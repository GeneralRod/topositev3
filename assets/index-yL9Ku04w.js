function kb(a, t) {
  for (var e = 0; e < t.length; e++) {
    const s = t[e];
    if (typeof s != 'string' && !Array.isArray(s)) {
      for (const l in s)
        if (l !== 'default' && !(l in a)) {
          const h = Object.getOwnPropertyDescriptor(s, l);
          h && Object.defineProperty(a, l, h.get ? h : { enumerable: !0, get: () => s[l] });
        }
    }
  }
  return Object.freeze(Object.defineProperty(a, Symbol.toStringTag, { value: 'Module' }));
}
(function () {
  const t = document.createElement('link').relList;
  if (t && t.supports && t.supports('modulepreload')) return;
  for (const l of document.querySelectorAll('link[rel="modulepreload"]')) s(l);
  new MutationObserver((l) => {
    for (const h of l)
      if (h.type === 'childList')
        for (const f of h.addedNodes) f.tagName === 'LINK' && f.rel === 'modulepreload' && s(f);
  }).observe(document, { childList: !0, subtree: !0 });
  function e(l) {
    const h = {};
    return (
      l.integrity && (h.integrity = l.integrity),
      l.referrerPolicy && (h.referrerPolicy = l.referrerPolicy),
      l.crossOrigin === 'use-credentials'
        ? (h.credentials = 'include')
        : l.crossOrigin === 'anonymous'
          ? (h.credentials = 'omit')
          : (h.credentials = 'same-origin'),
      h
    );
  }
  function s(l) {
    if (l.ep) return;
    l.ep = !0;
    const h = e(l);
    fetch(l.href, h);
  }
})();
function jx(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, 'default') ? a.default : a;
}
var Bp = { exports: {} },
  jc = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Q0;
function Fb() {
  if (Q0) return jc;
  Q0 = 1;
  var a = Symbol.for('react.transitional.element'),
    t = Symbol.for('react.fragment');
  function e(s, l, h) {
    var f = null;
    if ((h !== void 0 && (f = '' + h), l.key !== void 0 && (f = '' + l.key), 'key' in l)) {
      h = {};
      for (var m in l) m !== 'key' && (h[m] = l[m]);
    } else h = l;
    return (l = h.ref), { $$typeof: a, type: s, key: f, ref: l !== void 0 ? l : null, props: h };
  }
  return (jc.Fragment = t), (jc.jsx = e), (jc.jsxs = e), jc;
}
var J0;
function Hb() {
  return J0 || ((J0 = 1), (Bp.exports = Fb())), Bp.exports;
}
var at = Hb(),
  kp = { exports: {} },
  Ie = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var $0;
function Gb() {
  if ($0) return Ie;
  $0 = 1;
  var a = Symbol.for('react.transitional.element'),
    t = Symbol.for('react.portal'),
    e = Symbol.for('react.fragment'),
    s = Symbol.for('react.strict_mode'),
    l = Symbol.for('react.profiler'),
    h = Symbol.for('react.consumer'),
    f = Symbol.for('react.context'),
    m = Symbol.for('react.forward_ref'),
    _ = Symbol.for('react.suspense'),
    g = Symbol.for('react.memo'),
    x = Symbol.for('react.lazy'),
    S = Symbol.iterator;
  function b(N) {
    return N === null || typeof N != 'object'
      ? null
      : ((N = (S && N[S]) || N['@@iterator']), typeof N == 'function' ? N : null);
  }
  var E = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    A = Object.assign,
    R = {};
  function T(N, Q, gt) {
    (this.props = N), (this.context = Q), (this.refs = R), (this.updater = gt || E);
  }
  (T.prototype.isReactComponent = {}),
    (T.prototype.setState = function (N, Q) {
      if (typeof N != 'object' && typeof N != 'function' && N != null)
        throw Error(
          'takes an object of state variables to update or a function which returns an object of state variables.',
        );
      this.updater.enqueueSetState(this, N, Q, 'setState');
    }),
    (T.prototype.forceUpdate = function (N) {
      this.updater.enqueueForceUpdate(this, N, 'forceUpdate');
    });
  function M() {}
  M.prototype = T.prototype;
  function z(N, Q, gt) {
    (this.props = N), (this.context = Q), (this.refs = R), (this.updater = gt || E);
  }
  var P = (z.prototype = new M());
  (P.constructor = z), A(P, T.prototype), (P.isPureReactComponent = !0);
  var D = Array.isArray,
    W = { H: null, A: null, T: null, S: null, V: null },
    Z = Object.prototype.hasOwnProperty;
  function V(N, Q, gt, At, tt, st) {
    return (
      (gt = st.ref), { $$typeof: a, type: N, key: Q, ref: gt !== void 0 ? gt : null, props: st }
    );
  }
  function J(N, Q) {
    return V(N.type, Q, void 0, void 0, void 0, N.props);
  }
  function F(N) {
    return typeof N == 'object' && N !== null && N.$$typeof === a;
  }
  function I(N) {
    var Q = { '=': '=0', ':': '=2' };
    return (
      '$' +
      N.replace(/[=:]/g, function (gt) {
        return Q[gt];
      })
    );
  }
  var j = /\/+/g;
  function ft(N, Q) {
    return typeof N == 'object' && N !== null && N.key != null ? I('' + N.key) : Q.toString(36);
  }
  function pt() {}
  function Mt(N) {
    switch (N.status) {
      case 'fulfilled':
        return N.value;
      case 'rejected':
        throw N.reason;
      default:
        switch (
          (typeof N.status == 'string'
            ? N.then(pt, pt)
            : ((N.status = 'pending'),
              N.then(
                function (Q) {
                  N.status === 'pending' && ((N.status = 'fulfilled'), (N.value = Q));
                },
                function (Q) {
                  N.status === 'pending' && ((N.status = 'rejected'), (N.reason = Q));
                },
              )),
          N.status)
        ) {
          case 'fulfilled':
            return N.value;
          case 'rejected':
            throw N.reason;
        }
    }
    throw N;
  }
  function bt(N, Q, gt, At, tt) {
    var st = typeof N;
    (st === 'undefined' || st === 'boolean') && (N = null);
    var _t = !1;
    if (N === null) _t = !0;
    else
      switch (st) {
        case 'bigint':
        case 'string':
        case 'number':
          _t = !0;
          break;
        case 'object':
          switch (N.$$typeof) {
            case a:
            case t:
              _t = !0;
              break;
            case x:
              return (_t = N._init), bt(_t(N._payload), Q, gt, At, tt);
          }
      }
    if (_t)
      return (
        (tt = tt(N)),
        (_t = At === '' ? '.' + ft(N, 0) : At),
        D(tt)
          ? ((gt = ''),
            _t != null && (gt = _t.replace(j, '$&/') + '/'),
            bt(tt, Q, gt, '', function (fe) {
              return fe;
            }))
          : tt != null &&
            (F(tt) &&
              (tt = J(
                tt,
                gt +
                  (tt.key == null || (N && N.key === tt.key)
                    ? ''
                    : ('' + tt.key).replace(j, '$&/') + '/') +
                  _t,
              )),
            Q.push(tt)),
        1
      );
    _t = 0;
    var It = At === '' ? '.' : At + ':';
    if (D(N))
      for (var Gt = 0; Gt < N.length; Gt++)
        (At = N[Gt]), (st = It + ft(At, Gt)), (_t += bt(At, Q, gt, st, tt));
    else if (((Gt = b(N)), typeof Gt == 'function'))
      for (N = Gt.call(N), Gt = 0; !(At = N.next()).done; )
        (At = At.value), (st = It + ft(At, Gt++)), (_t += bt(At, Q, gt, st, tt));
    else if (st === 'object') {
      if (typeof N.then == 'function') return bt(Mt(N), Q, gt, At, tt);
      throw (
        ((Q = String(N)),
        Error(
          'Objects are not valid as a React child (found: ' +
            (Q === '[object Object]' ? 'object with keys {' + Object.keys(N).join(', ') + '}' : Q) +
            '). If you meant to render a collection of children, use an array instead.',
        ))
      );
    }
    return _t;
  }
  function X(N, Q, gt) {
    if (N == null) return N;
    var At = [],
      tt = 0;
    return (
      bt(N, At, '', '', function (st) {
        return Q.call(gt, st, tt++);
      }),
      At
    );
  }
  function it(N) {
    if (N._status === -1) {
      var Q = N._result;
      (Q = Q()),
        Q.then(
          function (gt) {
            (N._status === 0 || N._status === -1) && ((N._status = 1), (N._result = gt));
          },
          function (gt) {
            (N._status === 0 || N._status === -1) && ((N._status = 2), (N._result = gt));
          },
        ),
        N._status === -1 && ((N._status = 0), (N._result = Q));
    }
    if (N._status === 1) return N._result.default;
    throw N._result;
  }
  var K =
    typeof reportError == 'function'
      ? reportError
      : function (N) {
          if (typeof window == 'object' && typeof window.ErrorEvent == 'function') {
            var Q = new window.ErrorEvent('error', {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof N == 'object' && N !== null && typeof N.message == 'string'
                  ? String(N.message)
                  : String(N),
              error: N,
            });
            if (!window.dispatchEvent(Q)) return;
          } else if (typeof process == 'object' && typeof process.emit == 'function') {
            process.emit('uncaughtException', N);
            return;
          }
          console.error(N);
        };
  function zt() {}
  return (
    (Ie.Children = {
      map: X,
      forEach: function (N, Q, gt) {
        X(
          N,
          function () {
            Q.apply(this, arguments);
          },
          gt,
        );
      },
      count: function (N) {
        var Q = 0;
        return (
          X(N, function () {
            Q++;
          }),
          Q
        );
      },
      toArray: function (N) {
        return (
          X(N, function (Q) {
            return Q;
          }) || []
        );
      },
      only: function (N) {
        if (!F(N))
          throw Error('React.Children.only expected to receive a single React element child.');
        return N;
      },
    }),
    (Ie.Component = T),
    (Ie.Fragment = e),
    (Ie.Profiler = l),
    (Ie.PureComponent = z),
    (Ie.StrictMode = s),
    (Ie.Suspense = _),
    (Ie.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = W),
    (Ie.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function (N) {
        return W.H.useMemoCache(N);
      },
    }),
    (Ie.cache = function (N) {
      return function () {
        return N.apply(null, arguments);
      };
    }),
    (Ie.cloneElement = function (N, Q, gt) {
      if (N == null) throw Error('The argument must be a React element, but you passed ' + N + '.');
      var At = A({}, N.props),
        tt = N.key,
        st = void 0;
      if (Q != null)
        for (_t in (Q.ref !== void 0 && (st = void 0), Q.key !== void 0 && (tt = '' + Q.key), Q))
          !Z.call(Q, _t) ||
            _t === 'key' ||
            _t === '__self' ||
            _t === '__source' ||
            (_t === 'ref' && Q.ref === void 0) ||
            (At[_t] = Q[_t]);
      var _t = arguments.length - 2;
      if (_t === 1) At.children = gt;
      else if (1 < _t) {
        for (var It = Array(_t), Gt = 0; Gt < _t; Gt++) It[Gt] = arguments[Gt + 2];
        At.children = It;
      }
      return V(N.type, tt, void 0, void 0, st, At);
    }),
    (Ie.createContext = function (N) {
      return (
        (N = {
          $$typeof: f,
          _currentValue: N,
          _currentValue2: N,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
        }),
        (N.Provider = N),
        (N.Consumer = { $$typeof: h, _context: N }),
        N
      );
    }),
    (Ie.createElement = function (N, Q, gt) {
      var At,
        tt = {},
        st = null;
      if (Q != null)
        for (At in (Q.key !== void 0 && (st = '' + Q.key), Q))
          Z.call(Q, At) && At !== 'key' && At !== '__self' && At !== '__source' && (tt[At] = Q[At]);
      var _t = arguments.length - 2;
      if (_t === 1) tt.children = gt;
      else if (1 < _t) {
        for (var It = Array(_t), Gt = 0; Gt < _t; Gt++) It[Gt] = arguments[Gt + 2];
        tt.children = It;
      }
      if (N && N.defaultProps)
        for (At in ((_t = N.defaultProps), _t)) tt[At] === void 0 && (tt[At] = _t[At]);
      return V(N, st, void 0, void 0, null, tt);
    }),
    (Ie.createRef = function () {
      return { current: null };
    }),
    (Ie.forwardRef = function (N) {
      return { $$typeof: m, render: N };
    }),
    (Ie.isValidElement = F),
    (Ie.lazy = function (N) {
      return { $$typeof: x, _payload: { _status: -1, _result: N }, _init: it };
    }),
    (Ie.memo = function (N, Q) {
      return { $$typeof: g, type: N, compare: Q === void 0 ? null : Q };
    }),
    (Ie.startTransition = function (N) {
      var Q = W.T,
        gt = {};
      W.T = gt;
      try {
        var At = N(),
          tt = W.S;
        tt !== null && tt(gt, At),
          typeof At == 'object' && At !== null && typeof At.then == 'function' && At.then(zt, K);
      } catch (st) {
        K(st);
      } finally {
        W.T = Q;
      }
    }),
    (Ie.unstable_useCacheRefresh = function () {
      return W.H.useCacheRefresh();
    }),
    (Ie.use = function (N) {
      return W.H.use(N);
    }),
    (Ie.useActionState = function (N, Q, gt) {
      return W.H.useActionState(N, Q, gt);
    }),
    (Ie.useCallback = function (N, Q) {
      return W.H.useCallback(N, Q);
    }),
    (Ie.useContext = function (N) {
      return W.H.useContext(N);
    }),
    (Ie.useDebugValue = function () {}),
    (Ie.useDeferredValue = function (N, Q) {
      return W.H.useDeferredValue(N, Q);
    }),
    (Ie.useEffect = function (N, Q, gt) {
      var At = W.H;
      if (typeof gt == 'function')
        throw Error('useEffect CRUD overload is not enabled in this build of React.');
      return At.useEffect(N, Q);
    }),
    (Ie.useId = function () {
      return W.H.useId();
    }),
    (Ie.useImperativeHandle = function (N, Q, gt) {
      return W.H.useImperativeHandle(N, Q, gt);
    }),
    (Ie.useInsertionEffect = function (N, Q) {
      return W.H.useInsertionEffect(N, Q);
    }),
    (Ie.useLayoutEffect = function (N, Q) {
      return W.H.useLayoutEffect(N, Q);
    }),
    (Ie.useMemo = function (N, Q) {
      return W.H.useMemo(N, Q);
    }),
    (Ie.useOptimistic = function (N, Q) {
      return W.H.useOptimistic(N, Q);
    }),
    (Ie.useReducer = function (N, Q, gt) {
      return W.H.useReducer(N, Q, gt);
    }),
    (Ie.useRef = function (N) {
      return W.H.useRef(N);
    }),
    (Ie.useState = function (N) {
      return W.H.useState(N);
    }),
    (Ie.useSyncExternalStore = function (N, Q, gt) {
      return W.H.useSyncExternalStore(N, Q, gt);
    }),
    (Ie.useTransition = function () {
      return W.H.useTransition();
    }),
    (Ie.version = '19.1.0'),
    Ie
  );
}
var ty;
function D_() {
  return ty || ((ty = 1), (kp.exports = Gb())), kp.exports;
}
var ot = D_();
const pa = jx(ot),
  ey = kb({ __proto__: null, default: pa }, [ot]);
var Fp = { exports: {} },
  qc = {},
  Hp = { exports: {} },
  Gp = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ny;
function Vb() {
  return (
    ny ||
      ((ny = 1),
      (function (a) {
        function t(X, it) {
          var K = X.length;
          X.push(it);
          t: for (; 0 < K; ) {
            var zt = (K - 1) >>> 1,
              N = X[zt];
            if (0 < l(N, it)) (X[zt] = it), (X[K] = N), (K = zt);
            else break t;
          }
        }
        function e(X) {
          return X.length === 0 ? null : X[0];
        }
        function s(X) {
          if (X.length === 0) return null;
          var it = X[0],
            K = X.pop();
          if (K !== it) {
            X[0] = K;
            t: for (var zt = 0, N = X.length, Q = N >>> 1; zt < Q; ) {
              var gt = 2 * (zt + 1) - 1,
                At = X[gt],
                tt = gt + 1,
                st = X[tt];
              if (0 > l(At, K))
                tt < N && 0 > l(st, At)
                  ? ((X[zt] = st), (X[tt] = K), (zt = tt))
                  : ((X[zt] = At), (X[gt] = K), (zt = gt));
              else if (tt < N && 0 > l(st, K)) (X[zt] = st), (X[tt] = K), (zt = tt);
              else break t;
            }
          }
          return it;
        }
        function l(X, it) {
          var K = X.sortIndex - it.sortIndex;
          return K !== 0 ? K : X.id - it.id;
        }
        if (
          ((a.unstable_now = void 0),
          typeof performance == 'object' && typeof performance.now == 'function')
        ) {
          var h = performance;
          a.unstable_now = function () {
            return h.now();
          };
        } else {
          var f = Date,
            m = f.now();
          a.unstable_now = function () {
            return f.now() - m;
          };
        }
        var _ = [],
          g = [],
          x = 1,
          S = null,
          b = 3,
          E = !1,
          A = !1,
          R = !1,
          T = !1,
          M = typeof setTimeout == 'function' ? setTimeout : null,
          z = typeof clearTimeout == 'function' ? clearTimeout : null,
          P = typeof setImmediate < 'u' ? setImmediate : null;
        function D(X) {
          for (var it = e(g); it !== null; ) {
            if (it.callback === null) s(g);
            else if (it.startTime <= X) s(g), (it.sortIndex = it.expirationTime), t(_, it);
            else break;
            it = e(g);
          }
        }
        function W(X) {
          if (((R = !1), D(X), !A))
            if (e(_) !== null) (A = !0), Z || ((Z = !0), ft());
            else {
              var it = e(g);
              it !== null && bt(W, it.startTime - X);
            }
        }
        var Z = !1,
          V = -1,
          J = 5,
          F = -1;
        function I() {
          return T ? !0 : !(a.unstable_now() - F < J);
        }
        function j() {
          if (((T = !1), Z)) {
            var X = a.unstable_now();
            F = X;
            var it = !0;
            try {
              t: {
                (A = !1), R && ((R = !1), z(V), (V = -1)), (E = !0);
                var K = b;
                try {
                  e: {
                    for (D(X), S = e(_); S !== null && !(S.expirationTime > X && I()); ) {
                      var zt = S.callback;
                      if (typeof zt == 'function') {
                        (S.callback = null), (b = S.priorityLevel);
                        var N = zt(S.expirationTime <= X);
                        if (((X = a.unstable_now()), typeof N == 'function')) {
                          (S.callback = N), D(X), (it = !0);
                          break e;
                        }
                        S === e(_) && s(_), D(X);
                      } else s(_);
                      S = e(_);
                    }
                    if (S !== null) it = !0;
                    else {
                      var Q = e(g);
                      Q !== null && bt(W, Q.startTime - X), (it = !1);
                    }
                  }
                  break t;
                } finally {
                  (S = null), (b = K), (E = !1);
                }
                it = void 0;
              }
            } finally {
              it ? ft() : (Z = !1);
            }
          }
        }
        var ft;
        if (typeof P == 'function')
          ft = function () {
            P(j);
          };
        else if (typeof MessageChannel < 'u') {
          var pt = new MessageChannel(),
            Mt = pt.port2;
          (pt.port1.onmessage = j),
            (ft = function () {
              Mt.postMessage(null);
            });
        } else
          ft = function () {
            M(j, 0);
          };
        function bt(X, it) {
          V = M(function () {
            X(a.unstable_now());
          }, it);
        }
        (a.unstable_IdlePriority = 5),
          (a.unstable_ImmediatePriority = 1),
          (a.unstable_LowPriority = 4),
          (a.unstable_NormalPriority = 3),
          (a.unstable_Profiling = null),
          (a.unstable_UserBlockingPriority = 2),
          (a.unstable_cancelCallback = function (X) {
            X.callback = null;
          }),
          (a.unstable_forceFrameRate = function (X) {
            0 > X || 125 < X
              ? console.error(
                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported',
                )
              : (J = 0 < X ? Math.floor(1e3 / X) : 5);
          }),
          (a.unstable_getCurrentPriorityLevel = function () {
            return b;
          }),
          (a.unstable_next = function (X) {
            switch (b) {
              case 1:
              case 2:
              case 3:
                var it = 3;
                break;
              default:
                it = b;
            }
            var K = b;
            b = it;
            try {
              return X();
            } finally {
              b = K;
            }
          }),
          (a.unstable_requestPaint = function () {
            T = !0;
          }),
          (a.unstable_runWithPriority = function (X, it) {
            switch (X) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                X = 3;
            }
            var K = b;
            b = X;
            try {
              return it();
            } finally {
              b = K;
            }
          }),
          (a.unstable_scheduleCallback = function (X, it, K) {
            var zt = a.unstable_now();
            switch (
              (typeof K == 'object' && K !== null
                ? ((K = K.delay), (K = typeof K == 'number' && 0 < K ? zt + K : zt))
                : (K = zt),
              X)
            ) {
              case 1:
                var N = -1;
                break;
              case 2:
                N = 250;
                break;
              case 5:
                N = 1073741823;
                break;
              case 4:
                N = 1e4;
                break;
              default:
                N = 5e3;
            }
            return (
              (N = K + N),
              (X = {
                id: x++,
                callback: it,
                priorityLevel: X,
                startTime: K,
                expirationTime: N,
                sortIndex: -1,
              }),
              K > zt
                ? ((X.sortIndex = K),
                  t(g, X),
                  e(_) === null && X === e(g) && (R ? (z(V), (V = -1)) : (R = !0), bt(W, K - zt)))
                : ((X.sortIndex = N), t(_, X), A || E || ((A = !0), Z || ((Z = !0), ft()))),
              X
            );
          }),
          (a.unstable_shouldYield = I),
          (a.unstable_wrapCallback = function (X) {
            var it = b;
            return function () {
              var K = b;
              b = it;
              try {
                return X.apply(this, arguments);
              } finally {
                b = K;
              }
            };
          });
      })(Gp)),
    Gp
  );
}
var iy;
function Wb() {
  return iy || ((iy = 1), (Hp.exports = Vb())), Hp.exports;
}
var Vp = { exports: {} },
  pi = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ay;
function Zb() {
  if (ay) return pi;
  ay = 1;
  var a = D_();
  function t(_) {
    var g = 'https://react.dev/errors/' + _;
    if (1 < arguments.length) {
      g += '?args[]=' + encodeURIComponent(arguments[1]);
      for (var x = 2; x < arguments.length; x++) g += '&args[]=' + encodeURIComponent(arguments[x]);
    }
    return (
      'Minified React error #' +
      _ +
      '; visit ' +
      g +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    );
  }
  function e() {}
  var s = {
      d: {
        f: e,
        r: function () {
          throw Error(t(522));
        },
        D: e,
        C: e,
        L: e,
        m: e,
        X: e,
        S: e,
        M: e,
      },
      p: 0,
      findDOMNode: null,
    },
    l = Symbol.for('react.portal');
  function h(_, g, x) {
    var S = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: l,
      key: S == null ? null : '' + S,
      children: _,
      containerInfo: g,
      implementation: x,
    };
  }
  var f = a.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function m(_, g) {
    if (_ === 'font') return '';
    if (typeof g == 'string') return g === 'use-credentials' ? g : '';
  }
  return (
    (pi.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = s),
    (pi.createPortal = function (_, g) {
      var x = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!g || (g.nodeType !== 1 && g.nodeType !== 9 && g.nodeType !== 11)) throw Error(t(299));
      return h(_, g, null, x);
    }),
    (pi.flushSync = function (_) {
      var g = f.T,
        x = s.p;
      try {
        if (((f.T = null), (s.p = 2), _)) return _();
      } finally {
        (f.T = g), (s.p = x), s.d.f();
      }
    }),
    (pi.preconnect = function (_, g) {
      typeof _ == 'string' &&
        (g
          ? ((g = g.crossOrigin),
            (g = typeof g == 'string' ? (g === 'use-credentials' ? g : '') : void 0))
          : (g = null),
        s.d.C(_, g));
    }),
    (pi.prefetchDNS = function (_) {
      typeof _ == 'string' && s.d.D(_);
    }),
    (pi.preinit = function (_, g) {
      if (typeof _ == 'string' && g && typeof g.as == 'string') {
        var x = g.as,
          S = m(x, g.crossOrigin),
          b = typeof g.integrity == 'string' ? g.integrity : void 0,
          E = typeof g.fetchPriority == 'string' ? g.fetchPriority : void 0;
        x === 'style'
          ? s.d.S(_, typeof g.precedence == 'string' ? g.precedence : void 0, {
              crossOrigin: S,
              integrity: b,
              fetchPriority: E,
            })
          : x === 'script' &&
            s.d.X(_, {
              crossOrigin: S,
              integrity: b,
              fetchPriority: E,
              nonce: typeof g.nonce == 'string' ? g.nonce : void 0,
            });
      }
    }),
    (pi.preinitModule = function (_, g) {
      if (typeof _ == 'string')
        if (typeof g == 'object' && g !== null) {
          if (g.as == null || g.as === 'script') {
            var x = m(g.as, g.crossOrigin);
            s.d.M(_, {
              crossOrigin: x,
              integrity: typeof g.integrity == 'string' ? g.integrity : void 0,
              nonce: typeof g.nonce == 'string' ? g.nonce : void 0,
            });
          }
        } else g == null && s.d.M(_);
    }),
    (pi.preload = function (_, g) {
      if (typeof _ == 'string' && typeof g == 'object' && g !== null && typeof g.as == 'string') {
        var x = g.as,
          S = m(x, g.crossOrigin);
        s.d.L(_, x, {
          crossOrigin: S,
          integrity: typeof g.integrity == 'string' ? g.integrity : void 0,
          nonce: typeof g.nonce == 'string' ? g.nonce : void 0,
          type: typeof g.type == 'string' ? g.type : void 0,
          fetchPriority: typeof g.fetchPriority == 'string' ? g.fetchPriority : void 0,
          referrerPolicy: typeof g.referrerPolicy == 'string' ? g.referrerPolicy : void 0,
          imageSrcSet: typeof g.imageSrcSet == 'string' ? g.imageSrcSet : void 0,
          imageSizes: typeof g.imageSizes == 'string' ? g.imageSizes : void 0,
          media: typeof g.media == 'string' ? g.media : void 0,
        });
      }
    }),
    (pi.preloadModule = function (_, g) {
      if (typeof _ == 'string')
        if (g) {
          var x = m(g.as, g.crossOrigin);
          s.d.m(_, {
            as: typeof g.as == 'string' && g.as !== 'script' ? g.as : void 0,
            crossOrigin: x,
            integrity: typeof g.integrity == 'string' ? g.integrity : void 0,
          });
        } else s.d.m(_);
    }),
    (pi.requestFormReset = function (_) {
      s.d.r(_);
    }),
    (pi.unstable_batchedUpdates = function (_, g) {
      return _(g);
    }),
    (pi.useFormState = function (_, g, x) {
      return f.H.useFormState(_, g, x);
    }),
    (pi.useFormStatus = function () {
      return f.H.useHostTransitionStatus();
    }),
    (pi.version = '19.1.0'),
    pi
  );
}
var ry;
function qx() {
  if (ry) return Vp.exports;
  ry = 1;
  function a() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(a);
      } catch (t) {
        console.error(t);
      }
  }
  return a(), (Vp.exports = Zb()), Vp.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var sy;
function Xb() {
  if (sy) return qc;
  sy = 1;
  var a = Wb(),
    t = D_(),
    e = qx();
  function s(n) {
    var i = 'https://react.dev/errors/' + n;
    if (1 < arguments.length) {
      i += '?args[]=' + encodeURIComponent(arguments[1]);
      for (var o = 2; o < arguments.length; o++) i += '&args[]=' + encodeURIComponent(arguments[o]);
    }
    return (
      'Minified React error #' +
      n +
      '; visit ' +
      i +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    );
  }
  function l(n) {
    return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
  }
  function h(n) {
    var i = n,
      o = n;
    if (n.alternate) for (; i.return; ) i = i.return;
    else {
      n = i;
      do (i = n), (i.flags & 4098) !== 0 && (o = i.return), (n = i.return);
      while (n);
    }
    return i.tag === 3 ? o : null;
  }
  function f(n) {
    if (n.tag === 13) {
      var i = n.memoizedState;
      if ((i === null && ((n = n.alternate), n !== null && (i = n.memoizedState)), i !== null))
        return i.dehydrated;
    }
    return null;
  }
  function m(n) {
    if (h(n) !== n) throw Error(s(188));
  }
  function _(n) {
    var i = n.alternate;
    if (!i) {
      if (((i = h(n)), i === null)) throw Error(s(188));
      return i !== n ? null : n;
    }
    for (var o = n, u = i; ; ) {
      var p = o.return;
      if (p === null) break;
      var v = p.alternate;
      if (v === null) {
        if (((u = p.return), u !== null)) {
          o = u;
          continue;
        }
        break;
      }
      if (p.child === v.child) {
        for (v = p.child; v; ) {
          if (v === o) return m(p), n;
          if (v === u) return m(p), i;
          v = v.sibling;
        }
        throw Error(s(188));
      }
      if (o.return !== u.return) (o = p), (u = v);
      else {
        for (var C = !1, B = p.child; B; ) {
          if (B === o) {
            (C = !0), (o = p), (u = v);
            break;
          }
          if (B === u) {
            (C = !0), (u = p), (o = v);
            break;
          }
          B = B.sibling;
        }
        if (!C) {
          for (B = v.child; B; ) {
            if (B === o) {
              (C = !0), (o = v), (u = p);
              break;
            }
            if (B === u) {
              (C = !0), (u = v), (o = p);
              break;
            }
            B = B.sibling;
          }
          if (!C) throw Error(s(189));
        }
      }
      if (o.alternate !== u) throw Error(s(190));
    }
    if (o.tag !== 3) throw Error(s(188));
    return o.stateNode.current === o ? n : i;
  }
  function g(n) {
    var i = n.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return n;
    for (n = n.child; n !== null; ) {
      if (((i = g(n)), i !== null)) return i;
      n = n.sibling;
    }
    return null;
  }
  var x = Object.assign,
    S = Symbol.for('react.element'),
    b = Symbol.for('react.transitional.element'),
    E = Symbol.for('react.portal'),
    A = Symbol.for('react.fragment'),
    R = Symbol.for('react.strict_mode'),
    T = Symbol.for('react.profiler'),
    M = Symbol.for('react.provider'),
    z = Symbol.for('react.consumer'),
    P = Symbol.for('react.context'),
    D = Symbol.for('react.forward_ref'),
    W = Symbol.for('react.suspense'),
    Z = Symbol.for('react.suspense_list'),
    V = Symbol.for('react.memo'),
    J = Symbol.for('react.lazy'),
    F = Symbol.for('react.activity'),
    I = Symbol.for('react.memo_cache_sentinel'),
    j = Symbol.iterator;
  function ft(n) {
    return n === null || typeof n != 'object'
      ? null
      : ((n = (j && n[j]) || n['@@iterator']), typeof n == 'function' ? n : null);
  }
  var pt = Symbol.for('react.client.reference');
  function Mt(n) {
    if (n == null) return null;
    if (typeof n == 'function') return n.$$typeof === pt ? null : n.displayName || n.name || null;
    if (typeof n == 'string') return n;
    switch (n) {
      case A:
        return 'Fragment';
      case T:
        return 'Profiler';
      case R:
        return 'StrictMode';
      case W:
        return 'Suspense';
      case Z:
        return 'SuspenseList';
      case F:
        return 'Activity';
    }
    if (typeof n == 'object')
      switch (n.$$typeof) {
        case E:
          return 'Portal';
        case P:
          return (n.displayName || 'Context') + '.Provider';
        case z:
          return (n._context.displayName || 'Context') + '.Consumer';
        case D:
          var i = n.render;
          return (
            (n = n.displayName),
            n ||
              ((n = i.displayName || i.name || ''),
              (n = n !== '' ? 'ForwardRef(' + n + ')' : 'ForwardRef')),
            n
          );
        case V:
          return (i = n.displayName || null), i !== null ? i : Mt(n.type) || 'Memo';
        case J:
          (i = n._payload), (n = n._init);
          try {
            return Mt(n(i));
          } catch {}
      }
    return null;
  }
  var bt = Array.isArray,
    X = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    it = e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    K = { pending: !1, data: null, method: null, action: null },
    zt = [],
    N = -1;
  function Q(n) {
    return { current: n };
  }
  function gt(n) {
    0 > N || ((n.current = zt[N]), (zt[N] = null), N--);
  }
  function At(n, i) {
    N++, (zt[N] = n.current), (n.current = i);
  }
  var tt = Q(null),
    st = Q(null),
    _t = Q(null),
    It = Q(null);
  function Gt(n, i) {
    switch ((At(_t, i), At(st, n), At(tt, null), i.nodeType)) {
      case 9:
      case 11:
        n = (n = i.documentElement) && (n = n.namespaceURI) ? T0(n) : 0;
        break;
      default:
        if (((n = i.tagName), (i = i.namespaceURI))) (i = T0(i)), (n = w0(i, n));
        else
          switch (n) {
            case 'svg':
              n = 1;
              break;
            case 'math':
              n = 2;
              break;
            default:
              n = 0;
          }
    }
    gt(tt), At(tt, n);
  }
  function fe() {
    gt(tt), gt(st), gt(_t);
  }
  function oe(n) {
    n.memoizedState !== null && At(It, n);
    var i = tt.current,
      o = w0(i, n.type);
    i !== o && (At(st, n), At(tt, o));
  }
  function Ne(n) {
    st.current === n && (gt(tt), gt(st)), It.current === n && (gt(It), (Gc._currentValue = K));
  }
  var Te = Object.prototype.hasOwnProperty,
    ye = a.unstable_scheduleCallback,
    G = a.unstable_cancelCallback,
    Zt = a.unstable_shouldYield,
    Bt = a.unstable_requestPaint,
    Ut = a.unstable_now,
    Lt = a.unstable_getCurrentPriorityLevel,
    le = a.unstable_ImmediatePriority,
    kt = a.unstable_UserBlockingPriority,
    H = a.unstable_NormalPriority,
    O = a.unstable_LowPriority,
    rt = a.unstable_IdlePriority,
    wt = a.log,
    Dt = a.unstable_setDisableYieldValue,
    Et = null,
    Xt = null;
  function Wt(n) {
    if ((typeof wt == 'function' && Dt(n), Xt && typeof Xt.setStrictMode == 'function'))
      try {
        Xt.setStrictMode(Et, n);
      } catch {}
  }
  var $t = Math.clz32 ? Math.clz32 : re,
    ce = Math.log,
    Ht = Math.LN2;
  function re(n) {
    return (n >>>= 0), n === 0 ? 32 : (31 - ((ce(n) / Ht) | 0)) | 0;
  }
  var pe = 256,
    Se = 4194304;
  function Qt(n) {
    var i = n & 42;
    if (i !== 0) return i;
    switch (n & -n) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return n & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return n;
    }
  }
  function Oe(n, i, o) {
    var u = n.pendingLanes;
    if (u === 0) return 0;
    var p = 0,
      v = n.suspendedLanes,
      C = n.pingedLanes;
    n = n.warmLanes;
    var B = u & 134217727;
    return (
      B !== 0
        ? ((u = B & ~v),
          u !== 0
            ? (p = Qt(u))
            : ((C &= B), C !== 0 ? (p = Qt(C)) : o || ((o = B & ~n), o !== 0 && (p = Qt(o)))))
        : ((B = u & ~v),
          B !== 0
            ? (p = Qt(B))
            : C !== 0
              ? (p = Qt(C))
              : o || ((o = u & ~n), o !== 0 && (p = Qt(o)))),
      p === 0
        ? 0
        : i !== 0 &&
            i !== p &&
            (i & v) === 0 &&
            ((v = p & -p), (o = i & -i), v >= o || (v === 32 && (o & 4194048) !== 0))
          ? i
          : p
    );
  }
  function Me(n, i) {
    return (n.pendingLanes & ~(n.suspendedLanes & ~n.pingedLanes) & i) === 0;
  }
  function Je(n, i) {
    switch (n) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return i + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function nt() {
    var n = pe;
    return (pe <<= 1), (pe & 4194048) === 0 && (pe = 256), n;
  }
  function qt() {
    var n = Se;
    return (Se <<= 1), (Se & 62914560) === 0 && (Se = 4194304), n;
  }
  function Ct(n) {
    for (var i = [], o = 0; 31 > o; o++) i.push(n);
    return i;
  }
  function Ot(n, i) {
    (n.pendingLanes |= i),
      i !== 268435456 && ((n.suspendedLanes = 0), (n.pingedLanes = 0), (n.warmLanes = 0));
  }
  function ae(n, i, o, u, p, v) {
    var C = n.pendingLanes;
    (n.pendingLanes = o),
      (n.suspendedLanes = 0),
      (n.pingedLanes = 0),
      (n.warmLanes = 0),
      (n.expiredLanes &= o),
      (n.entangledLanes &= o),
      (n.errorRecoveryDisabledLanes &= o),
      (n.shellSuspendCounter = 0);
    var B = n.entanglements,
      Y = n.expirationTimes,
      mt = n.hiddenUpdates;
    for (o = C & ~o; 0 < o; ) {
      var Rt = 31 - $t(o),
        Nt = 1 << Rt;
      (B[Rt] = 0), (Y[Rt] = -1);
      var vt = mt[Rt];
      if (vt !== null)
        for (mt[Rt] = null, Rt = 0; Rt < vt.length; Rt++) {
          var xt = vt[Rt];
          xt !== null && (xt.lane &= -536870913);
        }
      o &= ~Nt;
    }
    u !== 0 && te(n, u, 0),
      v !== 0 && p === 0 && n.tag !== 0 && (n.suspendedLanes |= v & ~(C & ~i));
  }
  function te(n, i, o) {
    (n.pendingLanes |= i), (n.suspendedLanes &= ~i);
    var u = 31 - $t(i);
    (n.entangledLanes |= i), (n.entanglements[u] = n.entanglements[u] | 1073741824 | (o & 4194090));
  }
  function Pe(n, i) {
    var o = (n.entangledLanes |= i);
    for (n = n.entanglements; o; ) {
      var u = 31 - $t(o),
        p = 1 << u;
      (p & i) | (n[u] & i) && (n[u] |= i), (o &= ~p);
    }
  }
  function cn(n) {
    switch (n) {
      case 2:
        n = 1;
        break;
      case 8:
        n = 4;
        break;
      case 32:
        n = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        n = 128;
        break;
      case 268435456:
        n = 134217728;
        break;
      default:
        n = 0;
    }
    return n;
  }
  function Rn(n) {
    return (n &= -n), 2 < n ? (8 < n ? ((n & 134217727) !== 0 ? 32 : 268435456) : 8) : 2;
  }
  function Ye() {
    var n = it.p;
    return n !== 0 ? n : ((n = window.event), n === void 0 ? 32 : Z0(n.type));
  }
  function ii(n, i) {
    var o = it.p;
    try {
      return (it.p = n), i();
    } finally {
      it.p = o;
    }
  }
  var kn = Math.random().toString(36).slice(2),
    Nn = '__reactFiber$' + kn,
    Wn = '__reactProps$' + kn,
    ui = '__reactContainer$' + kn,
    Kn = '__reactEvents$' + kn,
    me = '__reactListeners$' + kn,
    Is = '__reactHandles$' + kn,
    Oa = '__reactResources$' + kn,
    _a = '__reactMarker$' + kn;
  function ga(n) {
    delete n[Nn], delete n[Wn], delete n[Kn], delete n[me], delete n[Is];
  }
  function Ii(n) {
    var i = n[Nn];
    if (i) return i;
    for (var o = n.parentNode; o; ) {
      if ((i = o[ui] || o[Nn])) {
        if (((o = i.alternate), i.child !== null || (o !== null && o.child !== null)))
          for (n = L0(n); n !== null; ) {
            if ((o = n[Nn])) return o;
            n = L0(n);
          }
        return i;
      }
      (n = o), (o = n.parentNode);
    }
    return null;
  }
  function ta(n) {
    if ((n = n[Nn] || n[ui])) {
      var i = n.tag;
      if (i === 5 || i === 6 || i === 13 || i === 26 || i === 27 || i === 3) return n;
    }
    return null;
  }
  function Ci(n) {
    var i = n.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return n.stateNode;
    throw Error(s(33));
  }
  function va(n) {
    var i = n[Oa];
    return i || (i = n[Oa] = { hoistableStyles: new Map(), hoistableScripts: new Map() }), i;
  }
  function Ln(n) {
    n[_a] = !0;
  }
  var Ro = new Set(),
    Lo = {};
  function ya(n, i) {
    k(n, i), k(n + 'Capture', i);
  }
  function k(n, i) {
    for (Lo[n] = i, n = 0; n < i.length; n++) Ro.add(i[n]);
  }
  var lt = RegExp(
      '^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$',
    ),
    yt = {},
    Tt = {};
  function ut(n) {
    return Te.call(Tt, n)
      ? !0
      : Te.call(yt, n)
        ? !1
        : lt.test(n)
          ? (Tt[n] = !0)
          : ((yt[n] = !0), !1);
  }
  function Vt(n, i, o) {
    if (ut(i))
      if (o === null) n.removeAttribute(i);
      else {
        switch (typeof o) {
          case 'undefined':
          case 'function':
          case 'symbol':
            n.removeAttribute(i);
            return;
          case 'boolean':
            var u = i.toLowerCase().slice(0, 5);
            if (u !== 'data-' && u !== 'aria-') {
              n.removeAttribute(i);
              return;
            }
        }
        n.setAttribute(i, '' + o);
      }
  }
  function Kt(n, i, o) {
    if (o === null) n.removeAttribute(i);
    else {
      switch (typeof o) {
        case 'undefined':
        case 'function':
        case 'symbol':
        case 'boolean':
          n.removeAttribute(i);
          return;
      }
      n.setAttribute(i, '' + o);
    }
  }
  function Jt(n, i, o, u) {
    if (u === null) n.removeAttribute(o);
    else {
      switch (typeof u) {
        case 'undefined':
        case 'function':
        case 'symbol':
        case 'boolean':
          n.removeAttribute(o);
          return;
      }
      n.setAttributeNS(i, o, '' + u);
    }
  }
  var se, Ee;
  function be(n) {
    if (se === void 0)
      try {
        throw Error();
      } catch (o) {
        var i = o.stack.trim().match(/\n( *(at )?)/);
        (se = (i && i[1]) || ''),
          (Ee =
            -1 <
            o.stack.indexOf(`
    at`)
              ? ' (<anonymous>)'
              : -1 < o.stack.indexOf('@')
                ? '@unknown:0:0'
                : '');
      }
    return (
      `
` +
      se +
      n +
      Ee
    );
  }
  var ve = !1;
  function Ue(n, i) {
    if (!n || ve) return '';
    ve = !0;
    var o = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var u = {
        DetermineComponentFrameRoot: function () {
          try {
            if (i) {
              var Nt = function () {
                throw Error();
              };
              if (
                (Object.defineProperty(Nt.prototype, 'props', {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == 'object' && Reflect.construct)
              ) {
                try {
                  Reflect.construct(Nt, []);
                } catch (xt) {
                  var vt = xt;
                }
                Reflect.construct(n, [], Nt);
              } else {
                try {
                  Nt.call();
                } catch (xt) {
                  vt = xt;
                }
                n.call(Nt.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (xt) {
                vt = xt;
              }
              (Nt = n()) && typeof Nt.catch == 'function' && Nt.catch(function () {});
            }
          } catch (xt) {
            if (xt && vt && typeof xt.stack == 'string') return [xt.stack, vt.stack];
          }
          return [null, null];
        },
      };
      u.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';
      var p = Object.getOwnPropertyDescriptor(u.DetermineComponentFrameRoot, 'name');
      p &&
        p.configurable &&
        Object.defineProperty(u.DetermineComponentFrameRoot, 'name', {
          value: 'DetermineComponentFrameRoot',
        });
      var v = u.DetermineComponentFrameRoot(),
        C = v[0],
        B = v[1];
      if (C && B) {
        var Y = C.split(`
`),
          mt = B.split(`
`);
        for (p = u = 0; u < Y.length && !Y[u].includes('DetermineComponentFrameRoot'); ) u++;
        for (; p < mt.length && !mt[p].includes('DetermineComponentFrameRoot'); ) p++;
        if (u === Y.length || p === mt.length)
          for (u = Y.length - 1, p = mt.length - 1; 1 <= u && 0 <= p && Y[u] !== mt[p]; ) p--;
        for (; 1 <= u && 0 <= p; u--, p--)
          if (Y[u] !== mt[p]) {
            if (u !== 1 || p !== 1)
              do
                if ((u--, p--, 0 > p || Y[u] !== mt[p])) {
                  var Rt =
                    `
` + Y[u].replace(' at new ', ' at ');
                  return (
                    n.displayName &&
                      Rt.includes('<anonymous>') &&
                      (Rt = Rt.replace('<anonymous>', n.displayName)),
                    Rt
                  );
                }
              while (1 <= u && 0 <= p);
            break;
          }
      }
    } finally {
      (ve = !1), (Error.prepareStackTrace = o);
    }
    return (o = n ? n.displayName || n.name : '') ? be(o) : '';
  }
  function ue(n) {
    switch (n.tag) {
      case 26:
      case 27:
      case 5:
        return be(n.type);
      case 16:
        return be('Lazy');
      case 13:
        return be('Suspense');
      case 19:
        return be('SuspenseList');
      case 0:
      case 15:
        return Ue(n.type, !1);
      case 11:
        return Ue(n.type.render, !1);
      case 1:
        return Ue(n.type, !0);
      case 31:
        return be('Activity');
      default:
        return '';
    }
  }
  function Re(n) {
    try {
      var i = '';
      do (i += ue(n)), (n = n.return);
      while (n);
      return i;
    } catch (o) {
      return (
        `
Error generating stack: ` +
        o.message +
        `
` +
        o.stack
      );
    }
  }
  function ke(n) {
    switch (typeof n) {
      case 'bigint':
      case 'boolean':
      case 'number':
      case 'string':
      case 'undefined':
        return n;
      case 'object':
        return n;
      default:
        return '';
    }
  }
  function ze(n) {
    var i = n.type;
    return (n = n.nodeName) && n.toLowerCase() === 'input' && (i === 'checkbox' || i === 'radio');
  }
  function ge(n) {
    var i = ze(n) ? 'checked' : 'value',
      o = Object.getOwnPropertyDescriptor(n.constructor.prototype, i),
      u = '' + n[i];
    if (
      !n.hasOwnProperty(i) &&
      typeof o < 'u' &&
      typeof o.get == 'function' &&
      typeof o.set == 'function'
    ) {
      var p = o.get,
        v = o.set;
      return (
        Object.defineProperty(n, i, {
          configurable: !0,
          get: function () {
            return p.call(this);
          },
          set: function (C) {
            (u = '' + C), v.call(this, C);
          },
        }),
        Object.defineProperty(n, i, { enumerable: o.enumerable }),
        {
          getValue: function () {
            return u;
          },
          setValue: function (C) {
            u = '' + C;
          },
          stopTracking: function () {
            (n._valueTracker = null), delete n[i];
          },
        }
      );
    }
  }
  function gn(n) {
    n._valueTracker || (n._valueTracker = ge(n));
  }
  function ne(n) {
    if (!n) return !1;
    var i = n._valueTracker;
    if (!i) return !0;
    var o = i.getValue(),
      u = '';
    return (
      n && (u = ze(n) ? (n.checked ? 'true' : 'false') : n.value),
      (n = u),
      n !== o ? (i.setValue(n), !0) : !1
    );
  }
  function We(n) {
    if (((n = n || (typeof document < 'u' ? document : void 0)), typeof n > 'u')) return null;
    try {
      return n.activeElement || n.body;
    } catch {
      return n.body;
    }
  }
  var ea = /[\n"\\]/g;
  function nn(n) {
    return n.replace(ea, function (i) {
      return '\\' + i.charCodeAt(0).toString(16) + ' ';
    });
  }
  function Pn(n, i, o, u, p, v, C, B) {
    (n.name = ''),
      C != null && typeof C != 'function' && typeof C != 'symbol' && typeof C != 'boolean'
        ? (n.type = C)
        : n.removeAttribute('type'),
      i != null
        ? C === 'number'
          ? ((i === 0 && n.value === '') || n.value != i) && (n.value = '' + ke(i))
          : n.value !== '' + ke(i) && (n.value = '' + ke(i))
        : (C !== 'submit' && C !== 'reset') || n.removeAttribute('value'),
      i != null
        ? zn(n, C, ke(i))
        : o != null
          ? zn(n, C, ke(o))
          : u != null && n.removeAttribute('value'),
      p == null && v != null && (n.defaultChecked = !!v),
      p != null && (n.checked = p && typeof p != 'function' && typeof p != 'symbol'),
      B != null && typeof B != 'function' && typeof B != 'symbol' && typeof B != 'boolean'
        ? (n.name = '' + ke(B))
        : n.removeAttribute('name');
  }
  function sn(n, i, o, u, p, v, C, B) {
    if (
      (v != null &&
        typeof v != 'function' &&
        typeof v != 'symbol' &&
        typeof v != 'boolean' &&
        (n.type = v),
      i != null || o != null)
    ) {
      if (!((v !== 'submit' && v !== 'reset') || i != null)) return;
      (o = o != null ? '' + ke(o) : ''),
        (i = i != null ? '' + ke(i) : o),
        B || i === n.value || (n.value = i),
        (n.defaultValue = i);
    }
    (u = u ?? p),
      (u = typeof u != 'function' && typeof u != 'symbol' && !!u),
      (n.checked = B ? n.checked : !!u),
      (n.defaultChecked = !!u),
      C != null &&
        typeof C != 'function' &&
        typeof C != 'symbol' &&
        typeof C != 'boolean' &&
        (n.name = C);
  }
  function zn(n, i, o) {
    (i === 'number' && We(n.ownerDocument) === n) ||
      n.defaultValue === '' + o ||
      (n.defaultValue = '' + o);
  }
  function mn(n, i, o, u) {
    if (((n = n.options), i)) {
      i = {};
      for (var p = 0; p < o.length; p++) i['$' + o[p]] = !0;
      for (o = 0; o < n.length; o++)
        (p = i.hasOwnProperty('$' + n[o].value)),
          n[o].selected !== p && (n[o].selected = p),
          p && u && (n[o].defaultSelected = !0);
    } else {
      for (o = '' + ke(o), i = null, p = 0; p < n.length; p++) {
        if (n[p].value === o) {
          (n[p].selected = !0), u && (n[p].defaultSelected = !0);
          return;
        }
        i !== null || n[p].disabled || (i = n[p]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function He(n, i, o) {
    if (i != null && ((i = '' + ke(i)), i !== n.value && (n.value = i), o == null)) {
      n.defaultValue !== i && (n.defaultValue = i);
      return;
    }
    n.defaultValue = o != null ? '' + ke(o) : '';
  }
  function xn(n, i, o, u) {
    if (i == null) {
      if (u != null) {
        if (o != null) throw Error(s(92));
        if (bt(u)) {
          if (1 < u.length) throw Error(s(93));
          u = u[0];
        }
        o = u;
      }
      o == null && (o = ''), (i = o);
    }
    (o = ke(i)),
      (n.defaultValue = o),
      (u = n.textContent),
      u === o && u !== '' && u !== null && (n.value = u);
  }
  function hi(n, i) {
    if (i) {
      var o = n.firstChild;
      if (o && o === n.lastChild && o.nodeType === 3) {
        o.nodeValue = i;
        return;
      }
    }
    n.textContent = i;
  }
  var yi = new Set(
    'animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp'.split(
      ' ',
    ),
  );
  function Po(n, i, o) {
    var u = i.indexOf('--') === 0;
    o == null || typeof o == 'boolean' || o === ''
      ? u
        ? n.setProperty(i, '')
        : i === 'float'
          ? (n.cssFloat = '')
          : (n[i] = '')
      : u
        ? n.setProperty(i, o)
        : typeof o != 'number' || o === 0 || yi.has(i)
          ? i === 'float'
            ? (n.cssFloat = o)
            : (n[i] = ('' + o).trim())
          : (n[i] = o + 'px');
  }
  function Fr(n, i, o) {
    if (i != null && typeof i != 'object') throw Error(s(62));
    if (((n = n.style), o != null)) {
      for (var u in o)
        !o.hasOwnProperty(u) ||
          (i != null && i.hasOwnProperty(u)) ||
          (u.indexOf('--') === 0
            ? n.setProperty(u, '')
            : u === 'float'
              ? (n.cssFloat = '')
              : (n[u] = ''));
      for (var p in i) (u = i[p]), i.hasOwnProperty(p) && o[p] !== u && Po(n, p, u);
    } else for (var v in i) i.hasOwnProperty(v) && Po(n, v, i[v]);
  }
  function Bs(n) {
    if (n.indexOf('-') === -1) return !1;
    switch (n) {
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return !1;
      default:
        return !0;
    }
  }
  var Jl = new Map([
      ['acceptCharset', 'accept-charset'],
      ['htmlFor', 'for'],
      ['httpEquiv', 'http-equiv'],
      ['crossOrigin', 'crossorigin'],
      ['accentHeight', 'accent-height'],
      ['alignmentBaseline', 'alignment-baseline'],
      ['arabicForm', 'arabic-form'],
      ['baselineShift', 'baseline-shift'],
      ['capHeight', 'cap-height'],
      ['clipPath', 'clip-path'],
      ['clipRule', 'clip-rule'],
      ['colorInterpolation', 'color-interpolation'],
      ['colorInterpolationFilters', 'color-interpolation-filters'],
      ['colorProfile', 'color-profile'],
      ['colorRendering', 'color-rendering'],
      ['dominantBaseline', 'dominant-baseline'],
      ['enableBackground', 'enable-background'],
      ['fillOpacity', 'fill-opacity'],
      ['fillRule', 'fill-rule'],
      ['floodColor', 'flood-color'],
      ['floodOpacity', 'flood-opacity'],
      ['fontFamily', 'font-family'],
      ['fontSize', 'font-size'],
      ['fontSizeAdjust', 'font-size-adjust'],
      ['fontStretch', 'font-stretch'],
      ['fontStyle', 'font-style'],
      ['fontVariant', 'font-variant'],
      ['fontWeight', 'font-weight'],
      ['glyphName', 'glyph-name'],
      ['glyphOrientationHorizontal', 'glyph-orientation-horizontal'],
      ['glyphOrientationVertical', 'glyph-orientation-vertical'],
      ['horizAdvX', 'horiz-adv-x'],
      ['horizOriginX', 'horiz-origin-x'],
      ['imageRendering', 'image-rendering'],
      ['letterSpacing', 'letter-spacing'],
      ['lightingColor', 'lighting-color'],
      ['markerEnd', 'marker-end'],
      ['markerMid', 'marker-mid'],
      ['markerStart', 'marker-start'],
      ['overlinePosition', 'overline-position'],
      ['overlineThickness', 'overline-thickness'],
      ['paintOrder', 'paint-order'],
      ['panose-1', 'panose-1'],
      ['pointerEvents', 'pointer-events'],
      ['renderingIntent', 'rendering-intent'],
      ['shapeRendering', 'shape-rendering'],
      ['stopColor', 'stop-color'],
      ['stopOpacity', 'stop-opacity'],
      ['strikethroughPosition', 'strikethrough-position'],
      ['strikethroughThickness', 'strikethrough-thickness'],
      ['strokeDasharray', 'stroke-dasharray'],
      ['strokeDashoffset', 'stroke-dashoffset'],
      ['strokeLinecap', 'stroke-linecap'],
      ['strokeLinejoin', 'stroke-linejoin'],
      ['strokeMiterlimit', 'stroke-miterlimit'],
      ['strokeOpacity', 'stroke-opacity'],
      ['strokeWidth', 'stroke-width'],
      ['textAnchor', 'text-anchor'],
      ['textDecoration', 'text-decoration'],
      ['textRendering', 'text-rendering'],
      ['transformOrigin', 'transform-origin'],
      ['underlinePosition', 'underline-position'],
      ['underlineThickness', 'underline-thickness'],
      ['unicodeBidi', 'unicode-bidi'],
      ['unicodeRange', 'unicode-range'],
      ['unitsPerEm', 'units-per-em'],
      ['vAlphabetic', 'v-alphabetic'],
      ['vHanging', 'v-hanging'],
      ['vIdeographic', 'v-ideographic'],
      ['vMathematical', 'v-mathematical'],
      ['vectorEffect', 'vector-effect'],
      ['vertAdvY', 'vert-adv-y'],
      ['vertOriginX', 'vert-origin-x'],
      ['vertOriginY', 'vert-origin-y'],
      ['wordSpacing', 'word-spacing'],
      ['writingMode', 'writing-mode'],
      ['xmlnsXlink', 'xmlns:xlink'],
      ['xHeight', 'x-height'],
    ]),
    Do =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Hr(n) {
    return Do.test('' + n)
      ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
      : n;
  }
  var ks = null;
  function Gr(n) {
    return (
      (n = n.target || n.srcElement || window),
      n.correspondingUseElement && (n = n.correspondingUseElement),
      n.nodeType === 3 ? n.parentNode : n
    );
  }
  var er = null,
    Ua = null;
  function Au(n) {
    var i = ta(n);
    if (i && (n = i.stateNode)) {
      var o = n[Wn] || null;
      t: switch (((n = i.stateNode), i.type)) {
        case 'input':
          if (
            (Pn(
              n,
              o.value,
              o.defaultValue,
              o.defaultValue,
              o.checked,
              o.defaultChecked,
              o.type,
              o.name,
            ),
            (i = o.name),
            o.type === 'radio' && i != null)
          ) {
            for (o = n; o.parentNode; ) o = o.parentNode;
            for (
              o = o.querySelectorAll('input[name="' + nn('' + i) + '"][type="radio"]'), i = 0;
              i < o.length;
              i++
            ) {
              var u = o[i];
              if (u !== n && u.form === n.form) {
                var p = u[Wn] || null;
                if (!p) throw Error(s(90));
                Pn(
                  u,
                  p.value,
                  p.defaultValue,
                  p.defaultValue,
                  p.checked,
                  p.defaultChecked,
                  p.type,
                  p.name,
                );
              }
            }
            for (i = 0; i < o.length; i++) (u = o[i]), u.form === n.form && ne(u);
          }
          break t;
        case 'textarea':
          He(n, o.value, o.defaultValue);
          break t;
        case 'select':
          (i = o.value), i != null && mn(n, !!o.multiple, i, !1);
      }
    }
  }
  var De = !1;
  function Bi(n, i, o) {
    if (De) return n(i, o);
    De = !0;
    try {
      var u = n(i);
      return u;
    } finally {
      if (
        ((De = !1),
        (er !== null || Ua !== null) &&
          (Sh(), er && ((i = er), (n = Ua), (Ua = er = null), Au(i), n)))
      )
        for (i = 0; i < n.length; i++) Au(n[i]);
    }
  }
  function $e(n, i) {
    var o = n.stateNode;
    if (o === null) return null;
    var u = o[Wn] || null;
    if (u === null) return null;
    o = u[i];
    t: switch (i) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
      case 'onMouseEnter':
        (u = !u.disabled) ||
          ((n = n.type),
          (u = !(n === 'button' || n === 'input' || n === 'select' || n === 'textarea'))),
          (n = !u);
        break t;
      default:
        n = !1;
    }
    if (n) return null;
    if (o && typeof o != 'function') throw Error(s(231, i, typeof o));
    return o;
  }
  var na = !(
      typeof window > 'u' ||
      typeof window.document > 'u' ||
      typeof window.document.createElement > 'u'
    ),
    Fs = !1;
  if (na)
    try {
      var nr = {};
      Object.defineProperty(nr, 'passive', {
        get: function () {
          Fs = !0;
        },
      }),
        window.addEventListener('test', nr, nr),
        window.removeEventListener('test', nr, nr);
    } catch {
      Fs = !1;
    }
  var ia = null,
    xa = null,
    Vr = null;
  function Wr() {
    if (Vr) return Vr;
    var n,
      i = xa,
      o = i.length,
      u,
      p = 'value' in ia ? ia.value : ia.textContent,
      v = p.length;
    for (n = 0; n < o && i[n] === p[n]; n++);
    var C = o - n;
    for (u = 1; u <= C && i[o - u] === p[v - u]; u++);
    return (Vr = p.slice(n, 1 < u ? 1 - u : void 0));
  }
  function Dn(n) {
    var i = n.keyCode;
    return (
      'charCode' in n ? ((n = n.charCode), n === 0 && i === 13 && (n = 13)) : (n = i),
      n === 10 && (n = 13),
      32 <= n || n === 13 ? n : 0
    );
  }
  function aa() {
    return !0;
  }
  function $l() {
    return !1;
  }
  function ai(n) {
    function i(o, u, p, v, C) {
      (this._reactName = o),
        (this._targetInst = p),
        (this.type = u),
        (this.nativeEvent = v),
        (this.target = C),
        (this.currentTarget = null);
      for (var B in n) n.hasOwnProperty(B) && ((o = n[B]), (this[B] = o ? o(v) : v[B]));
      return (
        (this.isDefaultPrevented = (
          v.defaultPrevented != null ? v.defaultPrevented : v.returnValue === !1
        )
          ? aa
          : $l),
        (this.isPropagationStopped = $l),
        this
      );
    }
    return (
      x(i.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var o = this.nativeEvent;
          o &&
            (o.preventDefault
              ? o.preventDefault()
              : typeof o.returnValue != 'unknown' && (o.returnValue = !1),
            (this.isDefaultPrevented = aa));
        },
        stopPropagation: function () {
          var o = this.nativeEvent;
          o &&
            (o.stopPropagation
              ? o.stopPropagation()
              : typeof o.cancelBubble != 'unknown' && (o.cancelBubble = !0),
            (this.isPropagationStopped = aa));
        },
        persist: function () {},
        isPersistent: aa,
      }),
      i
    );
  }
  var ir = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (n) {
        return n.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    Hs = ai(ir),
    ar = x({}, ir, { view: 0, detail: 0 }),
    Kf = ai(ar),
    Oo,
    Ze,
    Gs,
    fi = x({}, ar, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Uo,
      button: 0,
      buttons: 0,
      relatedTarget: function (n) {
        return n.relatedTarget === void 0
          ? n.fromElement === n.srcElement
            ? n.toElement
            : n.fromElement
          : n.relatedTarget;
      },
      movementX: function (n) {
        return 'movementX' in n
          ? n.movementX
          : (n !== Gs &&
              (Gs && n.type === 'mousemove'
                ? ((Oo = n.screenX - Gs.screenX), (Ze = n.screenY - Gs.screenY))
                : (Ze = Oo = 0),
              (Gs = n)),
            Oo);
      },
      movementY: function (n) {
        return 'movementY' in n ? n.movementY : Ze;
      },
    }),
    Zr = ai(fi),
    Cu = x({}, fi, { dataTransfer: 0 }),
    Qf = ai(Cu),
    tc = x({}, ar, { relatedTarget: 0 }),
    ec = ai(tc),
    Ru = x({}, ir, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Jf = ai(Ru),
    $f = x({}, ir, {
      clipboardData: function (n) {
        return 'clipboardData' in n ? n.clipboardData : window.clipboardData;
      },
    }),
    nc = ai($f),
    td = x({}, ir, { data: 0 }),
    ki = ai(td),
    ed = {
      Esc: 'Escape',
      Spacebar: ' ',
      Left: 'ArrowLeft',
      Up: 'ArrowUp',
      Right: 'ArrowRight',
      Down: 'ArrowDown',
      Del: 'Delete',
      Win: 'OS',
      Menu: 'ContextMenu',
      Apps: 'ContextMenu',
      Scroll: 'ScrollLock',
      MozPrintableKey: 'Unidentified',
    },
    Lu = {
      8: 'Backspace',
      9: 'Tab',
      12: 'Clear',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Escape',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      45: 'Insert',
      46: 'Delete',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'NumLock',
      145: 'ScrollLock',
      224: 'Meta',
    },
    Na = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' };
  function Pu(n) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(n) : (n = Na[n]) ? !!i[n] : !1;
  }
  function Uo() {
    return Pu;
  }
  var ic = x({}, ar, {
      key: function (n) {
        if (n.key) {
          var i = ed[n.key] || n.key;
          if (i !== 'Unidentified') return i;
        }
        return n.type === 'keypress'
          ? ((n = Dn(n)), n === 13 ? 'Enter' : String.fromCharCode(n))
          : n.type === 'keydown' || n.type === 'keyup'
            ? Lu[n.keyCode] || 'Unidentified'
            : '';
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Uo,
      charCode: function (n) {
        return n.type === 'keypress' ? Dn(n) : 0;
      },
      keyCode: function (n) {
        return n.type === 'keydown' || n.type === 'keyup' ? n.keyCode : 0;
      },
      which: function (n) {
        return n.type === 'keypress'
          ? Dn(n)
          : n.type === 'keydown' || n.type === 'keyup'
            ? n.keyCode
            : 0;
      },
    }),
    nd = ai(ic),
    Du = x({}, fi, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    ac = ai(Du),
    id = x({}, ar, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Uo,
    }),
    ad = ai(id),
    rc = x({}, ir, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    rd = ai(rc),
    Ou = x({}, fi, {
      deltaX: function (n) {
        return 'deltaX' in n ? n.deltaX : 'wheelDeltaX' in n ? -n.wheelDeltaX : 0;
      },
      deltaY: function (n) {
        return 'deltaY' in n
          ? n.deltaY
          : 'wheelDeltaY' in n
            ? -n.wheelDeltaY
            : 'wheelDelta' in n
              ? -n.wheelDelta
              : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    Uu = ai(Ou),
    No = x({}, ir, { newState: 0, oldState: 0 }),
    rr = ai(No),
    sd = [9, 13, 27, 32],
    sr = na && 'CompositionEvent' in window,
    Qn = null;
  na && 'documentMode' in document && (Qn = document.documentMode);
  var Nu = na && 'TextEvent' in window && !Qn,
    sc = na && (!sr || (Qn && 8 < Qn && 11 >= Qn)),
    zu = ' ',
    zo = !1;
  function Io(n, i) {
    switch (n) {
      case 'keyup':
        return sd.indexOf(i.keyCode) !== -1;
      case 'keydown':
        return i.keyCode !== 229;
      case 'keypress':
      case 'mousedown':
      case 'focusout':
        return !0;
      default:
        return !1;
    }
  }
  function Iu(n) {
    return (n = n.detail), typeof n == 'object' && 'data' in n ? n.data : null;
  }
  var Xr = !1;
  function Bu(n, i) {
    switch (n) {
      case 'compositionend':
        return Iu(i);
      case 'keypress':
        return i.which !== 32 ? null : ((zo = !0), zu);
      case 'textInput':
        return (n = i.data), n === zu && zo ? null : n;
      default:
        return null;
    }
  }
  function od(n, i) {
    if (Xr)
      return n === 'compositionend' || (!sr && Io(n, i))
        ? ((n = Wr()), (Vr = xa = ia = null), (Xr = !1), n)
        : null;
    switch (n) {
      case 'paste':
        return null;
      case 'keypress':
        if (!(i.ctrlKey || i.altKey || i.metaKey) || (i.ctrlKey && i.altKey)) {
          if (i.char && 1 < i.char.length) return i.char;
          if (i.which) return String.fromCharCode(i.which);
        }
        return null;
      case 'compositionend':
        return sc && i.locale !== 'ko' ? null : i.data;
      default:
        return null;
    }
  }
  var Fi = {
    color: !0,
    date: !0,
    datetime: !0,
    'datetime-local': !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function or(n) {
    var i = n && n.nodeName && n.nodeName.toLowerCase();
    return i === 'input' ? !!Fi[n.type] : i === 'textarea';
  }
  function ku(n, i, o, u) {
    er ? (Ua ? Ua.push(u) : (Ua = [u])) : (er = u),
      (i = Ah(i, 'onChange')),
      0 < i.length &&
        ((o = new Hs('onChange', 'change', null, o, u)), n.push({ event: o, listeners: i }));
  }
  var xi = null,
    Vs = null;
  function jr(n) {
    x0(n, 0);
  }
  function Bo(n) {
    var i = Ci(n);
    if (ne(i)) return n;
  }
  function qr(n, i) {
    if (n === 'change') return i;
  }
  var oc = !1;
  if (na) {
    var Yr;
    if (na) {
      var lc = 'oninput' in document;
      if (!lc) {
        var Sa = document.createElement('div');
        Sa.setAttribute('oninput', 'return;'), (lc = typeof Sa.oninput == 'function');
      }
      Yr = lc;
    } else Yr = !1;
    oc = Yr && (!document.documentMode || 9 < document.documentMode);
  }
  function Ws() {
    xi && (xi.detachEvent('onpropertychange', Fu), (Vs = xi = null));
  }
  function Fu(n) {
    if (n.propertyName === 'value' && Bo(Vs)) {
      var i = [];
      ku(i, Vs, n, Gr(n)), Bi(jr, i);
    }
  }
  function cc(n, i, o) {
    n === 'focusin'
      ? (Ws(), (xi = i), (Vs = o), xi.attachEvent('onpropertychange', Fu))
      : n === 'focusout' && Ws();
  }
  function ld(n) {
    if (n === 'selectionchange' || n === 'keyup' || n === 'keydown') return Bo(Vs);
  }
  function Ma(n, i) {
    if (n === 'click') return Bo(i);
  }
  function cd(n, i) {
    if (n === 'input' || n === 'change') return Bo(i);
  }
  function Kr(n, i) {
    return (n === i && (n !== 0 || 1 / n === 1 / i)) || (n !== n && i !== i);
  }
  var Si = typeof Object.is == 'function' ? Object.is : Kr;
  function Mi(n, i) {
    if (Si(n, i)) return !0;
    if (typeof n != 'object' || n === null || typeof i != 'object' || i === null) return !1;
    var o = Object.keys(n),
      u = Object.keys(i);
    if (o.length !== u.length) return !1;
    for (u = 0; u < o.length; u++) {
      var p = o[u];
      if (!Te.call(i, p) || !Si(n[p], i[p])) return !1;
    }
    return !0;
  }
  function Zs(n) {
    for (; n && n.firstChild; ) n = n.firstChild;
    return n;
  }
  function uc(n, i) {
    var o = Zs(n);
    n = 0;
    for (var u; o; ) {
      if (o.nodeType === 3) {
        if (((u = n + o.textContent.length), n <= i && u >= i)) return { node: o, offset: i - n };
        n = u;
      }
      t: {
        for (; o; ) {
          if (o.nextSibling) {
            o = o.nextSibling;
            break t;
          }
          o = o.parentNode;
        }
        o = void 0;
      }
      o = Zs(o);
    }
  }
  function ko(n, i) {
    return n && i
      ? n === i
        ? !0
        : n && n.nodeType === 3
          ? !1
          : i && i.nodeType === 3
            ? ko(n, i.parentNode)
            : 'contains' in n
              ? n.contains(i)
              : n.compareDocumentPosition
                ? !!(n.compareDocumentPosition(i) & 16)
                : !1
      : !1;
  }
  function Xs(n) {
    n =
      n != null && n.ownerDocument != null && n.ownerDocument.defaultView != null
        ? n.ownerDocument.defaultView
        : window;
    for (var i = We(n.document); i instanceof n.HTMLIFrameElement; ) {
      try {
        var o = typeof i.contentWindow.location.href == 'string';
      } catch {
        o = !1;
      }
      if (o) n = i.contentWindow;
      else break;
      i = We(n.document);
    }
    return i;
  }
  function js(n) {
    var i = n && n.nodeName && n.nodeName.toLowerCase();
    return (
      i &&
      ((i === 'input' &&
        (n.type === 'text' ||
          n.type === 'search' ||
          n.type === 'tel' ||
          n.type === 'url' ||
          n.type === 'password')) ||
        i === 'textarea' ||
        n.contentEditable === 'true')
    );
  }
  var Fo = na && 'documentMode' in document && 11 >= document.documentMode,
    Hi = null,
    Qr = null,
    lr = null,
    Ho = !1;
  function Hu(n, i, o) {
    var u = o.window === o ? o.document : o.nodeType === 9 ? o : o.ownerDocument;
    Ho ||
      Hi == null ||
      Hi !== We(u) ||
      ((u = Hi),
      'selectionStart' in u && js(u)
        ? (u = { start: u.selectionStart, end: u.selectionEnd })
        : ((u = ((u.ownerDocument && u.ownerDocument.defaultView) || window).getSelection()),
          (u = {
            anchorNode: u.anchorNode,
            anchorOffset: u.anchorOffset,
            focusNode: u.focusNode,
            focusOffset: u.focusOffset,
          })),
      (lr && Mi(lr, u)) ||
        ((lr = u),
        (u = Ah(Qr, 'onSelect')),
        0 < u.length &&
          ((i = new Hs('onSelect', 'select', null, i, o)),
          n.push({ event: i, listeners: u }),
          (i.target = Hi))));
  }
  function ra(n, i) {
    var o = {};
    return (
      (o[n.toLowerCase()] = i.toLowerCase()),
      (o['Webkit' + n] = 'webkit' + i),
      (o['Moz' + n] = 'moz' + i),
      o
    );
  }
  var Jr = {
      animationend: ra('Animation', 'AnimationEnd'),
      animationiteration: ra('Animation', 'AnimationIteration'),
      animationstart: ra('Animation', 'AnimationStart'),
      transitionrun: ra('Transition', 'TransitionRun'),
      transitionstart: ra('Transition', 'TransitionStart'),
      transitioncancel: ra('Transition', 'TransitionCancel'),
      transitionend: ra('Transition', 'TransitionEnd'),
    },
    Go = {},
    Gu = {};
  na &&
    ((Gu = document.createElement('div').style),
    'AnimationEvent' in window ||
      (delete Jr.animationend.animation,
      delete Jr.animationiteration.animation,
      delete Jr.animationstart.animation),
    'TransitionEvent' in window || delete Jr.transitionend.transition);
  function za(n) {
    if (Go[n]) return Go[n];
    if (!Jr[n]) return n;
    var i = Jr[n],
      o;
    for (o in i) if (i.hasOwnProperty(o) && o in Gu) return (Go[n] = i[o]);
    return n;
  }
  var Vu = za('animationend'),
    Gi = za('animationiteration'),
    qs = za('animationstart'),
    ud = za('transitionrun'),
    Vo = za('transitionstart'),
    hd = za('transitioncancel'),
    hc = za('transitionend'),
    Wu = new Map(),
    cr =
      'abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
        ' ',
      );
  cr.push('scrollEnd');
  function Vi(n, i) {
    Wu.set(n, i), ya(i, [n]);
  }
  var ur = new WeakMap();
  function bi(n, i) {
    if (typeof n == 'object' && n !== null) {
      var o = ur.get(n);
      return o !== void 0 ? o : ((i = { value: n, source: i, stack: Re(i) }), ur.set(n, i), i);
    }
    return { value: n, source: i, stack: Re(i) };
  }
  var Ei = [],
    $r = 0,
    Wi = 0;
  function Ys() {
    for (var n = $r, i = (Wi = $r = 0); i < n; ) {
      var o = Ei[i];
      Ei[i++] = null;
      var u = Ei[i];
      Ei[i++] = null;
      var p = Ei[i];
      Ei[i++] = null;
      var v = Ei[i];
      if (((Ei[i++] = null), u !== null && p !== null)) {
        var C = u.pending;
        C === null ? (p.next = p) : ((p.next = C.next), (C.next = p)), (u.pending = p);
      }
      v !== 0 && Qs(o, p, v);
    }
  }
  function Ks(n, i, o, u) {
    (Ei[$r++] = n),
      (Ei[$r++] = i),
      (Ei[$r++] = o),
      (Ei[$r++] = u),
      (Wi |= u),
      (n.lanes |= u),
      (n = n.alternate),
      n !== null && (n.lanes |= u);
  }
  function hr(n, i, o, u) {
    return Ks(n, i, o, u), Ia(n);
  }
  function ts(n, i) {
    return Ks(n, null, null, i), Ia(n);
  }
  function Qs(n, i, o) {
    n.lanes |= o;
    var u = n.alternate;
    u !== null && (u.lanes |= o);
    for (var p = !1, v = n.return; v !== null; )
      (v.childLanes |= o),
        (u = v.alternate),
        u !== null && (u.childLanes |= o),
        v.tag === 22 && ((n = v.stateNode), n === null || n._visibility & 1 || (p = !0)),
        (n = v),
        (v = v.return);
    return n.tag === 3
      ? ((v = n.stateNode),
        p &&
          i !== null &&
          ((p = 31 - $t(o)),
          (n = v.hiddenUpdates),
          (u = n[p]),
          u === null ? (n[p] = [i]) : u.push(i),
          (i.lane = o | 536870912)),
        v)
      : null;
  }
  function Ia(n) {
    if (50 < Uc) throw ((Uc = 0), (lp = null), Error(s(185)));
    for (var i = n.return; i !== null; ) (n = i), (i = n.return);
    return n.tag === 3 ? n.stateNode : null;
  }
  var fr = {};
  function Zu(n, i, o, u) {
    (this.tag = n),
      (this.key = o),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.refCleanup = this.ref = null),
      (this.pendingProps = i),
      (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
      (this.mode = u),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Ti(n, i, o, u) {
    return new Zu(n, i, o, u);
  }
  function Wo(n) {
    return (n = n.prototype), !(!n || !n.isReactComponent);
  }
  function sa(n, i) {
    var o = n.alternate;
    return (
      o === null
        ? ((o = Ti(n.tag, i, n.key, n.mode)),
          (o.elementType = n.elementType),
          (o.type = n.type),
          (o.stateNode = n.stateNode),
          (o.alternate = n),
          (n.alternate = o))
        : ((o.pendingProps = i),
          (o.type = n.type),
          (o.flags = 0),
          (o.subtreeFlags = 0),
          (o.deletions = null)),
      (o.flags = n.flags & 65011712),
      (o.childLanes = n.childLanes),
      (o.lanes = n.lanes),
      (o.child = n.child),
      (o.memoizedProps = n.memoizedProps),
      (o.memoizedState = n.memoizedState),
      (o.updateQueue = n.updateQueue),
      (i = n.dependencies),
      (o.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }),
      (o.sibling = n.sibling),
      (o.index = n.index),
      (o.ref = n.ref),
      (o.refCleanup = n.refCleanup),
      o
    );
  }
  function fc(n, i) {
    n.flags &= 65011714;
    var o = n.alternate;
    return (
      o === null
        ? ((n.childLanes = 0),
          (n.lanes = i),
          (n.child = null),
          (n.subtreeFlags = 0),
          (n.memoizedProps = null),
          (n.memoizedState = null),
          (n.updateQueue = null),
          (n.dependencies = null),
          (n.stateNode = null))
        : ((n.childLanes = o.childLanes),
          (n.lanes = o.lanes),
          (n.child = o.child),
          (n.subtreeFlags = 0),
          (n.deletions = null),
          (n.memoizedProps = o.memoizedProps),
          (n.memoizedState = o.memoizedState),
          (n.updateQueue = o.updateQueue),
          (n.type = o.type),
          (i = o.dependencies),
          (n.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext })),
      n
    );
  }
  function Js(n, i, o, u, p, v) {
    var C = 0;
    if (((u = n), typeof n == 'function')) Wo(n) && (C = 1);
    else if (typeof n == 'string')
      C = wb(n, o, tt.current) ? 26 : n === 'html' || n === 'head' || n === 'body' ? 27 : 5;
    else
      t: switch (n) {
        case F:
          return (n = Ti(31, o, i, p)), (n.elementType = F), (n.lanes = v), n;
        case A:
          return Ba(o.children, p, v, i);
        case R:
          (C = 8), (p |= 24);
          break;
        case T:
          return (n = Ti(12, o, i, p | 2)), (n.elementType = T), (n.lanes = v), n;
        case W:
          return (n = Ti(13, o, i, p)), (n.elementType = W), (n.lanes = v), n;
        case Z:
          return (n = Ti(19, o, i, p)), (n.elementType = Z), (n.lanes = v), n;
        default:
          if (typeof n == 'object' && n !== null)
            switch (n.$$typeof) {
              case M:
              case P:
                C = 10;
                break t;
              case z:
                C = 9;
                break t;
              case D:
                C = 11;
                break t;
              case V:
                C = 14;
                break t;
              case J:
                (C = 16), (u = null);
                break t;
            }
          (C = 29), (o = Error(s(130, n === null ? 'null' : typeof n, ''))), (u = null);
      }
    return (i = Ti(C, o, i, p)), (i.elementType = n), (i.type = u), (i.lanes = v), i;
  }
  function Ba(n, i, o, u) {
    return (n = Ti(7, n, u, i)), (n.lanes = o), n;
  }
  function dc(n, i, o) {
    return (n = Ti(6, n, null, i)), (n.lanes = o), n;
  }
  function Zo(n, i, o) {
    return (
      (i = Ti(4, n.children !== null ? n.children : [], n.key, i)),
      (i.lanes = o),
      (i.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation,
      }),
      i
    );
  }
  var dr = [],
    es = 0,
    r = null,
    c = 0,
    d = [],
    y = 0,
    w = null,
    U = 1,
    q = '';
  function ht(n, i) {
    (dr[es++] = c), (dr[es++] = r), (r = n), (c = i);
  }
  function St(n, i, o) {
    (d[y++] = U), (d[y++] = q), (d[y++] = w), (w = n);
    var u = U;
    n = q;
    var p = 32 - $t(u) - 1;
    (u &= ~(1 << p)), (o += 1);
    var v = 32 - $t(i) + p;
    if (30 < v) {
      var C = p - (p % 5);
      (v = (u & ((1 << C) - 1)).toString(32)),
        (u >>= C),
        (p -= C),
        (U = (1 << (32 - $t(i) + p)) | (o << p) | u),
        (q = v + n);
    } else (U = (1 << v) | (o << p) | u), (q = n);
  }
  function Ft(n) {
    n.return !== null && (ht(n, 1), St(n, 1, 0));
  }
  function ie(n) {
    for (; n === r; ) (r = dr[--es]), (dr[es] = null), (c = dr[--es]), (dr[es] = null);
    for (; n === w; )
      (w = d[--y]), (d[y] = null), (q = d[--y]), (d[y] = null), (U = d[--y]), (d[y] = null);
  }
  var he = null,
    _e = null,
    Le = !1,
    vn = null,
    Tn = !1,
    Jn = Error(s(519));
  function Ri(n) {
    var i = Error(s(418, ''));
    throw (is(bi(i, n)), Jn);
  }
  function Xu(n) {
    var i = n.stateNode,
      o = n.type,
      u = n.memoizedProps;
    switch (((i[Nn] = n), (i[Wn] = u), o)) {
      case 'dialog':
        qe('cancel', i), qe('close', i);
        break;
      case 'iframe':
      case 'object':
      case 'embed':
        qe('load', i);
        break;
      case 'video':
      case 'audio':
        for (o = 0; o < zc.length; o++) qe(zc[o], i);
        break;
      case 'source':
        qe('error', i);
        break;
      case 'img':
      case 'image':
      case 'link':
        qe('error', i), qe('load', i);
        break;
      case 'details':
        qe('toggle', i);
        break;
      case 'input':
        qe('invalid', i),
          sn(i, u.value, u.defaultValue, u.checked, u.defaultChecked, u.type, u.name, !0),
          gn(i);
        break;
      case 'select':
        qe('invalid', i);
        break;
      case 'textarea':
        qe('invalid', i), xn(i, u.value, u.defaultValue, u.children), gn(i);
    }
    (o = u.children),
      (typeof o != 'string' && typeof o != 'number' && typeof o != 'bigint') ||
      i.textContent === '' + o ||
      u.suppressHydrationWarning === !0 ||
      E0(i.textContent, o)
        ? (u.popover != null && (qe('beforetoggle', i), qe('toggle', i)),
          u.onScroll != null && qe('scroll', i),
          u.onScrollEnd != null && qe('scrollend', i),
          u.onClick != null && (i.onclick = Ch),
          (i = !0))
        : (i = !1),
      i || Ri(n);
  }
  function ju(n) {
    for (he = n.return; he; )
      switch (he.tag) {
        case 5:
        case 13:
          Tn = !1;
          return;
        case 27:
        case 3:
          Tn = !0;
          return;
        default:
          he = he.return;
      }
  }
  function $s(n) {
    if (n !== he) return !1;
    if (!Le) return ju(n), (Le = !0), !1;
    var i = n.tag,
      o;
    if (
      ((o = i !== 3 && i !== 27) &&
        ((o = i === 5) &&
          ((o = n.type), (o = !(o !== 'form' && o !== 'button') || Ep(n.type, n.memoizedProps))),
        (o = !o)),
      o && _e && Ri(n),
      ju(n),
      i === 13)
    ) {
      if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n)) throw Error(s(317));
      t: {
        for (n = n.nextSibling, i = 0; n; ) {
          if (n.nodeType === 8)
            if (((o = n.data), o === '/$')) {
              if (i === 0) {
                _e = wa(n.nextSibling);
                break t;
              }
              i--;
            } else (o !== '$' && o !== '$!' && o !== '$?') || i++;
          n = n.nextSibling;
        }
        _e = null;
      }
    } else
      i === 27
        ? ((i = _e), vs(n.type) ? ((n = Cp), (Cp = null), (_e = n)) : (_e = i))
        : (_e = he ? wa(n.stateNode.nextSibling) : null);
    return !0;
  }
  function ns() {
    (_e = he = null), (Le = !1);
  }
  function qu() {
    var n = vn;
    return n !== null && (Di === null ? (Di = n) : Di.push.apply(Di, n), (vn = null)), n;
  }
  function is(n) {
    vn === null ? (vn = [n]) : vn.push(n);
  }
  var Sn = Q(null),
    oa = null,
    ba = null;
  function ka(n, i, o) {
    At(Sn, i._currentValue), (i._currentValue = o);
  }
  function Ea(n) {
    (n._currentValue = Sn.current), gt(Sn);
  }
  function to(n, i, o) {
    for (; n !== null; ) {
      var u = n.alternate;
      if (
        ((n.childLanes & i) !== i
          ? ((n.childLanes |= i), u !== null && (u.childLanes |= i))
          : u !== null && (u.childLanes & i) !== i && (u.childLanes |= i),
        n === o)
      )
        break;
      n = n.return;
    }
  }
  function Xo(n, i, o, u) {
    var p = n.child;
    for (p !== null && (p.return = n); p !== null; ) {
      var v = p.dependencies;
      if (v !== null) {
        var C = p.child;
        v = v.firstContext;
        t: for (; v !== null; ) {
          var B = v;
          v = p;
          for (var Y = 0; Y < i.length; Y++)
            if (B.context === i[Y]) {
              (v.lanes |= o),
                (B = v.alternate),
                B !== null && (B.lanes |= o),
                to(v.return, o, n),
                u || (C = null);
              break t;
            }
          v = B.next;
        }
      } else if (p.tag === 18) {
        if (((C = p.return), C === null)) throw Error(s(341));
        (C.lanes |= o), (v = C.alternate), v !== null && (v.lanes |= o), to(C, o, n), (C = null);
      } else C = p.child;
      if (C !== null) C.return = p;
      else
        for (C = p; C !== null; ) {
          if (C === n) {
            C = null;
            break;
          }
          if (((p = C.sibling), p !== null)) {
            (p.return = C.return), (C = p);
            break;
          }
          C = C.return;
        }
      p = C;
    }
  }
  function eo(n, i, o, u) {
    n = null;
    for (var p = i, v = !1; p !== null; ) {
      if (!v) {
        if ((p.flags & 524288) !== 0) v = !0;
        else if ((p.flags & 262144) !== 0) break;
      }
      if (p.tag === 10) {
        var C = p.alternate;
        if (C === null) throw Error(s(387));
        if (((C = C.memoizedProps), C !== null)) {
          var B = p.type;
          Si(p.pendingProps.value, C.value) || (n !== null ? n.push(B) : (n = [B]));
        }
      } else if (p === It.current) {
        if (((C = p.alternate), C === null)) throw Error(s(387));
        C.memoizedState.memoizedState !== p.memoizedState.memoizedState &&
          (n !== null ? n.push(Gc) : (n = [Gc]));
      }
      p = p.return;
    }
    n !== null && Xo(i, n, o, u), (i.flags |= 262144);
  }
  function Yu(n) {
    for (n = n.firstContext; n !== null; ) {
      if (!Si(n.context._currentValue, n.memoizedValue)) return !0;
      n = n.next;
    }
    return !1;
  }
  function no(n) {
    (oa = n), (ba = null), (n = n.dependencies), n !== null && (n.firstContext = null);
  }
  function di(n) {
    return ug(oa, n);
  }
  function Ku(n, i) {
    return oa === null && no(n), ug(n, i);
  }
  function ug(n, i) {
    var o = i._currentValue;
    if (((i = { context: i, memoizedValue: o, next: null }), ba === null)) {
      if (n === null) throw Error(s(308));
      (ba = i), (n.dependencies = { lanes: 0, firstContext: i }), (n.flags |= 524288);
    } else ba = ba.next = i;
    return o;
  }
  var TM =
      typeof AbortController < 'u'
        ? AbortController
        : function () {
            var n = [],
              i = (this.signal = {
                aborted: !1,
                addEventListener: function (o, u) {
                  n.push(u);
                },
              });
            this.abort = function () {
              (i.aborted = !0),
                n.forEach(function (o) {
                  return o();
                });
            };
          },
    wM = a.unstable_scheduleCallback,
    AM = a.unstable_NormalPriority,
    Zn = {
      $$typeof: P,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
    };
  function fd() {
    return { controller: new TM(), data: new Map(), refCount: 0 };
  }
  function pc(n) {
    n.refCount--,
      n.refCount === 0 &&
        wM(AM, function () {
          n.controller.abort();
        });
  }
  var mc = null,
    dd = 0,
    jo = 0,
    qo = null;
  function CM(n, i) {
    if (mc === null) {
      var o = (mc = []);
      (dd = 0),
        (jo = mp()),
        (qo = {
          status: 'pending',
          value: void 0,
          then: function (u) {
            o.push(u);
          },
        });
    }
    return dd++, i.then(hg, hg), i;
  }
  function hg() {
    if (--dd === 0 && mc !== null) {
      qo !== null && (qo.status = 'fulfilled');
      var n = mc;
      (mc = null), (jo = 0), (qo = null);
      for (var i = 0; i < n.length; i++) (0, n[i])();
    }
  }
  function RM(n, i) {
    var o = [],
      u = {
        status: 'pending',
        value: null,
        reason: null,
        then: function (p) {
          o.push(p);
        },
      };
    return (
      n.then(
        function () {
          (u.status = 'fulfilled'), (u.value = i);
          for (var p = 0; p < o.length; p++) (0, o[p])(i);
        },
        function (p) {
          for (u.status = 'rejected', u.reason = p, p = 0; p < o.length; p++) (0, o[p])(void 0);
        },
      ),
      u
    );
  }
  var fg = X.S;
  X.S = function (n, i) {
    typeof i == 'object' && i !== null && typeof i.then == 'function' && CM(n, i),
      fg !== null && fg(n, i);
  };
  var io = Q(null);
  function pd() {
    var n = io.current;
    return n !== null ? n : yn.pooledCache;
  }
  function Qu(n, i) {
    i === null ? At(io, io.current) : At(io, i.pool);
  }
  function dg() {
    var n = pd();
    return n === null ? null : { parent: Zn._currentValue, pool: n };
  }
  var _c = Error(s(460)),
    pg = Error(s(474)),
    Ju = Error(s(542)),
    md = { then: function () {} };
  function mg(n) {
    return (n = n.status), n === 'fulfilled' || n === 'rejected';
  }
  function $u() {}
  function _g(n, i, o) {
    switch (
      ((o = n[o]), o === void 0 ? n.push(i) : o !== i && (i.then($u, $u), (i = o)), i.status)
    ) {
      case 'fulfilled':
        return i.value;
      case 'rejected':
        throw ((n = i.reason), vg(n), n);
      default:
        if (typeof i.status == 'string') i.then($u, $u);
        else {
          if (((n = yn), n !== null && 100 < n.shellSuspendCounter)) throw Error(s(482));
          (n = i),
            (n.status = 'pending'),
            n.then(
              function (u) {
                if (i.status === 'pending') {
                  var p = i;
                  (p.status = 'fulfilled'), (p.value = u);
                }
              },
              function (u) {
                if (i.status === 'pending') {
                  var p = i;
                  (p.status = 'rejected'), (p.reason = u);
                }
              },
            );
        }
        switch (i.status) {
          case 'fulfilled':
            return i.value;
          case 'rejected':
            throw ((n = i.reason), vg(n), n);
        }
        throw ((gc = i), _c);
    }
  }
  var gc = null;
  function gg() {
    if (gc === null) throw Error(s(459));
    var n = gc;
    return (gc = null), n;
  }
  function vg(n) {
    if (n === _c || n === Ju) throw Error(s(483));
  }
  var as = !1;
  function _d(n) {
    n.updateQueue = {
      baseState: n.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null,
    };
  }
  function gd(n, i) {
    (n = n.updateQueue),
      i.updateQueue === n &&
        (i.updateQueue = {
          baseState: n.baseState,
          firstBaseUpdate: n.firstBaseUpdate,
          lastBaseUpdate: n.lastBaseUpdate,
          shared: n.shared,
          callbacks: null,
        });
  }
  function rs(n) {
    return { lane: n, tag: 0, payload: null, callback: null, next: null };
  }
  function ss(n, i, o) {
    var u = n.updateQueue;
    if (u === null) return null;
    if (((u = u.shared), (on & 2) !== 0)) {
      var p = u.pending;
      return (
        p === null ? (i.next = i) : ((i.next = p.next), (p.next = i)),
        (u.pending = i),
        (i = Ia(n)),
        Qs(n, null, o),
        i
      );
    }
    return Ks(n, u, i, o), Ia(n);
  }
  function vc(n, i, o) {
    if (((i = i.updateQueue), i !== null && ((i = i.shared), (o & 4194048) !== 0))) {
      var u = i.lanes;
      (u &= n.pendingLanes), (o |= u), (i.lanes = o), Pe(n, o);
    }
  }
  function vd(n, i) {
    var o = n.updateQueue,
      u = n.alternate;
    if (u !== null && ((u = u.updateQueue), o === u)) {
      var p = null,
        v = null;
      if (((o = o.firstBaseUpdate), o !== null)) {
        do {
          var C = { lane: o.lane, tag: o.tag, payload: o.payload, callback: null, next: null };
          v === null ? (p = v = C) : (v = v.next = C), (o = o.next);
        } while (o !== null);
        v === null ? (p = v = i) : (v = v.next = i);
      } else p = v = i;
      (o = {
        baseState: u.baseState,
        firstBaseUpdate: p,
        lastBaseUpdate: v,
        shared: u.shared,
        callbacks: u.callbacks,
      }),
        (n.updateQueue = o);
      return;
    }
    (n = o.lastBaseUpdate),
      n === null ? (o.firstBaseUpdate = i) : (n.next = i),
      (o.lastBaseUpdate = i);
  }
  var yd = !1;
  function yc() {
    if (yd) {
      var n = qo;
      if (n !== null) throw n;
    }
  }
  function xc(n, i, o, u) {
    yd = !1;
    var p = n.updateQueue;
    as = !1;
    var v = p.firstBaseUpdate,
      C = p.lastBaseUpdate,
      B = p.shared.pending;
    if (B !== null) {
      p.shared.pending = null;
      var Y = B,
        mt = Y.next;
      (Y.next = null), C === null ? (v = mt) : (C.next = mt), (C = Y);
      var Rt = n.alternate;
      Rt !== null &&
        ((Rt = Rt.updateQueue),
        (B = Rt.lastBaseUpdate),
        B !== C &&
          (B === null ? (Rt.firstBaseUpdate = mt) : (B.next = mt), (Rt.lastBaseUpdate = Y)));
    }
    if (v !== null) {
      var Nt = p.baseState;
      (C = 0), (Rt = mt = Y = null), (B = v);
      do {
        var vt = B.lane & -536870913,
          xt = vt !== B.lane;
        if (xt ? (Ke & vt) === vt : (u & vt) === vt) {
          vt !== 0 && vt === jo && (yd = !0),
            Rt !== null &&
              (Rt = Rt.next =
                { lane: 0, tag: B.tag, payload: B.payload, callback: null, next: null });
          t: {
            var Ce = n,
              we = B;
            vt = i;
            var fn = o;
            switch (we.tag) {
              case 1:
                if (((Ce = we.payload), typeof Ce == 'function')) {
                  Nt = Ce.call(fn, Nt, vt);
                  break t;
                }
                Nt = Ce;
                break t;
              case 3:
                Ce.flags = (Ce.flags & -65537) | 128;
              case 0:
                if (
                  ((Ce = we.payload),
                  (vt = typeof Ce == 'function' ? Ce.call(fn, Nt, vt) : Ce),
                  vt == null)
                )
                  break t;
                Nt = x({}, Nt, vt);
                break t;
              case 2:
                as = !0;
            }
          }
          (vt = B.callback),
            vt !== null &&
              ((n.flags |= 64),
              xt && (n.flags |= 8192),
              (xt = p.callbacks),
              xt === null ? (p.callbacks = [vt]) : xt.push(vt));
        } else
          (xt = { lane: vt, tag: B.tag, payload: B.payload, callback: B.callback, next: null }),
            Rt === null ? ((mt = Rt = xt), (Y = Nt)) : (Rt = Rt.next = xt),
            (C |= vt);
        if (((B = B.next), B === null)) {
          if (((B = p.shared.pending), B === null)) break;
          (xt = B),
            (B = xt.next),
            (xt.next = null),
            (p.lastBaseUpdate = xt),
            (p.shared.pending = null);
        }
      } while (!0);
      Rt === null && (Y = Nt),
        (p.baseState = Y),
        (p.firstBaseUpdate = mt),
        (p.lastBaseUpdate = Rt),
        v === null && (p.shared.lanes = 0),
        (ps |= C),
        (n.lanes = C),
        (n.memoizedState = Nt);
    }
  }
  function yg(n, i) {
    if (typeof n != 'function') throw Error(s(191, n));
    n.call(i);
  }
  function xg(n, i) {
    var o = n.callbacks;
    if (o !== null) for (n.callbacks = null, n = 0; n < o.length; n++) yg(o[n], i);
  }
  var Yo = Q(null),
    th = Q(0);
  function Sg(n, i) {
    (n = xr), At(th, n), At(Yo, i), (xr = n | i.baseLanes);
  }
  function xd() {
    At(th, xr), At(Yo, Yo.current);
  }
  function Sd() {
    (xr = th.current), gt(Yo), gt(th);
  }
  var os = 0,
    Ge = null,
    un = null,
    Fn = null,
    eh = !1,
    Ko = !1,
    ao = !1,
    nh = 0,
    Sc = 0,
    Qo = null,
    LM = 0;
  function In() {
    throw Error(s(321));
  }
  function Md(n, i) {
    if (i === null) return !1;
    for (var o = 0; o < i.length && o < n.length; o++) if (!Si(n[o], i[o])) return !1;
    return !0;
  }
  function bd(n, i, o, u, p, v) {
    return (
      (os = v),
      (Ge = i),
      (i.memoizedState = null),
      (i.updateQueue = null),
      (i.lanes = 0),
      (X.H = n === null || n.memoizedState === null ? av : rv),
      (ao = !1),
      (v = o(u, p)),
      (ao = !1),
      Ko && (v = bg(i, o, u, p)),
      Mg(n),
      v
    );
  }
  function Mg(n) {
    X.H = lh;
    var i = un !== null && un.next !== null;
    if (((os = 0), (Fn = un = Ge = null), (eh = !1), (Sc = 0), (Qo = null), i)) throw Error(s(300));
    n === null || $n || ((n = n.dependencies), n !== null && Yu(n) && ($n = !0));
  }
  function bg(n, i, o, u) {
    Ge = n;
    var p = 0;
    do {
      if ((Ko && (Qo = null), (Sc = 0), (Ko = !1), 25 <= p)) throw Error(s(301));
      if (((p += 1), (Fn = un = null), n.updateQueue != null)) {
        var v = n.updateQueue;
        (v.lastEffect = null),
          (v.events = null),
          (v.stores = null),
          v.memoCache != null && (v.memoCache.index = 0);
      }
      (X.H = IM), (v = i(o, u));
    } while (Ko);
    return v;
  }
  function PM() {
    var n = X.H,
      i = n.useState()[0];
    return (
      (i = typeof i.then == 'function' ? Mc(i) : i),
      (n = n.useState()[0]),
      (un !== null ? un.memoizedState : null) !== n && (Ge.flags |= 1024),
      i
    );
  }
  function Ed() {
    var n = nh !== 0;
    return (nh = 0), n;
  }
  function Td(n, i, o) {
    (i.updateQueue = n.updateQueue), (i.flags &= -2053), (n.lanes &= ~o);
  }
  function wd(n) {
    if (eh) {
      for (n = n.memoizedState; n !== null; ) {
        var i = n.queue;
        i !== null && (i.pending = null), (n = n.next);
      }
      eh = !1;
    }
    (os = 0), (Fn = un = Ge = null), (Ko = !1), (Sc = nh = 0), (Qo = null);
  }
  function Li() {
    var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Fn === null ? (Ge.memoizedState = Fn = n) : (Fn = Fn.next = n), Fn;
  }
  function Hn() {
    if (un === null) {
      var n = Ge.alternate;
      n = n !== null ? n.memoizedState : null;
    } else n = un.next;
    var i = Fn === null ? Ge.memoizedState : Fn.next;
    if (i !== null) (Fn = i), (un = n);
    else {
      if (n === null) throw Ge.alternate === null ? Error(s(467)) : Error(s(310));
      (un = n),
        (n = {
          memoizedState: un.memoizedState,
          baseState: un.baseState,
          baseQueue: un.baseQueue,
          queue: un.queue,
          next: null,
        }),
        Fn === null ? (Ge.memoizedState = Fn = n) : (Fn = Fn.next = n);
    }
    return Fn;
  }
  function Ad() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Mc(n) {
    var i = Sc;
    return (
      (Sc += 1),
      Qo === null && (Qo = []),
      (n = _g(Qo, n, i)),
      (i = Ge),
      (Fn === null ? i.memoizedState : Fn.next) === null &&
        ((i = i.alternate), (X.H = i === null || i.memoizedState === null ? av : rv)),
      n
    );
  }
  function ih(n) {
    if (n !== null && typeof n == 'object') {
      if (typeof n.then == 'function') return Mc(n);
      if (n.$$typeof === P) return di(n);
    }
    throw Error(s(438, String(n)));
  }
  function Cd(n) {
    var i = null,
      o = Ge.updateQueue;
    if ((o !== null && (i = o.memoCache), i == null)) {
      var u = Ge.alternate;
      u !== null &&
        ((u = u.updateQueue),
        u !== null &&
          ((u = u.memoCache),
          u != null &&
            (i = {
              data: u.data.map(function (p) {
                return p.slice();
              }),
              index: 0,
            })));
    }
    if (
      (i == null && (i = { data: [], index: 0 }),
      o === null && ((o = Ad()), (Ge.updateQueue = o)),
      (o.memoCache = i),
      (o = i.data[i.index]),
      o === void 0)
    )
      for (o = i.data[i.index] = Array(n), u = 0; u < n; u++) o[u] = I;
    return i.index++, o;
  }
  function pr(n, i) {
    return typeof i == 'function' ? i(n) : i;
  }
  function ah(n) {
    var i = Hn();
    return Rd(i, un, n);
  }
  function Rd(n, i, o) {
    var u = n.queue;
    if (u === null) throw Error(s(311));
    u.lastRenderedReducer = o;
    var p = n.baseQueue,
      v = u.pending;
    if (v !== null) {
      if (p !== null) {
        var C = p.next;
        (p.next = v.next), (v.next = C);
      }
      (i.baseQueue = p = v), (u.pending = null);
    }
    if (((v = n.baseState), p === null)) n.memoizedState = v;
    else {
      i = p.next;
      var B = (C = null),
        Y = null,
        mt = i,
        Rt = !1;
      do {
        var Nt = mt.lane & -536870913;
        if (Nt !== mt.lane ? (Ke & Nt) === Nt : (os & Nt) === Nt) {
          var vt = mt.revertLane;
          if (vt === 0)
            Y !== null &&
              (Y = Y.next =
                {
                  lane: 0,
                  revertLane: 0,
                  action: mt.action,
                  hasEagerState: mt.hasEagerState,
                  eagerState: mt.eagerState,
                  next: null,
                }),
              Nt === jo && (Rt = !0);
          else if ((os & vt) === vt) {
            (mt = mt.next), vt === jo && (Rt = !0);
            continue;
          } else
            (Nt = {
              lane: 0,
              revertLane: mt.revertLane,
              action: mt.action,
              hasEagerState: mt.hasEagerState,
              eagerState: mt.eagerState,
              next: null,
            }),
              Y === null ? ((B = Y = Nt), (C = v)) : (Y = Y.next = Nt),
              (Ge.lanes |= vt),
              (ps |= vt);
          (Nt = mt.action), ao && o(v, Nt), (v = mt.hasEagerState ? mt.eagerState : o(v, Nt));
        } else
          (vt = {
            lane: Nt,
            revertLane: mt.revertLane,
            action: mt.action,
            hasEagerState: mt.hasEagerState,
            eagerState: mt.eagerState,
            next: null,
          }),
            Y === null ? ((B = Y = vt), (C = v)) : (Y = Y.next = vt),
            (Ge.lanes |= Nt),
            (ps |= Nt);
        mt = mt.next;
      } while (mt !== null && mt !== i);
      if (
        (Y === null ? (C = v) : (Y.next = B),
        !Si(v, n.memoizedState) && (($n = !0), Rt && ((o = qo), o !== null)))
      )
        throw o;
      (n.memoizedState = v), (n.baseState = C), (n.baseQueue = Y), (u.lastRenderedState = v);
    }
    return p === null && (u.lanes = 0), [n.memoizedState, u.dispatch];
  }
  function Ld(n) {
    var i = Hn(),
      o = i.queue;
    if (o === null) throw Error(s(311));
    o.lastRenderedReducer = n;
    var u = o.dispatch,
      p = o.pending,
      v = i.memoizedState;
    if (p !== null) {
      o.pending = null;
      var C = (p = p.next);
      do (v = n(v, C.action)), (C = C.next);
      while (C !== p);
      Si(v, i.memoizedState) || ($n = !0),
        (i.memoizedState = v),
        i.baseQueue === null && (i.baseState = v),
        (o.lastRenderedState = v);
    }
    return [v, u];
  }
  function Eg(n, i, o) {
    var u = Ge,
      p = Hn(),
      v = Le;
    if (v) {
      if (o === void 0) throw Error(s(407));
      o = o();
    } else o = i();
    var C = !Si((un || p).memoizedState, o);
    C && ((p.memoizedState = o), ($n = !0)), (p = p.queue);
    var B = Ag.bind(null, u, p, n);
    if (
      (bc(2048, 8, B, [n]), p.getSnapshot !== i || C || (Fn !== null && Fn.memoizedState.tag & 1))
    ) {
      if (((u.flags |= 2048), Jo(9, rh(), wg.bind(null, u, p, o, i), null), yn === null))
        throw Error(s(349));
      v || (os & 124) !== 0 || Tg(u, i, o);
    }
    return o;
  }
  function Tg(n, i, o) {
    (n.flags |= 16384),
      (n = { getSnapshot: i, value: o }),
      (i = Ge.updateQueue),
      i === null
        ? ((i = Ad()), (Ge.updateQueue = i), (i.stores = [n]))
        : ((o = i.stores), o === null ? (i.stores = [n]) : o.push(n));
  }
  function wg(n, i, o, u) {
    (i.value = o), (i.getSnapshot = u), Cg(i) && Rg(n);
  }
  function Ag(n, i, o) {
    return o(function () {
      Cg(i) && Rg(n);
    });
  }
  function Cg(n) {
    var i = n.getSnapshot;
    n = n.value;
    try {
      var o = i();
      return !Si(n, o);
    } catch {
      return !0;
    }
  }
  function Rg(n) {
    var i = ts(n, 2);
    i !== null && Yi(i, n, 2);
  }
  function Pd(n) {
    var i = Li();
    if (typeof n == 'function') {
      var o = n;
      if (((n = o()), ao)) {
        Wt(!0);
        try {
          o();
        } finally {
          Wt(!1);
        }
      }
    }
    return (
      (i.memoizedState = i.baseState = n),
      (i.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: pr,
        lastRenderedState: n,
      }),
      i
    );
  }
  function Lg(n, i, o, u) {
    return (n.baseState = o), Rd(n, un, typeof u == 'function' ? u : pr);
  }
  function DM(n, i, o, u, p) {
    if (oh(n)) throw Error(s(485));
    if (((n = i.action), n !== null)) {
      var v = {
        payload: p,
        action: n,
        next: null,
        isTransition: !0,
        status: 'pending',
        value: null,
        reason: null,
        listeners: [],
        then: function (C) {
          v.listeners.push(C);
        },
      };
      X.T !== null ? o(!0) : (v.isTransition = !1),
        u(v),
        (o = i.pending),
        o === null
          ? ((v.next = i.pending = v), Pg(i, v))
          : ((v.next = o.next), (i.pending = o.next = v));
    }
  }
  function Pg(n, i) {
    var o = i.action,
      u = i.payload,
      p = n.state;
    if (i.isTransition) {
      var v = X.T,
        C = {};
      X.T = C;
      try {
        var B = o(p, u),
          Y = X.S;
        Y !== null && Y(C, B), Dg(n, i, B);
      } catch (mt) {
        Dd(n, i, mt);
      } finally {
        X.T = v;
      }
    } else
      try {
        (v = o(p, u)), Dg(n, i, v);
      } catch (mt) {
        Dd(n, i, mt);
      }
  }
  function Dg(n, i, o) {
    o !== null && typeof o == 'object' && typeof o.then == 'function'
      ? o.then(
          function (u) {
            Og(n, i, u);
          },
          function (u) {
            return Dd(n, i, u);
          },
        )
      : Og(n, i, o);
  }
  function Og(n, i, o) {
    (i.status = 'fulfilled'),
      (i.value = o),
      Ug(i),
      (n.state = o),
      (i = n.pending),
      i !== null &&
        ((o = i.next), o === i ? (n.pending = null) : ((o = o.next), (i.next = o), Pg(n, o)));
  }
  function Dd(n, i, o) {
    var u = n.pending;
    if (((n.pending = null), u !== null)) {
      u = u.next;
      do (i.status = 'rejected'), (i.reason = o), Ug(i), (i = i.next);
      while (i !== u);
    }
    n.action = null;
  }
  function Ug(n) {
    n = n.listeners;
    for (var i = 0; i < n.length; i++) (0, n[i])();
  }
  function Ng(n, i) {
    return i;
  }
  function zg(n, i) {
    if (Le) {
      var o = yn.formState;
      if (o !== null) {
        t: {
          var u = Ge;
          if (Le) {
            if (_e) {
              e: {
                for (var p = _e, v = Tn; p.nodeType !== 8; ) {
                  if (!v) {
                    p = null;
                    break e;
                  }
                  if (((p = wa(p.nextSibling)), p === null)) {
                    p = null;
                    break e;
                  }
                }
                (v = p.data), (p = v === 'F!' || v === 'F' ? p : null);
              }
              if (p) {
                (_e = wa(p.nextSibling)), (u = p.data === 'F!');
                break t;
              }
            }
            Ri(u);
          }
          u = !1;
        }
        u && (i = o[0]);
      }
    }
    return (
      (o = Li()),
      (o.memoizedState = o.baseState = i),
      (u = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ng,
        lastRenderedState: i,
      }),
      (o.queue = u),
      (o = ev.bind(null, Ge, u)),
      (u.dispatch = o),
      (u = Pd(!1)),
      (v = Id.bind(null, Ge, !1, u.queue)),
      (u = Li()),
      (p = { state: i, dispatch: null, action: n, pending: null }),
      (u.queue = p),
      (o = DM.bind(null, Ge, p, v, o)),
      (p.dispatch = o),
      (u.memoizedState = n),
      [i, o, !1]
    );
  }
  function Ig(n) {
    var i = Hn();
    return Bg(i, un, n);
  }
  function Bg(n, i, o) {
    if (
      ((i = Rd(n, i, Ng)[0]),
      (n = ah(pr)[0]),
      typeof i == 'object' && i !== null && typeof i.then == 'function')
    )
      try {
        var u = Mc(i);
      } catch (C) {
        throw C === _c ? Ju : C;
      }
    else u = i;
    i = Hn();
    var p = i.queue,
      v = p.dispatch;
    return (
      o !== i.memoizedState && ((Ge.flags |= 2048), Jo(9, rh(), OM.bind(null, p, o), null)),
      [u, v, n]
    );
  }
  function OM(n, i) {
    n.action = i;
  }
  function kg(n) {
    var i = Hn(),
      o = un;
    if (o !== null) return Bg(i, o, n);
    Hn(), (i = i.memoizedState), (o = Hn());
    var u = o.queue.dispatch;
    return (o.memoizedState = n), [i, u, !1];
  }
  function Jo(n, i, o, u) {
    return (
      (n = { tag: n, create: o, deps: u, inst: i, next: null }),
      (i = Ge.updateQueue),
      i === null && ((i = Ad()), (Ge.updateQueue = i)),
      (o = i.lastEffect),
      o === null
        ? (i.lastEffect = n.next = n)
        : ((u = o.next), (o.next = n), (n.next = u), (i.lastEffect = n)),
      n
    );
  }
  function rh() {
    return { destroy: void 0, resource: void 0 };
  }
  function Fg() {
    return Hn().memoizedState;
  }
  function sh(n, i, o, u) {
    var p = Li();
    (u = u === void 0 ? null : u), (Ge.flags |= n), (p.memoizedState = Jo(1 | i, rh(), o, u));
  }
  function bc(n, i, o, u) {
    var p = Hn();
    u = u === void 0 ? null : u;
    var v = p.memoizedState.inst;
    un !== null && u !== null && Md(u, un.memoizedState.deps)
      ? (p.memoizedState = Jo(i, v, o, u))
      : ((Ge.flags |= n), (p.memoizedState = Jo(1 | i, v, o, u)));
  }
  function Hg(n, i) {
    sh(8390656, 8, n, i);
  }
  function Gg(n, i) {
    bc(2048, 8, n, i);
  }
  function Vg(n, i) {
    return bc(4, 2, n, i);
  }
  function Wg(n, i) {
    return bc(4, 4, n, i);
  }
  function Zg(n, i) {
    if (typeof i == 'function') {
      n = n();
      var o = i(n);
      return function () {
        typeof o == 'function' ? o() : i(null);
      };
    }
    if (i != null)
      return (
        (n = n()),
        (i.current = n),
        function () {
          i.current = null;
        }
      );
  }
  function Xg(n, i, o) {
    (o = o != null ? o.concat([n]) : null), bc(4, 4, Zg.bind(null, i, n), o);
  }
  function Od() {}
  function jg(n, i) {
    var o = Hn();
    i = i === void 0 ? null : i;
    var u = o.memoizedState;
    return i !== null && Md(i, u[1]) ? u[0] : ((o.memoizedState = [n, i]), n);
  }
  function qg(n, i) {
    var o = Hn();
    i = i === void 0 ? null : i;
    var u = o.memoizedState;
    if (i !== null && Md(i, u[1])) return u[0];
    if (((u = n()), ao)) {
      Wt(!0);
      try {
        n();
      } finally {
        Wt(!1);
      }
    }
    return (o.memoizedState = [u, i]), u;
  }
  function Ud(n, i, o) {
    return o === void 0 || (os & 1073741824) !== 0
      ? (n.memoizedState = i)
      : ((n.memoizedState = o), (n = Qv()), (Ge.lanes |= n), (ps |= n), o);
  }
  function Yg(n, i, o, u) {
    return Si(o, i)
      ? o
      : Yo.current !== null
        ? ((n = Ud(n, o, u)), Si(n, i) || ($n = !0), n)
        : (os & 42) === 0
          ? (($n = !0), (n.memoizedState = o))
          : ((n = Qv()), (Ge.lanes |= n), (ps |= n), i);
  }
  function Kg(n, i, o, u, p) {
    var v = it.p;
    it.p = v !== 0 && 8 > v ? v : 8;
    var C = X.T,
      B = {};
    (X.T = B), Id(n, !1, i, o);
    try {
      var Y = p(),
        mt = X.S;
      if (
        (mt !== null && mt(B, Y), Y !== null && typeof Y == 'object' && typeof Y.then == 'function')
      ) {
        var Rt = RM(Y, u);
        Ec(n, i, Rt, qi(n));
      } else Ec(n, i, u, qi(n));
    } catch (Nt) {
      Ec(n, i, { then: function () {}, status: 'rejected', reason: Nt }, qi());
    } finally {
      (it.p = v), (X.T = C);
    }
  }
  function UM() {}
  function Nd(n, i, o, u) {
    if (n.tag !== 5) throw Error(s(476));
    var p = Qg(n).queue;
    Kg(
      n,
      p,
      i,
      K,
      o === null
        ? UM
        : function () {
            return Jg(n), o(u);
          },
    );
  }
  function Qg(n) {
    var i = n.memoizedState;
    if (i !== null) return i;
    i = {
      memoizedState: K,
      baseState: K,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: pr,
        lastRenderedState: K,
      },
      next: null,
    };
    var o = {};
    return (
      (i.next = {
        memoizedState: o,
        baseState: o,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: pr,
          lastRenderedState: o,
        },
        next: null,
      }),
      (n.memoizedState = i),
      (n = n.alternate),
      n !== null && (n.memoizedState = i),
      i
    );
  }
  function Jg(n) {
    var i = Qg(n).next.queue;
    Ec(n, i, {}, qi());
  }
  function zd() {
    return di(Gc);
  }
  function $g() {
    return Hn().memoizedState;
  }
  function tv() {
    return Hn().memoizedState;
  }
  function NM(n) {
    for (var i = n.return; i !== null; ) {
      switch (i.tag) {
        case 24:
        case 3:
          var o = qi();
          n = rs(o);
          var u = ss(i, n, o);
          u !== null && (Yi(u, i, o), vc(u, i, o)), (i = { cache: fd() }), (n.payload = i);
          return;
      }
      i = i.return;
    }
  }
  function zM(n, i, o) {
    var u = qi();
    (o = { lane: u, revertLane: 0, action: o, hasEagerState: !1, eagerState: null, next: null }),
      oh(n) ? nv(i, o) : ((o = hr(n, i, o, u)), o !== null && (Yi(o, n, u), iv(o, i, u)));
  }
  function ev(n, i, o) {
    var u = qi();
    Ec(n, i, o, u);
  }
  function Ec(n, i, o, u) {
    var p = { lane: u, revertLane: 0, action: o, hasEagerState: !1, eagerState: null, next: null };
    if (oh(n)) nv(i, p);
    else {
      var v = n.alternate;
      if (
        n.lanes === 0 &&
        (v === null || v.lanes === 0) &&
        ((v = i.lastRenderedReducer), v !== null)
      )
        try {
          var C = i.lastRenderedState,
            B = v(C, o);
          if (((p.hasEagerState = !0), (p.eagerState = B), Si(B, C)))
            return Ks(n, i, p, 0), yn === null && Ys(), !1;
        } catch {
        } finally {
        }
      if (((o = hr(n, i, p, u)), o !== null)) return Yi(o, n, u), iv(o, i, u), !0;
    }
    return !1;
  }
  function Id(n, i, o, u) {
    if (
      ((u = {
        lane: 2,
        revertLane: mp(),
        action: u,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      oh(n))
    ) {
      if (i) throw Error(s(479));
    } else (i = hr(n, o, u, 2)), i !== null && Yi(i, n, 2);
  }
  function oh(n) {
    var i = n.alternate;
    return n === Ge || (i !== null && i === Ge);
  }
  function nv(n, i) {
    Ko = eh = !0;
    var o = n.pending;
    o === null ? (i.next = i) : ((i.next = o.next), (o.next = i)), (n.pending = i);
  }
  function iv(n, i, o) {
    if ((o & 4194048) !== 0) {
      var u = i.lanes;
      (u &= n.pendingLanes), (o |= u), (i.lanes = o), Pe(n, o);
    }
  }
  var lh = {
      readContext: di,
      use: ih,
      useCallback: In,
      useContext: In,
      useEffect: In,
      useImperativeHandle: In,
      useLayoutEffect: In,
      useInsertionEffect: In,
      useMemo: In,
      useReducer: In,
      useRef: In,
      useState: In,
      useDebugValue: In,
      useDeferredValue: In,
      useTransition: In,
      useSyncExternalStore: In,
      useId: In,
      useHostTransitionStatus: In,
      useFormState: In,
      useActionState: In,
      useOptimistic: In,
      useMemoCache: In,
      useCacheRefresh: In,
    },
    av = {
      readContext: di,
      use: ih,
      useCallback: function (n, i) {
        return (Li().memoizedState = [n, i === void 0 ? null : i]), n;
      },
      useContext: di,
      useEffect: Hg,
      useImperativeHandle: function (n, i, o) {
        (o = o != null ? o.concat([n]) : null), sh(4194308, 4, Zg.bind(null, i, n), o);
      },
      useLayoutEffect: function (n, i) {
        return sh(4194308, 4, n, i);
      },
      useInsertionEffect: function (n, i) {
        sh(4, 2, n, i);
      },
      useMemo: function (n, i) {
        var o = Li();
        i = i === void 0 ? null : i;
        var u = n();
        if (ao) {
          Wt(!0);
          try {
            n();
          } finally {
            Wt(!1);
          }
        }
        return (o.memoizedState = [u, i]), u;
      },
      useReducer: function (n, i, o) {
        var u = Li();
        if (o !== void 0) {
          var p = o(i);
          if (ao) {
            Wt(!0);
            try {
              o(i);
            } finally {
              Wt(!1);
            }
          }
        } else p = i;
        return (
          (u.memoizedState = u.baseState = p),
          (n = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: n,
            lastRenderedState: p,
          }),
          (u.queue = n),
          (n = n.dispatch = zM.bind(null, Ge, n)),
          [u.memoizedState, n]
        );
      },
      useRef: function (n) {
        var i = Li();
        return (n = { current: n }), (i.memoizedState = n);
      },
      useState: function (n) {
        n = Pd(n);
        var i = n.queue,
          o = ev.bind(null, Ge, i);
        return (i.dispatch = o), [n.memoizedState, o];
      },
      useDebugValue: Od,
      useDeferredValue: function (n, i) {
        var o = Li();
        return Ud(o, n, i);
      },
      useTransition: function () {
        var n = Pd(!1);
        return (n = Kg.bind(null, Ge, n.queue, !0, !1)), (Li().memoizedState = n), [!1, n];
      },
      useSyncExternalStore: function (n, i, o) {
        var u = Ge,
          p = Li();
        if (Le) {
          if (o === void 0) throw Error(s(407));
          o = o();
        } else {
          if (((o = i()), yn === null)) throw Error(s(349));
          (Ke & 124) !== 0 || Tg(u, i, o);
        }
        p.memoizedState = o;
        var v = { value: o, getSnapshot: i };
        return (
          (p.queue = v),
          Hg(Ag.bind(null, u, v, n), [n]),
          (u.flags |= 2048),
          Jo(9, rh(), wg.bind(null, u, v, o, i), null),
          o
        );
      },
      useId: function () {
        var n = Li(),
          i = yn.identifierPrefix;
        if (Le) {
          var o = q,
            u = U;
          (o = (u & ~(1 << (32 - $t(u) - 1))).toString(32) + o),
            (i = '«' + i + 'R' + o),
            (o = nh++),
            0 < o && (i += 'H' + o.toString(32)),
            (i += '»');
        } else (o = LM++), (i = '«' + i + 'r' + o.toString(32) + '»');
        return (n.memoizedState = i);
      },
      useHostTransitionStatus: zd,
      useFormState: zg,
      useActionState: zg,
      useOptimistic: function (n) {
        var i = Li();
        i.memoizedState = i.baseState = n;
        var o = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null,
        };
        return (i.queue = o), (i = Id.bind(null, Ge, !0, o)), (o.dispatch = i), [n, i];
      },
      useMemoCache: Cd,
      useCacheRefresh: function () {
        return (Li().memoizedState = NM.bind(null, Ge));
      },
    },
    rv = {
      readContext: di,
      use: ih,
      useCallback: jg,
      useContext: di,
      useEffect: Gg,
      useImperativeHandle: Xg,
      useInsertionEffect: Vg,
      useLayoutEffect: Wg,
      useMemo: qg,
      useReducer: ah,
      useRef: Fg,
      useState: function () {
        return ah(pr);
      },
      useDebugValue: Od,
      useDeferredValue: function (n, i) {
        var o = Hn();
        return Yg(o, un.memoizedState, n, i);
      },
      useTransition: function () {
        var n = ah(pr)[0],
          i = Hn().memoizedState;
        return [typeof n == 'boolean' ? n : Mc(n), i];
      },
      useSyncExternalStore: Eg,
      useId: $g,
      useHostTransitionStatus: zd,
      useFormState: Ig,
      useActionState: Ig,
      useOptimistic: function (n, i) {
        var o = Hn();
        return Lg(o, un, n, i);
      },
      useMemoCache: Cd,
      useCacheRefresh: tv,
    },
    IM = {
      readContext: di,
      use: ih,
      useCallback: jg,
      useContext: di,
      useEffect: Gg,
      useImperativeHandle: Xg,
      useInsertionEffect: Vg,
      useLayoutEffect: Wg,
      useMemo: qg,
      useReducer: Ld,
      useRef: Fg,
      useState: function () {
        return Ld(pr);
      },
      useDebugValue: Od,
      useDeferredValue: function (n, i) {
        var o = Hn();
        return un === null ? Ud(o, n, i) : Yg(o, un.memoizedState, n, i);
      },
      useTransition: function () {
        var n = Ld(pr)[0],
          i = Hn().memoizedState;
        return [typeof n == 'boolean' ? n : Mc(n), i];
      },
      useSyncExternalStore: Eg,
      useId: $g,
      useHostTransitionStatus: zd,
      useFormState: kg,
      useActionState: kg,
      useOptimistic: function (n, i) {
        var o = Hn();
        return un !== null ? Lg(o, un, n, i) : ((o.baseState = n), [n, o.queue.dispatch]);
      },
      useMemoCache: Cd,
      useCacheRefresh: tv,
    },
    $o = null,
    Tc = 0;
  function ch(n) {
    var i = Tc;
    return (Tc += 1), $o === null && ($o = []), _g($o, n, i);
  }
  function wc(n, i) {
    (i = i.props.ref), (n.ref = i !== void 0 ? i : null);
  }
  function uh(n, i) {
    throw i.$$typeof === S
      ? Error(s(525))
      : ((n = Object.prototype.toString.call(i)),
        Error(
          s(
            31,
            n === '[object Object]' ? 'object with keys {' + Object.keys(i).join(', ') + '}' : n,
          ),
        ));
  }
  function sv(n) {
    var i = n._init;
    return i(n._payload);
  }
  function ov(n) {
    function i(ct, $) {
      if (n) {
        var dt = ct.deletions;
        dt === null ? ((ct.deletions = [$]), (ct.flags |= 16)) : dt.push($);
      }
    }
    function o(ct, $) {
      if (!n) return null;
      for (; $ !== null; ) i(ct, $), ($ = $.sibling);
      return null;
    }
    function u(ct) {
      for (var $ = new Map(); ct !== null; )
        ct.key !== null ? $.set(ct.key, ct) : $.set(ct.index, ct), (ct = ct.sibling);
      return $;
    }
    function p(ct, $) {
      return (ct = sa(ct, $)), (ct.index = 0), (ct.sibling = null), ct;
    }
    function v(ct, $, dt) {
      return (
        (ct.index = dt),
        n
          ? ((dt = ct.alternate),
            dt !== null
              ? ((dt = dt.index), dt < $ ? ((ct.flags |= 67108866), $) : dt)
              : ((ct.flags |= 67108866), $))
          : ((ct.flags |= 1048576), $)
      );
    }
    function C(ct) {
      return n && ct.alternate === null && (ct.flags |= 67108866), ct;
    }
    function B(ct, $, dt, Pt) {
      return $ === null || $.tag !== 6
        ? (($ = dc(dt, ct.mode, Pt)), ($.return = ct), $)
        : (($ = p($, dt)), ($.return = ct), $);
    }
    function Y(ct, $, dt, Pt) {
      var de = dt.type;
      return de === A
        ? Rt(ct, $, dt.props.children, Pt, dt.key)
        : $ !== null &&
            ($.elementType === de ||
              (typeof de == 'object' && de !== null && de.$$typeof === J && sv(de) === $.type))
          ? (($ = p($, dt.props)), wc($, dt), ($.return = ct), $)
          : (($ = Js(dt.type, dt.key, dt.props, null, ct.mode, Pt)), wc($, dt), ($.return = ct), $);
    }
    function mt(ct, $, dt, Pt) {
      return $ === null ||
        $.tag !== 4 ||
        $.stateNode.containerInfo !== dt.containerInfo ||
        $.stateNode.implementation !== dt.implementation
        ? (($ = Zo(dt, ct.mode, Pt)), ($.return = ct), $)
        : (($ = p($, dt.children || [])), ($.return = ct), $);
    }
    function Rt(ct, $, dt, Pt, de) {
      return $ === null || $.tag !== 7
        ? (($ = Ba(dt, ct.mode, Pt, de)), ($.return = ct), $)
        : (($ = p($, dt)), ($.return = ct), $);
    }
    function Nt(ct, $, dt) {
      if ((typeof $ == 'string' && $ !== '') || typeof $ == 'number' || typeof $ == 'bigint')
        return ($ = dc('' + $, ct.mode, dt)), ($.return = ct), $;
      if (typeof $ == 'object' && $ !== null) {
        switch ($.$$typeof) {
          case b:
            return (
              (dt = Js($.type, $.key, $.props, null, ct.mode, dt)), wc(dt, $), (dt.return = ct), dt
            );
          case E:
            return ($ = Zo($, ct.mode, dt)), ($.return = ct), $;
          case J:
            var Pt = $._init;
            return ($ = Pt($._payload)), Nt(ct, $, dt);
        }
        if (bt($) || ft($)) return ($ = Ba($, ct.mode, dt, null)), ($.return = ct), $;
        if (typeof $.then == 'function') return Nt(ct, ch($), dt);
        if ($.$$typeof === P) return Nt(ct, Ku(ct, $), dt);
        uh(ct, $);
      }
      return null;
    }
    function vt(ct, $, dt, Pt) {
      var de = $ !== null ? $.key : null;
      if ((typeof dt == 'string' && dt !== '') || typeof dt == 'number' || typeof dt == 'bigint')
        return de !== null ? null : B(ct, $, '' + dt, Pt);
      if (typeof dt == 'object' && dt !== null) {
        switch (dt.$$typeof) {
          case b:
            return dt.key === de ? Y(ct, $, dt, Pt) : null;
          case E:
            return dt.key === de ? mt(ct, $, dt, Pt) : null;
          case J:
            return (de = dt._init), (dt = de(dt._payload)), vt(ct, $, dt, Pt);
        }
        if (bt(dt) || ft(dt)) return de !== null ? null : Rt(ct, $, dt, Pt, null);
        if (typeof dt.then == 'function') return vt(ct, $, ch(dt), Pt);
        if (dt.$$typeof === P) return vt(ct, $, Ku(ct, dt), Pt);
        uh(ct, dt);
      }
      return null;
    }
    function xt(ct, $, dt, Pt, de) {
      if ((typeof Pt == 'string' && Pt !== '') || typeof Pt == 'number' || typeof Pt == 'bigint')
        return (ct = ct.get(dt) || null), B($, ct, '' + Pt, de);
      if (typeof Pt == 'object' && Pt !== null) {
        switch (Pt.$$typeof) {
          case b:
            return (ct = ct.get(Pt.key === null ? dt : Pt.key) || null), Y($, ct, Pt, de);
          case E:
            return (ct = ct.get(Pt.key === null ? dt : Pt.key) || null), mt($, ct, Pt, de);
          case J:
            var Xe = Pt._init;
            return (Pt = Xe(Pt._payload)), xt(ct, $, dt, Pt, de);
        }
        if (bt(Pt) || ft(Pt)) return (ct = ct.get(dt) || null), Rt($, ct, Pt, de, null);
        if (typeof Pt.then == 'function') return xt(ct, $, dt, ch(Pt), de);
        if (Pt.$$typeof === P) return xt(ct, $, dt, Ku($, Pt), de);
        uh($, Pt);
      }
      return null;
    }
    function Ce(ct, $, dt, Pt) {
      for (
        var de = null, Xe = null, xe = $, Ae = ($ = 0), ei = null;
        xe !== null && Ae < dt.length;
        Ae++
      ) {
        xe.index > Ae ? ((ei = xe), (xe = null)) : (ei = xe.sibling);
        var tn = vt(ct, xe, dt[Ae], Pt);
        if (tn === null) {
          xe === null && (xe = ei);
          break;
        }
        n && xe && tn.alternate === null && i(ct, xe),
          ($ = v(tn, $, Ae)),
          Xe === null ? (de = tn) : (Xe.sibling = tn),
          (Xe = tn),
          (xe = ei);
      }
      if (Ae === dt.length) return o(ct, xe), Le && ht(ct, Ae), de;
      if (xe === null) {
        for (; Ae < dt.length; Ae++)
          (xe = Nt(ct, dt[Ae], Pt)),
            xe !== null &&
              (($ = v(xe, $, Ae)), Xe === null ? (de = xe) : (Xe.sibling = xe), (Xe = xe));
        return Le && ht(ct, Ae), de;
      }
      for (xe = u(xe); Ae < dt.length; Ae++)
        (ei = xt(xe, ct, Ae, dt[Ae], Pt)),
          ei !== null &&
            (n && ei.alternate !== null && xe.delete(ei.key === null ? Ae : ei.key),
            ($ = v(ei, $, Ae)),
            Xe === null ? (de = ei) : (Xe.sibling = ei),
            (Xe = ei));
      return (
        n &&
          xe.forEach(function (bs) {
            return i(ct, bs);
          }),
        Le && ht(ct, Ae),
        de
      );
    }
    function we(ct, $, dt, Pt) {
      if (dt == null) throw Error(s(151));
      for (
        var de = null, Xe = null, xe = $, Ae = ($ = 0), ei = null, tn = dt.next();
        xe !== null && !tn.done;
        Ae++, tn = dt.next()
      ) {
        xe.index > Ae ? ((ei = xe), (xe = null)) : (ei = xe.sibling);
        var bs = vt(ct, xe, tn.value, Pt);
        if (bs === null) {
          xe === null && (xe = ei);
          break;
        }
        n && xe && bs.alternate === null && i(ct, xe),
          ($ = v(bs, $, Ae)),
          Xe === null ? (de = bs) : (Xe.sibling = bs),
          (Xe = bs),
          (xe = ei);
      }
      if (tn.done) return o(ct, xe), Le && ht(ct, Ae), de;
      if (xe === null) {
        for (; !tn.done; Ae++, tn = dt.next())
          (tn = Nt(ct, tn.value, Pt)),
            tn !== null &&
              (($ = v(tn, $, Ae)), Xe === null ? (de = tn) : (Xe.sibling = tn), (Xe = tn));
        return Le && ht(ct, Ae), de;
      }
      for (xe = u(xe); !tn.done; Ae++, tn = dt.next())
        (tn = xt(xe, ct, Ae, tn.value, Pt)),
          tn !== null &&
            (n && tn.alternate !== null && xe.delete(tn.key === null ? Ae : tn.key),
            ($ = v(tn, $, Ae)),
            Xe === null ? (de = tn) : (Xe.sibling = tn),
            (Xe = tn));
      return (
        n &&
          xe.forEach(function (Bb) {
            return i(ct, Bb);
          }),
        Le && ht(ct, Ae),
        de
      );
    }
    function fn(ct, $, dt, Pt) {
      if (
        (typeof dt == 'object' &&
          dt !== null &&
          dt.type === A &&
          dt.key === null &&
          (dt = dt.props.children),
        typeof dt == 'object' && dt !== null)
      ) {
        switch (dt.$$typeof) {
          case b:
            t: {
              for (var de = dt.key; $ !== null; ) {
                if ($.key === de) {
                  if (((de = dt.type), de === A)) {
                    if ($.tag === 7) {
                      o(ct, $.sibling), (Pt = p($, dt.props.children)), (Pt.return = ct), (ct = Pt);
                      break t;
                    }
                  } else if (
                    $.elementType === de ||
                    (typeof de == 'object' && de !== null && de.$$typeof === J && sv(de) === $.type)
                  ) {
                    o(ct, $.sibling),
                      (Pt = p($, dt.props)),
                      wc(Pt, dt),
                      (Pt.return = ct),
                      (ct = Pt);
                    break t;
                  }
                  o(ct, $);
                  break;
                } else i(ct, $);
                $ = $.sibling;
              }
              dt.type === A
                ? ((Pt = Ba(dt.props.children, ct.mode, Pt, dt.key)), (Pt.return = ct), (ct = Pt))
                : ((Pt = Js(dt.type, dt.key, dt.props, null, ct.mode, Pt)),
                  wc(Pt, dt),
                  (Pt.return = ct),
                  (ct = Pt));
            }
            return C(ct);
          case E:
            t: {
              for (de = dt.key; $ !== null; ) {
                if ($.key === de)
                  if (
                    $.tag === 4 &&
                    $.stateNode.containerInfo === dt.containerInfo &&
                    $.stateNode.implementation === dt.implementation
                  ) {
                    o(ct, $.sibling), (Pt = p($, dt.children || [])), (Pt.return = ct), (ct = Pt);
                    break t;
                  } else {
                    o(ct, $);
                    break;
                  }
                else i(ct, $);
                $ = $.sibling;
              }
              (Pt = Zo(dt, ct.mode, Pt)), (Pt.return = ct), (ct = Pt);
            }
            return C(ct);
          case J:
            return (de = dt._init), (dt = de(dt._payload)), fn(ct, $, dt, Pt);
        }
        if (bt(dt)) return Ce(ct, $, dt, Pt);
        if (ft(dt)) {
          if (((de = ft(dt)), typeof de != 'function')) throw Error(s(150));
          return (dt = de.call(dt)), we(ct, $, dt, Pt);
        }
        if (typeof dt.then == 'function') return fn(ct, $, ch(dt), Pt);
        if (dt.$$typeof === P) return fn(ct, $, Ku(ct, dt), Pt);
        uh(ct, dt);
      }
      return (typeof dt == 'string' && dt !== '') || typeof dt == 'number' || typeof dt == 'bigint'
        ? ((dt = '' + dt),
          $ !== null && $.tag === 6
            ? (o(ct, $.sibling), (Pt = p($, dt)), (Pt.return = ct), (ct = Pt))
            : (o(ct, $), (Pt = dc(dt, ct.mode, Pt)), (Pt.return = ct), (ct = Pt)),
          C(ct))
        : o(ct, $);
    }
    return function (ct, $, dt, Pt) {
      try {
        Tc = 0;
        var de = fn(ct, $, dt, Pt);
        return ($o = null), de;
      } catch (xe) {
        if (xe === _c || xe === Ju) throw xe;
        var Xe = Ti(29, xe, null, ct.mode);
        return (Xe.lanes = Pt), (Xe.return = ct), Xe;
      } finally {
      }
    };
  }
  var tl = ov(!0),
    lv = ov(!1),
    la = Q(null),
    Fa = null;
  function ls(n) {
    var i = n.alternate;
    At(Xn, Xn.current & 1),
      At(la, n),
      Fa === null && (i === null || Yo.current !== null || i.memoizedState !== null) && (Fa = n);
  }
  function cv(n) {
    if (n.tag === 22) {
      if ((At(Xn, Xn.current), At(la, n), Fa === null)) {
        var i = n.alternate;
        i !== null && i.memoizedState !== null && (Fa = n);
      }
    } else cs();
  }
  function cs() {
    At(Xn, Xn.current), At(la, la.current);
  }
  function mr(n) {
    gt(la), Fa === n && (Fa = null), gt(Xn);
  }
  var Xn = Q(0);
  function hh(n) {
    for (var i = n; i !== null; ) {
      if (i.tag === 13) {
        var o = i.memoizedState;
        if (o !== null && ((o = o.dehydrated), o === null || o.data === '$?' || Ap(o))) return i;
      } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
        if ((i.flags & 128) !== 0) return i;
      } else if (i.child !== null) {
        (i.child.return = i), (i = i.child);
        continue;
      }
      if (i === n) break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === n) return null;
        i = i.return;
      }
      (i.sibling.return = i.return), (i = i.sibling);
    }
    return null;
  }
  function Bd(n, i, o, u) {
    (i = n.memoizedState),
      (o = o(u, i)),
      (o = o == null ? i : x({}, i, o)),
      (n.memoizedState = o),
      n.lanes === 0 && (n.updateQueue.baseState = o);
  }
  var kd = {
    enqueueSetState: function (n, i, o) {
      n = n._reactInternals;
      var u = qi(),
        p = rs(u);
      (p.payload = i),
        o != null && (p.callback = o),
        (i = ss(n, p, u)),
        i !== null && (Yi(i, n, u), vc(i, n, u));
    },
    enqueueReplaceState: function (n, i, o) {
      n = n._reactInternals;
      var u = qi(),
        p = rs(u);
      (p.tag = 1),
        (p.payload = i),
        o != null && (p.callback = o),
        (i = ss(n, p, u)),
        i !== null && (Yi(i, n, u), vc(i, n, u));
    },
    enqueueForceUpdate: function (n, i) {
      n = n._reactInternals;
      var o = qi(),
        u = rs(o);
      (u.tag = 2),
        i != null && (u.callback = i),
        (i = ss(n, u, o)),
        i !== null && (Yi(i, n, o), vc(i, n, o));
    },
  };
  function uv(n, i, o, u, p, v, C) {
    return (
      (n = n.stateNode),
      typeof n.shouldComponentUpdate == 'function'
        ? n.shouldComponentUpdate(u, v, C)
        : i.prototype && i.prototype.isPureReactComponent
          ? !Mi(o, u) || !Mi(p, v)
          : !0
    );
  }
  function hv(n, i, o, u) {
    (n = i.state),
      typeof i.componentWillReceiveProps == 'function' && i.componentWillReceiveProps(o, u),
      typeof i.UNSAFE_componentWillReceiveProps == 'function' &&
        i.UNSAFE_componentWillReceiveProps(o, u),
      i.state !== n && kd.enqueueReplaceState(i, i.state, null);
  }
  function ro(n, i) {
    var o = i;
    if ('ref' in i) {
      o = {};
      for (var u in i) u !== 'ref' && (o[u] = i[u]);
    }
    if ((n = n.defaultProps)) {
      o === i && (o = x({}, o));
      for (var p in n) o[p] === void 0 && (o[p] = n[p]);
    }
    return o;
  }
  var fh =
    typeof reportError == 'function'
      ? reportError
      : function (n) {
          if (typeof window == 'object' && typeof window.ErrorEvent == 'function') {
            var i = new window.ErrorEvent('error', {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof n == 'object' && n !== null && typeof n.message == 'string'
                  ? String(n.message)
                  : String(n),
              error: n,
            });
            if (!window.dispatchEvent(i)) return;
          } else if (typeof process == 'object' && typeof process.emit == 'function') {
            process.emit('uncaughtException', n);
            return;
          }
          console.error(n);
        };
  function fv(n) {
    fh(n);
  }
  function dv(n) {
    console.error(n);
  }
  function pv(n) {
    fh(n);
  }
  function dh(n, i) {
    try {
      var o = n.onUncaughtError;
      o(i.value, { componentStack: i.stack });
    } catch (u) {
      setTimeout(function () {
        throw u;
      });
    }
  }
  function mv(n, i, o) {
    try {
      var u = n.onCaughtError;
      u(o.value, { componentStack: o.stack, errorBoundary: i.tag === 1 ? i.stateNode : null });
    } catch (p) {
      setTimeout(function () {
        throw p;
      });
    }
  }
  function Fd(n, i, o) {
    return (
      (o = rs(o)),
      (o.tag = 3),
      (o.payload = { element: null }),
      (o.callback = function () {
        dh(n, i);
      }),
      o
    );
  }
  function _v(n) {
    return (n = rs(n)), (n.tag = 3), n;
  }
  function gv(n, i, o, u) {
    var p = o.type.getDerivedStateFromError;
    if (typeof p == 'function') {
      var v = u.value;
      (n.payload = function () {
        return p(v);
      }),
        (n.callback = function () {
          mv(i, o, u);
        });
    }
    var C = o.stateNode;
    C !== null &&
      typeof C.componentDidCatch == 'function' &&
      (n.callback = function () {
        mv(i, o, u),
          typeof p != 'function' && (ms === null ? (ms = new Set([this])) : ms.add(this));
        var B = u.stack;
        this.componentDidCatch(u.value, { componentStack: B !== null ? B : '' });
      });
  }
  function BM(n, i, o, u, p) {
    if (((o.flags |= 32768), u !== null && typeof u == 'object' && typeof u.then == 'function')) {
      if (((i = o.alternate), i !== null && eo(i, o, p, !0), (o = la.current), o !== null)) {
        switch (o.tag) {
          case 13:
            return (
              Fa === null ? up() : o.alternate === null && On === 0 && (On = 3),
              (o.flags &= -257),
              (o.flags |= 65536),
              (o.lanes = p),
              u === md
                ? (o.flags |= 16384)
                : ((i = o.updateQueue),
                  i === null ? (o.updateQueue = new Set([u])) : i.add(u),
                  fp(n, u, p)),
              !1
            );
          case 22:
            return (
              (o.flags |= 65536),
              u === md
                ? (o.flags |= 16384)
                : ((i = o.updateQueue),
                  i === null
                    ? ((i = { transitions: null, markerInstances: null, retryQueue: new Set([u]) }),
                      (o.updateQueue = i))
                    : ((o = i.retryQueue), o === null ? (i.retryQueue = new Set([u])) : o.add(u)),
                  fp(n, u, p)),
              !1
            );
        }
        throw Error(s(435, o.tag));
      }
      return fp(n, u, p), up(), !1;
    }
    if (Le)
      return (
        (i = la.current),
        i !== null
          ? ((i.flags & 65536) === 0 && (i.flags |= 256),
            (i.flags |= 65536),
            (i.lanes = p),
            u !== Jn && ((n = Error(s(422), { cause: u })), is(bi(n, o))))
          : (u !== Jn && ((i = Error(s(423), { cause: u })), is(bi(i, o))),
            (n = n.current.alternate),
            (n.flags |= 65536),
            (p &= -p),
            (n.lanes |= p),
            (u = bi(u, o)),
            (p = Fd(n.stateNode, u, p)),
            vd(n, p),
            On !== 4 && (On = 2)),
        !1
      );
    var v = Error(s(520), { cause: u });
    if (((v = bi(v, o)), Oc === null ? (Oc = [v]) : Oc.push(v), On !== 4 && (On = 2), i === null))
      return !0;
    (u = bi(u, o)), (o = i);
    do {
      switch (o.tag) {
        case 3:
          return (
            (o.flags |= 65536),
            (n = p & -p),
            (o.lanes |= n),
            (n = Fd(o.stateNode, u, n)),
            vd(o, n),
            !1
          );
        case 1:
          if (
            ((i = o.type),
            (v = o.stateNode),
            (o.flags & 128) === 0 &&
              (typeof i.getDerivedStateFromError == 'function' ||
                (v !== null &&
                  typeof v.componentDidCatch == 'function' &&
                  (ms === null || !ms.has(v)))))
          )
            return (
              (o.flags |= 65536),
              (p &= -p),
              (o.lanes |= p),
              (p = _v(p)),
              gv(p, n, o, u),
              vd(o, p),
              !1
            );
      }
      o = o.return;
    } while (o !== null);
    return !1;
  }
  var vv = Error(s(461)),
    $n = !1;
  function ri(n, i, o, u) {
    i.child = n === null ? lv(i, null, o, u) : tl(i, n.child, o, u);
  }
  function yv(n, i, o, u, p) {
    o = o.render;
    var v = i.ref;
    if ('ref' in u) {
      var C = {};
      for (var B in u) B !== 'ref' && (C[B] = u[B]);
    } else C = u;
    return (
      no(i),
      (u = bd(n, i, o, C, v, p)),
      (B = Ed()),
      n !== null && !$n
        ? (Td(n, i, p), _r(n, i, p))
        : (Le && B && Ft(i), (i.flags |= 1), ri(n, i, u, p), i.child)
    );
  }
  function xv(n, i, o, u, p) {
    if (n === null) {
      var v = o.type;
      return typeof v == 'function' && !Wo(v) && v.defaultProps === void 0 && o.compare === null
        ? ((i.tag = 15), (i.type = v), Sv(n, i, v, u, p))
        : ((n = Js(o.type, null, u, i, i.mode, p)), (n.ref = i.ref), (n.return = i), (i.child = n));
    }
    if (((v = n.child), !qd(n, p))) {
      var C = v.memoizedProps;
      if (((o = o.compare), (o = o !== null ? o : Mi), o(C, u) && n.ref === i.ref))
        return _r(n, i, p);
    }
    return (i.flags |= 1), (n = sa(v, u)), (n.ref = i.ref), (n.return = i), (i.child = n);
  }
  function Sv(n, i, o, u, p) {
    if (n !== null) {
      var v = n.memoizedProps;
      if (Mi(v, u) && n.ref === i.ref)
        if ((($n = !1), (i.pendingProps = u = v), qd(n, p))) (n.flags & 131072) !== 0 && ($n = !0);
        else return (i.lanes = n.lanes), _r(n, i, p);
    }
    return Hd(n, i, o, u, p);
  }
  function Mv(n, i, o) {
    var u = i.pendingProps,
      p = u.children,
      v = n !== null ? n.memoizedState : null;
    if (u.mode === 'hidden') {
      if ((i.flags & 128) !== 0) {
        if (((u = v !== null ? v.baseLanes | o : o), n !== null)) {
          for (p = i.child = n.child, v = 0; p !== null; )
            (v = v | p.lanes | p.childLanes), (p = p.sibling);
          i.childLanes = v & ~u;
        } else (i.childLanes = 0), (i.child = null);
        return bv(n, i, u, o);
      }
      if ((o & 536870912) !== 0)
        (i.memoizedState = { baseLanes: 0, cachePool: null }),
          n !== null && Qu(i, v !== null ? v.cachePool : null),
          v !== null ? Sg(i, v) : xd(),
          cv(i);
      else
        return (i.lanes = i.childLanes = 536870912), bv(n, i, v !== null ? v.baseLanes | o : o, o);
    } else
      v !== null
        ? (Qu(i, v.cachePool), Sg(i, v), cs(), (i.memoizedState = null))
        : (n !== null && Qu(i, null), xd(), cs());
    return ri(n, i, p, o), i.child;
  }
  function bv(n, i, o, u) {
    var p = pd();
    return (
      (p = p === null ? null : { parent: Zn._currentValue, pool: p }),
      (i.memoizedState = { baseLanes: o, cachePool: p }),
      n !== null && Qu(i, null),
      xd(),
      cv(i),
      n !== null && eo(n, i, u, !0),
      null
    );
  }
  function ph(n, i) {
    var o = i.ref;
    if (o === null) n !== null && n.ref !== null && (i.flags |= 4194816);
    else {
      if (typeof o != 'function' && typeof o != 'object') throw Error(s(284));
      (n === null || n.ref !== o) && (i.flags |= 4194816);
    }
  }
  function Hd(n, i, o, u, p) {
    return (
      no(i),
      (o = bd(n, i, o, u, void 0, p)),
      (u = Ed()),
      n !== null && !$n
        ? (Td(n, i, p), _r(n, i, p))
        : (Le && u && Ft(i), (i.flags |= 1), ri(n, i, o, p), i.child)
    );
  }
  function Ev(n, i, o, u, p, v) {
    return (
      no(i),
      (i.updateQueue = null),
      (o = bg(i, u, o, p)),
      Mg(n),
      (u = Ed()),
      n !== null && !$n
        ? (Td(n, i, v), _r(n, i, v))
        : (Le && u && Ft(i), (i.flags |= 1), ri(n, i, o, v), i.child)
    );
  }
  function Tv(n, i, o, u, p) {
    if ((no(i), i.stateNode === null)) {
      var v = fr,
        C = o.contextType;
      typeof C == 'object' && C !== null && (v = di(C)),
        (v = new o(u, v)),
        (i.memoizedState = v.state !== null && v.state !== void 0 ? v.state : null),
        (v.updater = kd),
        (i.stateNode = v),
        (v._reactInternals = i),
        (v = i.stateNode),
        (v.props = u),
        (v.state = i.memoizedState),
        (v.refs = {}),
        _d(i),
        (C = o.contextType),
        (v.context = typeof C == 'object' && C !== null ? di(C) : fr),
        (v.state = i.memoizedState),
        (C = o.getDerivedStateFromProps),
        typeof C == 'function' && (Bd(i, o, C, u), (v.state = i.memoizedState)),
        typeof o.getDerivedStateFromProps == 'function' ||
          typeof v.getSnapshotBeforeUpdate == 'function' ||
          (typeof v.UNSAFE_componentWillMount != 'function' &&
            typeof v.componentWillMount != 'function') ||
          ((C = v.state),
          typeof v.componentWillMount == 'function' && v.componentWillMount(),
          typeof v.UNSAFE_componentWillMount == 'function' && v.UNSAFE_componentWillMount(),
          C !== v.state && kd.enqueueReplaceState(v, v.state, null),
          xc(i, u, v, p),
          yc(),
          (v.state = i.memoizedState)),
        typeof v.componentDidMount == 'function' && (i.flags |= 4194308),
        (u = !0);
    } else if (n === null) {
      v = i.stateNode;
      var B = i.memoizedProps,
        Y = ro(o, B);
      v.props = Y;
      var mt = v.context,
        Rt = o.contextType;
      (C = fr), typeof Rt == 'object' && Rt !== null && (C = di(Rt));
      var Nt = o.getDerivedStateFromProps;
      (Rt = typeof Nt == 'function' || typeof v.getSnapshotBeforeUpdate == 'function'),
        (B = i.pendingProps !== B),
        Rt ||
          (typeof v.UNSAFE_componentWillReceiveProps != 'function' &&
            typeof v.componentWillReceiveProps != 'function') ||
          ((B || mt !== C) && hv(i, v, u, C)),
        (as = !1);
      var vt = i.memoizedState;
      (v.state = vt),
        xc(i, u, v, p),
        yc(),
        (mt = i.memoizedState),
        B || vt !== mt || as
          ? (typeof Nt == 'function' && (Bd(i, o, Nt, u), (mt = i.memoizedState)),
            (Y = as || uv(i, o, Y, u, vt, mt, C))
              ? (Rt ||
                  (typeof v.UNSAFE_componentWillMount != 'function' &&
                    typeof v.componentWillMount != 'function') ||
                  (typeof v.componentWillMount == 'function' && v.componentWillMount(),
                  typeof v.UNSAFE_componentWillMount == 'function' &&
                    v.UNSAFE_componentWillMount()),
                typeof v.componentDidMount == 'function' && (i.flags |= 4194308))
              : (typeof v.componentDidMount == 'function' && (i.flags |= 4194308),
                (i.memoizedProps = u),
                (i.memoizedState = mt)),
            (v.props = u),
            (v.state = mt),
            (v.context = C),
            (u = Y))
          : (typeof v.componentDidMount == 'function' && (i.flags |= 4194308), (u = !1));
    } else {
      (v = i.stateNode),
        gd(n, i),
        (C = i.memoizedProps),
        (Rt = ro(o, C)),
        (v.props = Rt),
        (Nt = i.pendingProps),
        (vt = v.context),
        (mt = o.contextType),
        (Y = fr),
        typeof mt == 'object' && mt !== null && (Y = di(mt)),
        (B = o.getDerivedStateFromProps),
        (mt = typeof B == 'function' || typeof v.getSnapshotBeforeUpdate == 'function') ||
          (typeof v.UNSAFE_componentWillReceiveProps != 'function' &&
            typeof v.componentWillReceiveProps != 'function') ||
          ((C !== Nt || vt !== Y) && hv(i, v, u, Y)),
        (as = !1),
        (vt = i.memoizedState),
        (v.state = vt),
        xc(i, u, v, p),
        yc();
      var xt = i.memoizedState;
      C !== Nt || vt !== xt || as || (n !== null && n.dependencies !== null && Yu(n.dependencies))
        ? (typeof B == 'function' && (Bd(i, o, B, u), (xt = i.memoizedState)),
          (Rt =
            as ||
            uv(i, o, Rt, u, vt, xt, Y) ||
            (n !== null && n.dependencies !== null && Yu(n.dependencies)))
            ? (mt ||
                (typeof v.UNSAFE_componentWillUpdate != 'function' &&
                  typeof v.componentWillUpdate != 'function') ||
                (typeof v.componentWillUpdate == 'function' && v.componentWillUpdate(u, xt, Y),
                typeof v.UNSAFE_componentWillUpdate == 'function' &&
                  v.UNSAFE_componentWillUpdate(u, xt, Y)),
              typeof v.componentDidUpdate == 'function' && (i.flags |= 4),
              typeof v.getSnapshotBeforeUpdate == 'function' && (i.flags |= 1024))
            : (typeof v.componentDidUpdate != 'function' ||
                (C === n.memoizedProps && vt === n.memoizedState) ||
                (i.flags |= 4),
              typeof v.getSnapshotBeforeUpdate != 'function' ||
                (C === n.memoizedProps && vt === n.memoizedState) ||
                (i.flags |= 1024),
              (i.memoizedProps = u),
              (i.memoizedState = xt)),
          (v.props = u),
          (v.state = xt),
          (v.context = Y),
          (u = Rt))
        : (typeof v.componentDidUpdate != 'function' ||
            (C === n.memoizedProps && vt === n.memoizedState) ||
            (i.flags |= 4),
          typeof v.getSnapshotBeforeUpdate != 'function' ||
            (C === n.memoizedProps && vt === n.memoizedState) ||
            (i.flags |= 1024),
          (u = !1));
    }
    return (
      (v = u),
      ph(n, i),
      (u = (i.flags & 128) !== 0),
      v || u
        ? ((v = i.stateNode),
          (o = u && typeof o.getDerivedStateFromError != 'function' ? null : v.render()),
          (i.flags |= 1),
          n !== null && u
            ? ((i.child = tl(i, n.child, null, p)), (i.child = tl(i, null, o, p)))
            : ri(n, i, o, p),
          (i.memoizedState = v.state),
          (n = i.child))
        : (n = _r(n, i, p)),
      n
    );
  }
  function wv(n, i, o, u) {
    return ns(), (i.flags |= 256), ri(n, i, o, u), i.child;
  }
  var Gd = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null };
  function Vd(n) {
    return { baseLanes: n, cachePool: dg() };
  }
  function Wd(n, i, o) {
    return (n = n !== null ? n.childLanes & ~o : 0), i && (n |= ca), n;
  }
  function Av(n, i, o) {
    var u = i.pendingProps,
      p = !1,
      v = (i.flags & 128) !== 0,
      C;
    if (
      ((C = v) || (C = n !== null && n.memoizedState === null ? !1 : (Xn.current & 2) !== 0),
      C && ((p = !0), (i.flags &= -129)),
      (C = (i.flags & 32) !== 0),
      (i.flags &= -33),
      n === null)
    ) {
      if (Le) {
        if ((p ? ls(i) : cs(), Le)) {
          var B = _e,
            Y;
          if ((Y = B)) {
            t: {
              for (Y = B, B = Tn; Y.nodeType !== 8; ) {
                if (!B) {
                  B = null;
                  break t;
                }
                if (((Y = wa(Y.nextSibling)), Y === null)) {
                  B = null;
                  break t;
                }
              }
              B = Y;
            }
            B !== null
              ? ((i.memoizedState = {
                  dehydrated: B,
                  treeContext: w !== null ? { id: U, overflow: q } : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (Y = Ti(18, null, null, 0)),
                (Y.stateNode = B),
                (Y.return = i),
                (i.child = Y),
                (he = i),
                (_e = null),
                (Y = !0))
              : (Y = !1);
          }
          Y || Ri(i);
        }
        if (((B = i.memoizedState), B !== null && ((B = B.dehydrated), B !== null)))
          return Ap(B) ? (i.lanes = 32) : (i.lanes = 536870912), null;
        mr(i);
      }
      return (
        (B = u.children),
        (u = u.fallback),
        p
          ? (cs(),
            (p = i.mode),
            (B = mh({ mode: 'hidden', children: B }, p)),
            (u = Ba(u, p, o, null)),
            (B.return = i),
            (u.return = i),
            (B.sibling = u),
            (i.child = B),
            (p = i.child),
            (p.memoizedState = Vd(o)),
            (p.childLanes = Wd(n, C, o)),
            (i.memoizedState = Gd),
            u)
          : (ls(i), Zd(i, B))
      );
    }
    if (((Y = n.memoizedState), Y !== null && ((B = Y.dehydrated), B !== null))) {
      if (v)
        i.flags & 256
          ? (ls(i), (i.flags &= -257), (i = Xd(n, i, o)))
          : i.memoizedState !== null
            ? (cs(), (i.child = n.child), (i.flags |= 128), (i = null))
            : (cs(),
              (p = u.fallback),
              (B = i.mode),
              (u = mh({ mode: 'visible', children: u.children }, B)),
              (p = Ba(p, B, o, null)),
              (p.flags |= 2),
              (u.return = i),
              (p.return = i),
              (u.sibling = p),
              (i.child = u),
              tl(i, n.child, null, o),
              (u = i.child),
              (u.memoizedState = Vd(o)),
              (u.childLanes = Wd(n, C, o)),
              (i.memoizedState = Gd),
              (i = p));
      else if ((ls(i), Ap(B))) {
        if (((C = B.nextSibling && B.nextSibling.dataset), C)) var mt = C.dgst;
        (C = mt),
          (u = Error(s(419))),
          (u.stack = ''),
          (u.digest = C),
          is({ value: u, source: null, stack: null }),
          (i = Xd(n, i, o));
      } else if (($n || eo(n, i, o, !1), (C = (o & n.childLanes) !== 0), $n || C)) {
        if (
          ((C = yn),
          C !== null &&
            ((u = o & -o),
            (u = (u & 42) !== 0 ? 1 : cn(u)),
            (u = (u & (C.suspendedLanes | o)) !== 0 ? 0 : u),
            u !== 0 && u !== Y.retryLane))
        )
          throw ((Y.retryLane = u), ts(n, u), Yi(C, n, u), vv);
        B.data === '$?' || up(), (i = Xd(n, i, o));
      } else
        B.data === '$?'
          ? ((i.flags |= 192), (i.child = n.child), (i = null))
          : ((n = Y.treeContext),
            (_e = wa(B.nextSibling)),
            (he = i),
            (Le = !0),
            (vn = null),
            (Tn = !1),
            n !== null &&
              ((d[y++] = U), (d[y++] = q), (d[y++] = w), (U = n.id), (q = n.overflow), (w = i)),
            (i = Zd(i, u.children)),
            (i.flags |= 4096));
      return i;
    }
    return p
      ? (cs(),
        (p = u.fallback),
        (B = i.mode),
        (Y = n.child),
        (mt = Y.sibling),
        (u = sa(Y, { mode: 'hidden', children: u.children })),
        (u.subtreeFlags = Y.subtreeFlags & 65011712),
        mt !== null ? (p = sa(mt, p)) : ((p = Ba(p, B, o, null)), (p.flags |= 2)),
        (p.return = i),
        (u.return = i),
        (u.sibling = p),
        (i.child = u),
        (u = p),
        (p = i.child),
        (B = n.child.memoizedState),
        B === null
          ? (B = Vd(o))
          : ((Y = B.cachePool),
            Y !== null
              ? ((mt = Zn._currentValue), (Y = Y.parent !== mt ? { parent: mt, pool: mt } : Y))
              : (Y = dg()),
            (B = { baseLanes: B.baseLanes | o, cachePool: Y })),
        (p.memoizedState = B),
        (p.childLanes = Wd(n, C, o)),
        (i.memoizedState = Gd),
        u)
      : (ls(i),
        (o = n.child),
        (n = o.sibling),
        (o = sa(o, { mode: 'visible', children: u.children })),
        (o.return = i),
        (o.sibling = null),
        n !== null &&
          ((C = i.deletions), C === null ? ((i.deletions = [n]), (i.flags |= 16)) : C.push(n)),
        (i.child = o),
        (i.memoizedState = null),
        o);
  }
  function Zd(n, i) {
    return (i = mh({ mode: 'visible', children: i }, n.mode)), (i.return = n), (n.child = i);
  }
  function mh(n, i) {
    return (
      (n = Ti(22, n, null, i)),
      (n.lanes = 0),
      (n.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null,
      }),
      n
    );
  }
  function Xd(n, i, o) {
    return (
      tl(i, n.child, null, o),
      (n = Zd(i, i.pendingProps.children)),
      (n.flags |= 2),
      (i.memoizedState = null),
      n
    );
  }
  function Cv(n, i, o) {
    n.lanes |= i;
    var u = n.alternate;
    u !== null && (u.lanes |= i), to(n.return, i, o);
  }
  function jd(n, i, o, u, p) {
    var v = n.memoizedState;
    v === null
      ? (n.memoizedState = {
          isBackwards: i,
          rendering: null,
          renderingStartTime: 0,
          last: u,
          tail: o,
          tailMode: p,
        })
      : ((v.isBackwards = i),
        (v.rendering = null),
        (v.renderingStartTime = 0),
        (v.last = u),
        (v.tail = o),
        (v.tailMode = p));
  }
  function Rv(n, i, o) {
    var u = i.pendingProps,
      p = u.revealOrder,
      v = u.tail;
    if ((ri(n, i, u.children, o), (u = Xn.current), (u & 2) !== 0))
      (u = (u & 1) | 2), (i.flags |= 128);
    else {
      if (n !== null && (n.flags & 128) !== 0)
        t: for (n = i.child; n !== null; ) {
          if (n.tag === 13) n.memoizedState !== null && Cv(n, o, i);
          else if (n.tag === 19) Cv(n, o, i);
          else if (n.child !== null) {
            (n.child.return = n), (n = n.child);
            continue;
          }
          if (n === i) break t;
          for (; n.sibling === null; ) {
            if (n.return === null || n.return === i) break t;
            n = n.return;
          }
          (n.sibling.return = n.return), (n = n.sibling);
        }
      u &= 1;
    }
    switch ((At(Xn, u), p)) {
      case 'forwards':
        for (o = i.child, p = null; o !== null; )
          (n = o.alternate), n !== null && hh(n) === null && (p = o), (o = o.sibling);
        (o = p),
          o === null ? ((p = i.child), (i.child = null)) : ((p = o.sibling), (o.sibling = null)),
          jd(i, !1, p, o, v);
        break;
      case 'backwards':
        for (o = null, p = i.child, i.child = null; p !== null; ) {
          if (((n = p.alternate), n !== null && hh(n) === null)) {
            i.child = p;
            break;
          }
          (n = p.sibling), (p.sibling = o), (o = p), (p = n);
        }
        jd(i, !0, o, null, v);
        break;
      case 'together':
        jd(i, !1, null, null, void 0);
        break;
      default:
        i.memoizedState = null;
    }
    return i.child;
  }
  function _r(n, i, o) {
    if (
      (n !== null && (i.dependencies = n.dependencies), (ps |= i.lanes), (o & i.childLanes) === 0)
    )
      if (n !== null) {
        if ((eo(n, i, o, !1), (o & i.childLanes) === 0)) return null;
      } else return null;
    if (n !== null && i.child !== n.child) throw Error(s(153));
    if (i.child !== null) {
      for (n = i.child, o = sa(n, n.pendingProps), i.child = o, o.return = i; n.sibling !== null; )
        (n = n.sibling), (o = o.sibling = sa(n, n.pendingProps)), (o.return = i);
      o.sibling = null;
    }
    return i.child;
  }
  function qd(n, i) {
    return (n.lanes & i) !== 0 ? !0 : ((n = n.dependencies), !!(n !== null && Yu(n)));
  }
  function kM(n, i, o) {
    switch (i.tag) {
      case 3:
        Gt(i, i.stateNode.containerInfo), ka(i, Zn, n.memoizedState.cache), ns();
        break;
      case 27:
      case 5:
        oe(i);
        break;
      case 4:
        Gt(i, i.stateNode.containerInfo);
        break;
      case 10:
        ka(i, i.type, i.memoizedProps.value);
        break;
      case 13:
        var u = i.memoizedState;
        if (u !== null)
          return u.dehydrated !== null
            ? (ls(i), (i.flags |= 128), null)
            : (o & i.child.childLanes) !== 0
              ? Av(n, i, o)
              : (ls(i), (n = _r(n, i, o)), n !== null ? n.sibling : null);
        ls(i);
        break;
      case 19:
        var p = (n.flags & 128) !== 0;
        if (
          ((u = (o & i.childLanes) !== 0),
          u || (eo(n, i, o, !1), (u = (o & i.childLanes) !== 0)),
          p)
        ) {
          if (u) return Rv(n, i, o);
          i.flags |= 128;
        }
        if (
          ((p = i.memoizedState),
          p !== null && ((p.rendering = null), (p.tail = null), (p.lastEffect = null)),
          At(Xn, Xn.current),
          u)
        )
          break;
        return null;
      case 22:
      case 23:
        return (i.lanes = 0), Mv(n, i, o);
      case 24:
        ka(i, Zn, n.memoizedState.cache);
    }
    return _r(n, i, o);
  }
  function Lv(n, i, o) {
    if (n !== null)
      if (n.memoizedProps !== i.pendingProps) $n = !0;
      else {
        if (!qd(n, o) && (i.flags & 128) === 0) return ($n = !1), kM(n, i, o);
        $n = (n.flags & 131072) !== 0;
      }
    else ($n = !1), Le && (i.flags & 1048576) !== 0 && St(i, c, i.index);
    switch (((i.lanes = 0), i.tag)) {
      case 16:
        t: {
          n = i.pendingProps;
          var u = i.elementType,
            p = u._init;
          if (((u = p(u._payload)), (i.type = u), typeof u == 'function'))
            Wo(u)
              ? ((n = ro(u, n)), (i.tag = 1), (i = Tv(null, i, u, n, o)))
              : ((i.tag = 0), (i = Hd(null, i, u, n, o)));
          else {
            if (u != null) {
              if (((p = u.$$typeof), p === D)) {
                (i.tag = 11), (i = yv(null, i, u, n, o));
                break t;
              } else if (p === V) {
                (i.tag = 14), (i = xv(null, i, u, n, o));
                break t;
              }
            }
            throw ((i = Mt(u) || u), Error(s(306, i, '')));
          }
        }
        return i;
      case 0:
        return Hd(n, i, i.type, i.pendingProps, o);
      case 1:
        return (u = i.type), (p = ro(u, i.pendingProps)), Tv(n, i, u, p, o);
      case 3:
        t: {
          if ((Gt(i, i.stateNode.containerInfo), n === null)) throw Error(s(387));
          u = i.pendingProps;
          var v = i.memoizedState;
          (p = v.element), gd(n, i), xc(i, u, null, o);
          var C = i.memoizedState;
          if (
            ((u = C.cache),
            ka(i, Zn, u),
            u !== v.cache && Xo(i, [Zn], o, !0),
            yc(),
            (u = C.element),
            v.isDehydrated)
          )
            if (
              ((v = { element: u, isDehydrated: !1, cache: C.cache }),
              (i.updateQueue.baseState = v),
              (i.memoizedState = v),
              i.flags & 256)
            ) {
              i = wv(n, i, u, o);
              break t;
            } else if (u !== p) {
              (p = bi(Error(s(424)), i)), is(p), (i = wv(n, i, u, o));
              break t;
            } else {
              switch (((n = i.stateNode.containerInfo), n.nodeType)) {
                case 9:
                  n = n.body;
                  break;
                default:
                  n = n.nodeName === 'HTML' ? n.ownerDocument.body : n;
              }
              for (
                _e = wa(n.firstChild),
                  he = i,
                  Le = !0,
                  vn = null,
                  Tn = !0,
                  o = lv(i, null, u, o),
                  i.child = o;
                o;

              )
                (o.flags = (o.flags & -3) | 4096), (o = o.sibling);
            }
          else {
            if ((ns(), u === p)) {
              i = _r(n, i, o);
              break t;
            }
            ri(n, i, u, o);
          }
          i = i.child;
        }
        return i;
      case 26:
        return (
          ph(n, i),
          n === null
            ? (o = U0(i.type, null, i.pendingProps, null))
              ? (i.memoizedState = o)
              : Le ||
                ((o = i.type),
                (n = i.pendingProps),
                (u = Rh(_t.current).createElement(o)),
                (u[Nn] = i),
                (u[Wn] = n),
                oi(u, o, n),
                Ln(u),
                (i.stateNode = u))
            : (i.memoizedState = U0(i.type, n.memoizedProps, i.pendingProps, n.memoizedState)),
          null
        );
      case 27:
        return (
          oe(i),
          n === null &&
            Le &&
            ((u = i.stateNode = P0(i.type, i.pendingProps, _t.current)),
            (he = i),
            (Tn = !0),
            (p = _e),
            vs(i.type) ? ((Cp = p), (_e = wa(u.firstChild))) : (_e = p)),
          ri(n, i, i.pendingProps.children, o),
          ph(n, i),
          n === null && (i.flags |= 4194304),
          i.child
        );
      case 5:
        return (
          n === null &&
            Le &&
            ((p = u = _e) &&
              ((u = db(u, i.type, i.pendingProps, Tn)),
              u !== null
                ? ((i.stateNode = u), (he = i), (_e = wa(u.firstChild)), (Tn = !1), (p = !0))
                : (p = !1)),
            p || Ri(i)),
          oe(i),
          (p = i.type),
          (v = i.pendingProps),
          (C = n !== null ? n.memoizedProps : null),
          (u = v.children),
          Ep(p, v) ? (u = null) : C !== null && Ep(p, C) && (i.flags |= 32),
          i.memoizedState !== null && ((p = bd(n, i, PM, null, null, o)), (Gc._currentValue = p)),
          ph(n, i),
          ri(n, i, u, o),
          i.child
        );
      case 6:
        return (
          n === null &&
            Le &&
            ((n = o = _e) &&
              ((o = pb(o, i.pendingProps, Tn)),
              o !== null ? ((i.stateNode = o), (he = i), (_e = null), (n = !0)) : (n = !1)),
            n || Ri(i)),
          null
        );
      case 13:
        return Av(n, i, o);
      case 4:
        return (
          Gt(i, i.stateNode.containerInfo),
          (u = i.pendingProps),
          n === null ? (i.child = tl(i, null, u, o)) : ri(n, i, u, o),
          i.child
        );
      case 11:
        return yv(n, i, i.type, i.pendingProps, o);
      case 7:
        return ri(n, i, i.pendingProps, o), i.child;
      case 8:
        return ri(n, i, i.pendingProps.children, o), i.child;
      case 12:
        return ri(n, i, i.pendingProps.children, o), i.child;
      case 10:
        return (u = i.pendingProps), ka(i, i.type, u.value), ri(n, i, u.children, o), i.child;
      case 9:
        return (
          (p = i.type._context),
          (u = i.pendingProps.children),
          no(i),
          (p = di(p)),
          (u = u(p)),
          (i.flags |= 1),
          ri(n, i, u, o),
          i.child
        );
      case 14:
        return xv(n, i, i.type, i.pendingProps, o);
      case 15:
        return Sv(n, i, i.type, i.pendingProps, o);
      case 19:
        return Rv(n, i, o);
      case 31:
        return (
          (u = i.pendingProps),
          (o = i.mode),
          (u = { mode: u.mode, children: u.children }),
          n === null
            ? ((o = mh(u, o)), (o.ref = i.ref), (i.child = o), (o.return = i), (i = o))
            : ((o = sa(n.child, u)), (o.ref = i.ref), (i.child = o), (o.return = i), (i = o)),
          i
        );
      case 22:
        return Mv(n, i, o);
      case 24:
        return (
          no(i),
          (u = di(Zn)),
          n === null
            ? ((p = pd()),
              p === null &&
                ((p = yn),
                (v = fd()),
                (p.pooledCache = v),
                v.refCount++,
                v !== null && (p.pooledCacheLanes |= o),
                (p = v)),
              (i.memoizedState = { parent: u, cache: p }),
              _d(i),
              ka(i, Zn, p))
            : ((n.lanes & o) !== 0 && (gd(n, i), xc(i, null, null, o), yc()),
              (p = n.memoizedState),
              (v = i.memoizedState),
              p.parent !== u
                ? ((p = { parent: u, cache: u }),
                  (i.memoizedState = p),
                  i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = p),
                  ka(i, Zn, u))
                : ((u = v.cache), ka(i, Zn, u), u !== p.cache && Xo(i, [Zn], o, !0))),
          ri(n, i, i.pendingProps.children, o),
          i.child
        );
      case 29:
        throw i.pendingProps;
    }
    throw Error(s(156, i.tag));
  }
  function gr(n) {
    n.flags |= 4;
  }
  function Pv(n, i) {
    if (i.type !== 'stylesheet' || (i.state.loading & 4) !== 0) n.flags &= -16777217;
    else if (((n.flags |= 16777216), !k0(i))) {
      if (
        ((i = la.current),
        i !== null &&
          ((Ke & 4194048) === Ke
            ? Fa !== null
            : ((Ke & 62914560) !== Ke && (Ke & 536870912) === 0) || i !== Fa))
      )
        throw ((gc = md), pg);
      n.flags |= 8192;
    }
  }
  function _h(n, i) {
    i !== null && (n.flags |= 4),
      n.flags & 16384 && ((i = n.tag !== 22 ? qt() : 536870912), (n.lanes |= i), (al |= i));
  }
  function Ac(n, i) {
    if (!Le)
      switch (n.tailMode) {
        case 'hidden':
          i = n.tail;
          for (var o = null; i !== null; ) i.alternate !== null && (o = i), (i = i.sibling);
          o === null ? (n.tail = null) : (o.sibling = null);
          break;
        case 'collapsed':
          o = n.tail;
          for (var u = null; o !== null; ) o.alternate !== null && (u = o), (o = o.sibling);
          u === null
            ? i || n.tail === null
              ? (n.tail = null)
              : (n.tail.sibling = null)
            : (u.sibling = null);
      }
  }
  function wn(n) {
    var i = n.alternate !== null && n.alternate.child === n.child,
      o = 0,
      u = 0;
    if (i)
      for (var p = n.child; p !== null; )
        (o |= p.lanes | p.childLanes),
          (u |= p.subtreeFlags & 65011712),
          (u |= p.flags & 65011712),
          (p.return = n),
          (p = p.sibling);
    else
      for (p = n.child; p !== null; )
        (o |= p.lanes | p.childLanes),
          (u |= p.subtreeFlags),
          (u |= p.flags),
          (p.return = n),
          (p = p.sibling);
    return (n.subtreeFlags |= u), (n.childLanes = o), i;
  }
  function FM(n, i, o) {
    var u = i.pendingProps;
    switch ((ie(i), i.tag)) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return wn(i), null;
      case 1:
        return wn(i), null;
      case 3:
        return (
          (o = i.stateNode),
          (u = null),
          n !== null && (u = n.memoizedState.cache),
          i.memoizedState.cache !== u && (i.flags |= 2048),
          Ea(Zn),
          fe(),
          o.pendingContext && ((o.context = o.pendingContext), (o.pendingContext = null)),
          (n === null || n.child === null) &&
            ($s(i)
              ? gr(i)
              : n === null ||
                (n.memoizedState.isDehydrated && (i.flags & 256) === 0) ||
                ((i.flags |= 1024), qu())),
          wn(i),
          null
        );
      case 26:
        return (
          (o = i.memoizedState),
          n === null
            ? (gr(i), o !== null ? (wn(i), Pv(i, o)) : (wn(i), (i.flags &= -16777217)))
            : o
              ? o !== n.memoizedState
                ? (gr(i), wn(i), Pv(i, o))
                : (wn(i), (i.flags &= -16777217))
              : (n.memoizedProps !== u && gr(i), wn(i), (i.flags &= -16777217)),
          null
        );
      case 27:
        Ne(i), (o = _t.current);
        var p = i.type;
        if (n !== null && i.stateNode != null) n.memoizedProps !== u && gr(i);
        else {
          if (!u) {
            if (i.stateNode === null) throw Error(s(166));
            return wn(i), null;
          }
          (n = tt.current), $s(i) ? Xu(i) : ((n = P0(p, u, o)), (i.stateNode = n), gr(i));
        }
        return wn(i), null;
      case 5:
        if ((Ne(i), (o = i.type), n !== null && i.stateNode != null))
          n.memoizedProps !== u && gr(i);
        else {
          if (!u) {
            if (i.stateNode === null) throw Error(s(166));
            return wn(i), null;
          }
          if (((n = tt.current), $s(i))) Xu(i);
          else {
            switch (((p = Rh(_t.current)), n)) {
              case 1:
                n = p.createElementNS('http://www.w3.org/2000/svg', o);
                break;
              case 2:
                n = p.createElementNS('http://www.w3.org/1998/Math/MathML', o);
                break;
              default:
                switch (o) {
                  case 'svg':
                    n = p.createElementNS('http://www.w3.org/2000/svg', o);
                    break;
                  case 'math':
                    n = p.createElementNS('http://www.w3.org/1998/Math/MathML', o);
                    break;
                  case 'script':
                    (n = p.createElement('div')),
                      (n.innerHTML = '<script><\/script>'),
                      (n = n.removeChild(n.firstChild));
                    break;
                  case 'select':
                    (n =
                      typeof u.is == 'string'
                        ? p.createElement('select', { is: u.is })
                        : p.createElement('select')),
                      u.multiple ? (n.multiple = !0) : u.size && (n.size = u.size);
                    break;
                  default:
                    n =
                      typeof u.is == 'string'
                        ? p.createElement(o, { is: u.is })
                        : p.createElement(o);
                }
            }
            (n[Nn] = i), (n[Wn] = u);
            t: for (p = i.child; p !== null; ) {
              if (p.tag === 5 || p.tag === 6) n.appendChild(p.stateNode);
              else if (p.tag !== 4 && p.tag !== 27 && p.child !== null) {
                (p.child.return = p), (p = p.child);
                continue;
              }
              if (p === i) break t;
              for (; p.sibling === null; ) {
                if (p.return === null || p.return === i) break t;
                p = p.return;
              }
              (p.sibling.return = p.return), (p = p.sibling);
            }
            i.stateNode = n;
            t: switch ((oi(n, o, u), o)) {
              case 'button':
              case 'input':
              case 'select':
              case 'textarea':
                n = !!u.autoFocus;
                break t;
              case 'img':
                n = !0;
                break t;
              default:
                n = !1;
            }
            n && gr(i);
          }
        }
        return wn(i), (i.flags &= -16777217), null;
      case 6:
        if (n && i.stateNode != null) n.memoizedProps !== u && gr(i);
        else {
          if (typeof u != 'string' && i.stateNode === null) throw Error(s(166));
          if (((n = _t.current), $s(i))) {
            if (((n = i.stateNode), (o = i.memoizedProps), (u = null), (p = he), p !== null))
              switch (p.tag) {
                case 27:
                case 5:
                  u = p.memoizedProps;
              }
            (n[Nn] = i),
              (n = !!(
                n.nodeValue === o ||
                (u !== null && u.suppressHydrationWarning === !0) ||
                E0(n.nodeValue, o)
              )),
              n || Ri(i);
          } else (n = Rh(n).createTextNode(u)), (n[Nn] = i), (i.stateNode = n);
        }
        return wn(i), null;
      case 13:
        if (
          ((u = i.memoizedState),
          n === null || (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
        ) {
          if (((p = $s(i)), u !== null && u.dehydrated !== null)) {
            if (n === null) {
              if (!p) throw Error(s(318));
              if (((p = i.memoizedState), (p = p !== null ? p.dehydrated : null), !p))
                throw Error(s(317));
              p[Nn] = i;
            } else ns(), (i.flags & 128) === 0 && (i.memoizedState = null), (i.flags |= 4);
            wn(i), (p = !1);
          } else
            (p = qu()),
              n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = p),
              (p = !0);
          if (!p) return i.flags & 256 ? (mr(i), i) : (mr(i), null);
        }
        if ((mr(i), (i.flags & 128) !== 0)) return (i.lanes = o), i;
        if (((o = u !== null), (n = n !== null && n.memoizedState !== null), o)) {
          (u = i.child),
            (p = null),
            u.alternate !== null &&
              u.alternate.memoizedState !== null &&
              u.alternate.memoizedState.cachePool !== null &&
              (p = u.alternate.memoizedState.cachePool.pool);
          var v = null;
          u.memoizedState !== null &&
            u.memoizedState.cachePool !== null &&
            (v = u.memoizedState.cachePool.pool),
            v !== p && (u.flags |= 2048);
        }
        return o !== n && o && (i.child.flags |= 8192), _h(i, i.updateQueue), wn(i), null;
      case 4:
        return fe(), n === null && yp(i.stateNode.containerInfo), wn(i), null;
      case 10:
        return Ea(i.type), wn(i), null;
      case 19:
        if ((gt(Xn), (p = i.memoizedState), p === null)) return wn(i), null;
        if (((u = (i.flags & 128) !== 0), (v = p.rendering), v === null))
          if (u) Ac(p, !1);
          else {
            if (On !== 0 || (n !== null && (n.flags & 128) !== 0))
              for (n = i.child; n !== null; ) {
                if (((v = hh(n)), v !== null)) {
                  for (
                    i.flags |= 128,
                      Ac(p, !1),
                      n = v.updateQueue,
                      i.updateQueue = n,
                      _h(i, n),
                      i.subtreeFlags = 0,
                      n = o,
                      o = i.child;
                    o !== null;

                  )
                    fc(o, n), (o = o.sibling);
                  return At(Xn, (Xn.current & 1) | 2), i.child;
                }
                n = n.sibling;
              }
            p.tail !== null &&
              Ut() > yh &&
              ((i.flags |= 128), (u = !0), Ac(p, !1), (i.lanes = 4194304));
          }
        else {
          if (!u)
            if (((n = hh(v)), n !== null)) {
              if (
                ((i.flags |= 128),
                (u = !0),
                (n = n.updateQueue),
                (i.updateQueue = n),
                _h(i, n),
                Ac(p, !0),
                p.tail === null && p.tailMode === 'hidden' && !v.alternate && !Le)
              )
                return wn(i), null;
            } else
              2 * Ut() - p.renderingStartTime > yh &&
                o !== 536870912 &&
                ((i.flags |= 128), (u = !0), Ac(p, !1), (i.lanes = 4194304));
          p.isBackwards
            ? ((v.sibling = i.child), (i.child = v))
            : ((n = p.last), n !== null ? (n.sibling = v) : (i.child = v), (p.last = v));
        }
        return p.tail !== null
          ? ((i = p.tail),
            (p.rendering = i),
            (p.tail = i.sibling),
            (p.renderingStartTime = Ut()),
            (i.sibling = null),
            (n = Xn.current),
            At(Xn, u ? (n & 1) | 2 : n & 1),
            i)
          : (wn(i), null);
      case 22:
      case 23:
        return (
          mr(i),
          Sd(),
          (u = i.memoizedState !== null),
          n !== null
            ? (n.memoizedState !== null) !== u && (i.flags |= 8192)
            : u && (i.flags |= 8192),
          u
            ? (o & 536870912) !== 0 &&
              (i.flags & 128) === 0 &&
              (wn(i), i.subtreeFlags & 6 && (i.flags |= 8192))
            : wn(i),
          (o = i.updateQueue),
          o !== null && _h(i, o.retryQueue),
          (o = null),
          n !== null &&
            n.memoizedState !== null &&
            n.memoizedState.cachePool !== null &&
            (o = n.memoizedState.cachePool.pool),
          (u = null),
          i.memoizedState !== null &&
            i.memoizedState.cachePool !== null &&
            (u = i.memoizedState.cachePool.pool),
          u !== o && (i.flags |= 2048),
          n !== null && gt(io),
          null
        );
      case 24:
        return (
          (o = null),
          n !== null && (o = n.memoizedState.cache),
          i.memoizedState.cache !== o && (i.flags |= 2048),
          Ea(Zn),
          wn(i),
          null
        );
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(s(156, i.tag));
  }
  function HM(n, i) {
    switch ((ie(i), i.tag)) {
      case 1:
        return (n = i.flags), n & 65536 ? ((i.flags = (n & -65537) | 128), i) : null;
      case 3:
        return (
          Ea(Zn),
          fe(),
          (n = i.flags),
          (n & 65536) !== 0 && (n & 128) === 0 ? ((i.flags = (n & -65537) | 128), i) : null
        );
      case 26:
      case 27:
      case 5:
        return Ne(i), null;
      case 13:
        if ((mr(i), (n = i.memoizedState), n !== null && n.dehydrated !== null)) {
          if (i.alternate === null) throw Error(s(340));
          ns();
        }
        return (n = i.flags), n & 65536 ? ((i.flags = (n & -65537) | 128), i) : null;
      case 19:
        return gt(Xn), null;
      case 4:
        return fe(), null;
      case 10:
        return Ea(i.type), null;
      case 22:
      case 23:
        return (
          mr(i),
          Sd(),
          n !== null && gt(io),
          (n = i.flags),
          n & 65536 ? ((i.flags = (n & -65537) | 128), i) : null
        );
      case 24:
        return Ea(Zn), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Dv(n, i) {
    switch ((ie(i), i.tag)) {
      case 3:
        Ea(Zn), fe();
        break;
      case 26:
      case 27:
      case 5:
        Ne(i);
        break;
      case 4:
        fe();
        break;
      case 13:
        mr(i);
        break;
      case 19:
        gt(Xn);
        break;
      case 10:
        Ea(i.type);
        break;
      case 22:
      case 23:
        mr(i), Sd(), n !== null && gt(io);
        break;
      case 24:
        Ea(Zn);
    }
  }
  function Cc(n, i) {
    try {
      var o = i.updateQueue,
        u = o !== null ? o.lastEffect : null;
      if (u !== null) {
        var p = u.next;
        o = p;
        do {
          if ((o.tag & n) === n) {
            u = void 0;
            var v = o.create,
              C = o.inst;
            (u = v()), (C.destroy = u);
          }
          o = o.next;
        } while (o !== p);
      }
    } catch (B) {
      _n(i, i.return, B);
    }
  }
  function us(n, i, o) {
    try {
      var u = i.updateQueue,
        p = u !== null ? u.lastEffect : null;
      if (p !== null) {
        var v = p.next;
        u = v;
        do {
          if ((u.tag & n) === n) {
            var C = u.inst,
              B = C.destroy;
            if (B !== void 0) {
              (C.destroy = void 0), (p = i);
              var Y = o,
                mt = B;
              try {
                mt();
              } catch (Rt) {
                _n(p, Y, Rt);
              }
            }
          }
          u = u.next;
        } while (u !== v);
      }
    } catch (Rt) {
      _n(i, i.return, Rt);
    }
  }
  function Ov(n) {
    var i = n.updateQueue;
    if (i !== null) {
      var o = n.stateNode;
      try {
        xg(i, o);
      } catch (u) {
        _n(n, n.return, u);
      }
    }
  }
  function Uv(n, i, o) {
    (o.props = ro(n.type, n.memoizedProps)), (o.state = n.memoizedState);
    try {
      o.componentWillUnmount();
    } catch (u) {
      _n(n, i, u);
    }
  }
  function Rc(n, i) {
    try {
      var o = n.ref;
      if (o !== null) {
        switch (n.tag) {
          case 26:
          case 27:
          case 5:
            var u = n.stateNode;
            break;
          case 30:
            u = n.stateNode;
            break;
          default:
            u = n.stateNode;
        }
        typeof o == 'function' ? (n.refCleanup = o(u)) : (o.current = u);
      }
    } catch (p) {
      _n(n, i, p);
    }
  }
  function Ha(n, i) {
    var o = n.ref,
      u = n.refCleanup;
    if (o !== null)
      if (typeof u == 'function')
        try {
          u();
        } catch (p) {
          _n(n, i, p);
        } finally {
          (n.refCleanup = null), (n = n.alternate), n != null && (n.refCleanup = null);
        }
      else if (typeof o == 'function')
        try {
          o(null);
        } catch (p) {
          _n(n, i, p);
        }
      else o.current = null;
  }
  function Nv(n) {
    var i = n.type,
      o = n.memoizedProps,
      u = n.stateNode;
    try {
      t: switch (i) {
        case 'button':
        case 'input':
        case 'select':
        case 'textarea':
          o.autoFocus && u.focus();
          break t;
        case 'img':
          o.src ? (u.src = o.src) : o.srcSet && (u.srcset = o.srcSet);
      }
    } catch (p) {
      _n(n, n.return, p);
    }
  }
  function Yd(n, i, o) {
    try {
      var u = n.stateNode;
      lb(u, n.type, o, i), (u[Wn] = i);
    } catch (p) {
      _n(n, n.return, p);
    }
  }
  function zv(n) {
    return (
      n.tag === 5 || n.tag === 3 || n.tag === 26 || (n.tag === 27 && vs(n.type)) || n.tag === 4
    );
  }
  function Kd(n) {
    t: for (;;) {
      for (; n.sibling === null; ) {
        if (n.return === null || zv(n.return)) return null;
        n = n.return;
      }
      for (
        n.sibling.return = n.return, n = n.sibling;
        n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

      ) {
        if ((n.tag === 27 && vs(n.type)) || n.flags & 2 || n.child === null || n.tag === 4)
          continue t;
        (n.child.return = n), (n = n.child);
      }
      if (!(n.flags & 2)) return n.stateNode;
    }
  }
  function Qd(n, i, o) {
    var u = n.tag;
    if (u === 5 || u === 6)
      (n = n.stateNode),
        i
          ? (o.nodeType === 9
              ? o.body
              : o.nodeName === 'HTML'
                ? o.ownerDocument.body
                : o
            ).insertBefore(n, i)
          : ((i = o.nodeType === 9 ? o.body : o.nodeName === 'HTML' ? o.ownerDocument.body : o),
            i.appendChild(n),
            (o = o._reactRootContainer),
            o != null || i.onclick !== null || (i.onclick = Ch));
    else if (
      u !== 4 &&
      (u === 27 && vs(n.type) && ((o = n.stateNode), (i = null)), (n = n.child), n !== null)
    )
      for (Qd(n, i, o), n = n.sibling; n !== null; ) Qd(n, i, o), (n = n.sibling);
  }
  function gh(n, i, o) {
    var u = n.tag;
    if (u === 5 || u === 6) (n = n.stateNode), i ? o.insertBefore(n, i) : o.appendChild(n);
    else if (u !== 4 && (u === 27 && vs(n.type) && (o = n.stateNode), (n = n.child), n !== null))
      for (gh(n, i, o), n = n.sibling; n !== null; ) gh(n, i, o), (n = n.sibling);
  }
  function Iv(n) {
    var i = n.stateNode,
      o = n.memoizedProps;
    try {
      for (var u = n.type, p = i.attributes; p.length; ) i.removeAttributeNode(p[0]);
      oi(i, u, o), (i[Nn] = n), (i[Wn] = o);
    } catch (v) {
      _n(n, n.return, v);
    }
  }
  var vr = !1,
    Bn = !1,
    Jd = !1,
    Bv = typeof WeakSet == 'function' ? WeakSet : Set,
    ti = null;
  function GM(n, i) {
    if (((n = n.containerInfo), (Mp = Nh), (n = Xs(n)), js(n))) {
      if ('selectionStart' in n) var o = { start: n.selectionStart, end: n.selectionEnd };
      else
        t: {
          o = ((o = n.ownerDocument) && o.defaultView) || window;
          var u = o.getSelection && o.getSelection();
          if (u && u.rangeCount !== 0) {
            o = u.anchorNode;
            var p = u.anchorOffset,
              v = u.focusNode;
            u = u.focusOffset;
            try {
              o.nodeType, v.nodeType;
            } catch {
              o = null;
              break t;
            }
            var C = 0,
              B = -1,
              Y = -1,
              mt = 0,
              Rt = 0,
              Nt = n,
              vt = null;
            e: for (;;) {
              for (
                var xt;
                Nt !== o || (p !== 0 && Nt.nodeType !== 3) || (B = C + p),
                  Nt !== v || (u !== 0 && Nt.nodeType !== 3) || (Y = C + u),
                  Nt.nodeType === 3 && (C += Nt.nodeValue.length),
                  (xt = Nt.firstChild) !== null;

              )
                (vt = Nt), (Nt = xt);
              for (;;) {
                if (Nt === n) break e;
                if (
                  (vt === o && ++mt === p && (B = C),
                  vt === v && ++Rt === u && (Y = C),
                  (xt = Nt.nextSibling) !== null)
                )
                  break;
                (Nt = vt), (vt = Nt.parentNode);
              }
              Nt = xt;
            }
            o = B === -1 || Y === -1 ? null : { start: B, end: Y };
          } else o = null;
        }
      o = o || { start: 0, end: 0 };
    } else o = null;
    for (bp = { focusedElem: n, selectionRange: o }, Nh = !1, ti = i; ti !== null; )
      if (((i = ti), (n = i.child), (i.subtreeFlags & 1024) !== 0 && n !== null))
        (n.return = i), (ti = n);
      else
        for (; ti !== null; ) {
          switch (((i = ti), (v = i.alternate), (n = i.flags), i.tag)) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((n & 1024) !== 0 && v !== null) {
                (n = void 0),
                  (o = i),
                  (p = v.memoizedProps),
                  (v = v.memoizedState),
                  (u = o.stateNode);
                try {
                  var Ce = ro(o.type, p, o.elementType === o.type);
                  (n = u.getSnapshotBeforeUpdate(Ce, v)),
                    (u.__reactInternalSnapshotBeforeUpdate = n);
                } catch (we) {
                  _n(o, o.return, we);
                }
              }
              break;
            case 3:
              if ((n & 1024) !== 0) {
                if (((n = i.stateNode.containerInfo), (o = n.nodeType), o === 9)) wp(n);
                else if (o === 1)
                  switch (n.nodeName) {
                    case 'HEAD':
                    case 'HTML':
                    case 'BODY':
                      wp(n);
                      break;
                    default:
                      n.textContent = '';
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((n & 1024) !== 0) throw Error(s(163));
          }
          if (((n = i.sibling), n !== null)) {
            (n.return = i.return), (ti = n);
            break;
          }
          ti = i.return;
        }
  }
  function kv(n, i, o) {
    var u = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        hs(n, o), u & 4 && Cc(5, o);
        break;
      case 1:
        if ((hs(n, o), u & 4))
          if (((n = o.stateNode), i === null))
            try {
              n.componentDidMount();
            } catch (C) {
              _n(o, o.return, C);
            }
          else {
            var p = ro(o.type, i.memoizedProps);
            i = i.memoizedState;
            try {
              n.componentDidUpdate(p, i, n.__reactInternalSnapshotBeforeUpdate);
            } catch (C) {
              _n(o, o.return, C);
            }
          }
        u & 64 && Ov(o), u & 512 && Rc(o, o.return);
        break;
      case 3:
        if ((hs(n, o), u & 64 && ((n = o.updateQueue), n !== null))) {
          if (((i = null), o.child !== null))
            switch (o.child.tag) {
              case 27:
              case 5:
                i = o.child.stateNode;
                break;
              case 1:
                i = o.child.stateNode;
            }
          try {
            xg(n, i);
          } catch (C) {
            _n(o, o.return, C);
          }
        }
        break;
      case 27:
        i === null && u & 4 && Iv(o);
      case 26:
      case 5:
        hs(n, o), i === null && u & 4 && Nv(o), u & 512 && Rc(o, o.return);
        break;
      case 12:
        hs(n, o);
        break;
      case 13:
        hs(n, o),
          u & 4 && Gv(n, o),
          u & 64 &&
            ((n = o.memoizedState),
            n !== null && ((n = n.dehydrated), n !== null && ((o = QM.bind(null, o)), mb(n, o))));
        break;
      case 22:
        if (((u = o.memoizedState !== null || vr), !u)) {
          (i = (i !== null && i.memoizedState !== null) || Bn), (p = vr);
          var v = Bn;
          (vr = u),
            (Bn = i) && !v ? fs(n, o, (o.subtreeFlags & 8772) !== 0) : hs(n, o),
            (vr = p),
            (Bn = v);
        }
        break;
      case 30:
        break;
      default:
        hs(n, o);
    }
  }
  function Fv(n) {
    var i = n.alternate;
    i !== null && ((n.alternate = null), Fv(i)),
      (n.child = null),
      (n.deletions = null),
      (n.sibling = null),
      n.tag === 5 && ((i = n.stateNode), i !== null && ga(i)),
      (n.stateNode = null),
      (n.return = null),
      (n.dependencies = null),
      (n.memoizedProps = null),
      (n.memoizedState = null),
      (n.pendingProps = null),
      (n.stateNode = null),
      (n.updateQueue = null);
  }
  var Mn = null,
    Pi = !1;
  function yr(n, i, o) {
    for (o = o.child; o !== null; ) Hv(n, i, o), (o = o.sibling);
  }
  function Hv(n, i, o) {
    if (Xt && typeof Xt.onCommitFiberUnmount == 'function')
      try {
        Xt.onCommitFiberUnmount(Et, o);
      } catch {}
    switch (o.tag) {
      case 26:
        Bn || Ha(o, i),
          yr(n, i, o),
          o.memoizedState
            ? o.memoizedState.count--
            : o.stateNode && ((o = o.stateNode), o.parentNode.removeChild(o));
        break;
      case 27:
        Bn || Ha(o, i);
        var u = Mn,
          p = Pi;
        vs(o.type) && ((Mn = o.stateNode), (Pi = !1)),
          yr(n, i, o),
          Bc(o.stateNode),
          (Mn = u),
          (Pi = p);
        break;
      case 5:
        Bn || Ha(o, i);
      case 6:
        if (((u = Mn), (p = Pi), (Mn = null), yr(n, i, o), (Mn = u), (Pi = p), Mn !== null))
          if (Pi)
            try {
              (Mn.nodeType === 9
                ? Mn.body
                : Mn.nodeName === 'HTML'
                  ? Mn.ownerDocument.body
                  : Mn
              ).removeChild(o.stateNode);
            } catch (v) {
              _n(o, i, v);
            }
          else
            try {
              Mn.removeChild(o.stateNode);
            } catch (v) {
              _n(o, i, v);
            }
        break;
      case 18:
        Mn !== null &&
          (Pi
            ? ((n = Mn),
              R0(
                n.nodeType === 9 ? n.body : n.nodeName === 'HTML' ? n.ownerDocument.body : n,
                o.stateNode,
              ),
              Xc(n))
            : R0(Mn, o.stateNode));
        break;
      case 4:
        (u = Mn),
          (p = Pi),
          (Mn = o.stateNode.containerInfo),
          (Pi = !0),
          yr(n, i, o),
          (Mn = u),
          (Pi = p);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Bn || us(2, o, i), Bn || us(4, o, i), yr(n, i, o);
        break;
      case 1:
        Bn ||
          (Ha(o, i), (u = o.stateNode), typeof u.componentWillUnmount == 'function' && Uv(o, i, u)),
          yr(n, i, o);
        break;
      case 21:
        yr(n, i, o);
        break;
      case 22:
        (Bn = (u = Bn) || o.memoizedState !== null), yr(n, i, o), (Bn = u);
        break;
      default:
        yr(n, i, o);
    }
  }
  function Gv(n, i) {
    if (
      i.memoizedState === null &&
      ((n = i.alternate),
      n !== null && ((n = n.memoizedState), n !== null && ((n = n.dehydrated), n !== null)))
    )
      try {
        Xc(n);
      } catch (o) {
        _n(i, i.return, o);
      }
  }
  function VM(n) {
    switch (n.tag) {
      case 13:
      case 19:
        var i = n.stateNode;
        return i === null && (i = n.stateNode = new Bv()), i;
      case 22:
        return (
          (n = n.stateNode), (i = n._retryCache), i === null && (i = n._retryCache = new Bv()), i
        );
      default:
        throw Error(s(435, n.tag));
    }
  }
  function $d(n, i) {
    var o = VM(n);
    i.forEach(function (u) {
      var p = JM.bind(null, n, u);
      o.has(u) || (o.add(u), u.then(p, p));
    });
  }
  function Zi(n, i) {
    var o = i.deletions;
    if (o !== null)
      for (var u = 0; u < o.length; u++) {
        var p = o[u],
          v = n,
          C = i,
          B = C;
        t: for (; B !== null; ) {
          switch (B.tag) {
            case 27:
              if (vs(B.type)) {
                (Mn = B.stateNode), (Pi = !1);
                break t;
              }
              break;
            case 5:
              (Mn = B.stateNode), (Pi = !1);
              break t;
            case 3:
            case 4:
              (Mn = B.stateNode.containerInfo), (Pi = !0);
              break t;
          }
          B = B.return;
        }
        if (Mn === null) throw Error(s(160));
        Hv(v, C, p),
          (Mn = null),
          (Pi = !1),
          (v = p.alternate),
          v !== null && (v.return = null),
          (p.return = null);
      }
    if (i.subtreeFlags & 13878) for (i = i.child; i !== null; ) Vv(i, n), (i = i.sibling);
  }
  var Ta = null;
  function Vv(n, i) {
    var o = n.alternate,
      u = n.flags;
    switch (n.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Zi(i, n), Xi(n), u & 4 && (us(3, n, n.return), Cc(3, n), us(5, n, n.return));
        break;
      case 1:
        Zi(i, n),
          Xi(n),
          u & 512 && (Bn || o === null || Ha(o, o.return)),
          u & 64 &&
            vr &&
            ((n = n.updateQueue),
            n !== null &&
              ((u = n.callbacks),
              u !== null &&
                ((o = n.shared.hiddenCallbacks),
                (n.shared.hiddenCallbacks = o === null ? u : o.concat(u)))));
        break;
      case 26:
        var p = Ta;
        if ((Zi(i, n), Xi(n), u & 512 && (Bn || o === null || Ha(o, o.return)), u & 4)) {
          var v = o !== null ? o.memoizedState : null;
          if (((u = n.memoizedState), o === null))
            if (u === null)
              if (n.stateNode === null) {
                t: {
                  (u = n.type), (o = n.memoizedProps), (p = p.ownerDocument || p);
                  e: switch (u) {
                    case 'title':
                      (v = p.getElementsByTagName('title')[0]),
                        (!v ||
                          v[_a] ||
                          v[Nn] ||
                          v.namespaceURI === 'http://www.w3.org/2000/svg' ||
                          v.hasAttribute('itemprop')) &&
                          ((v = p.createElement(u)),
                          p.head.insertBefore(v, p.querySelector('head > title'))),
                        oi(v, u, o),
                        (v[Nn] = n),
                        Ln(v),
                        (u = v);
                      break t;
                    case 'link':
                      var C = I0('link', 'href', p).get(u + (o.href || ''));
                      if (C) {
                        for (var B = 0; B < C.length; B++)
                          if (
                            ((v = C[B]),
                            v.getAttribute('href') ===
                              (o.href == null || o.href === '' ? null : o.href) &&
                              v.getAttribute('rel') === (o.rel == null ? null : o.rel) &&
                              v.getAttribute('title') === (o.title == null ? null : o.title) &&
                              v.getAttribute('crossorigin') ===
                                (o.crossOrigin == null ? null : o.crossOrigin))
                          ) {
                            C.splice(B, 1);
                            break e;
                          }
                      }
                      (v = p.createElement(u)), oi(v, u, o), p.head.appendChild(v);
                      break;
                    case 'meta':
                      if ((C = I0('meta', 'content', p).get(u + (o.content || '')))) {
                        for (B = 0; B < C.length; B++)
                          if (
                            ((v = C[B]),
                            v.getAttribute('content') ===
                              (o.content == null ? null : '' + o.content) &&
                              v.getAttribute('name') === (o.name == null ? null : o.name) &&
                              v.getAttribute('property') ===
                                (o.property == null ? null : o.property) &&
                              v.getAttribute('http-equiv') ===
                                (o.httpEquiv == null ? null : o.httpEquiv) &&
                              v.getAttribute('charset') === (o.charSet == null ? null : o.charSet))
                          ) {
                            C.splice(B, 1);
                            break e;
                          }
                      }
                      (v = p.createElement(u)), oi(v, u, o), p.head.appendChild(v);
                      break;
                    default:
                      throw Error(s(468, u));
                  }
                  (v[Nn] = n), Ln(v), (u = v);
                }
                n.stateNode = u;
              } else B0(p, n.type, n.stateNode);
            else n.stateNode = z0(p, u, n.memoizedProps);
          else
            v !== u
              ? (v === null
                  ? o.stateNode !== null && ((o = o.stateNode), o.parentNode.removeChild(o))
                  : v.count--,
                u === null ? B0(p, n.type, n.stateNode) : z0(p, u, n.memoizedProps))
              : u === null && n.stateNode !== null && Yd(n, n.memoizedProps, o.memoizedProps);
        }
        break;
      case 27:
        Zi(i, n),
          Xi(n),
          u & 512 && (Bn || o === null || Ha(o, o.return)),
          o !== null && u & 4 && Yd(n, n.memoizedProps, o.memoizedProps);
        break;
      case 5:
        if ((Zi(i, n), Xi(n), u & 512 && (Bn || o === null || Ha(o, o.return)), n.flags & 32)) {
          p = n.stateNode;
          try {
            hi(p, '');
          } catch (xt) {
            _n(n, n.return, xt);
          }
        }
        u & 4 &&
          n.stateNode != null &&
          ((p = n.memoizedProps), Yd(n, p, o !== null ? o.memoizedProps : p)),
          u & 1024 && (Jd = !0);
        break;
      case 6:
        if ((Zi(i, n), Xi(n), u & 4)) {
          if (n.stateNode === null) throw Error(s(162));
          (u = n.memoizedProps), (o = n.stateNode);
          try {
            o.nodeValue = u;
          } catch (xt) {
            _n(n, n.return, xt);
          }
        }
        break;
      case 3:
        if (
          ((Dh = null),
          (p = Ta),
          (Ta = Lh(i.containerInfo)),
          Zi(i, n),
          (Ta = p),
          Xi(n),
          u & 4 && o !== null && o.memoizedState.isDehydrated)
        )
          try {
            Xc(i.containerInfo);
          } catch (xt) {
            _n(n, n.return, xt);
          }
        Jd && ((Jd = !1), Wv(n));
        break;
      case 4:
        (u = Ta), (Ta = Lh(n.stateNode.containerInfo)), Zi(i, n), Xi(n), (Ta = u);
        break;
      case 12:
        Zi(i, n), Xi(n);
        break;
      case 13:
        Zi(i, n),
          Xi(n),
          n.child.flags & 8192 &&
            (n.memoizedState !== null) != (o !== null && o.memoizedState !== null) &&
            (rp = Ut()),
          u & 4 && ((u = n.updateQueue), u !== null && ((n.updateQueue = null), $d(n, u)));
        break;
      case 22:
        p = n.memoizedState !== null;
        var Y = o !== null && o.memoizedState !== null,
          mt = vr,
          Rt = Bn;
        if (((vr = mt || p), (Bn = Rt || Y), Zi(i, n), (Bn = Rt), (vr = mt), Xi(n), u & 8192))
          t: for (
            i = n.stateNode,
              i._visibility = p ? i._visibility & -2 : i._visibility | 1,
              p && (o === null || Y || vr || Bn || so(n)),
              o = null,
              i = n;
            ;

          ) {
            if (i.tag === 5 || i.tag === 26) {
              if (o === null) {
                Y = o = i;
                try {
                  if (((v = Y.stateNode), p))
                    (C = v.style),
                      typeof C.setProperty == 'function'
                        ? C.setProperty('display', 'none', 'important')
                        : (C.display = 'none');
                  else {
                    B = Y.stateNode;
                    var Nt = Y.memoizedProps.style,
                      vt = Nt != null && Nt.hasOwnProperty('display') ? Nt.display : null;
                    B.style.display = vt == null || typeof vt == 'boolean' ? '' : ('' + vt).trim();
                  }
                } catch (xt) {
                  _n(Y, Y.return, xt);
                }
              }
            } else if (i.tag === 6) {
              if (o === null) {
                Y = i;
                try {
                  Y.stateNode.nodeValue = p ? '' : Y.memoizedProps;
                } catch (xt) {
                  _n(Y, Y.return, xt);
                }
              }
            } else if (
              ((i.tag !== 22 && i.tag !== 23) || i.memoizedState === null || i === n) &&
              i.child !== null
            ) {
              (i.child.return = i), (i = i.child);
              continue;
            }
            if (i === n) break t;
            for (; i.sibling === null; ) {
              if (i.return === null || i.return === n) break t;
              o === i && (o = null), (i = i.return);
            }
            o === i && (o = null), (i.sibling.return = i.return), (i = i.sibling);
          }
        u & 4 &&
          ((u = n.updateQueue),
          u !== null && ((o = u.retryQueue), o !== null && ((u.retryQueue = null), $d(n, o))));
        break;
      case 19:
        Zi(i, n),
          Xi(n),
          u & 4 && ((u = n.updateQueue), u !== null && ((n.updateQueue = null), $d(n, u)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Zi(i, n), Xi(n);
    }
  }
  function Xi(n) {
    var i = n.flags;
    if (i & 2) {
      try {
        for (var o, u = n.return; u !== null; ) {
          if (zv(u)) {
            o = u;
            break;
          }
          u = u.return;
        }
        if (o == null) throw Error(s(160));
        switch (o.tag) {
          case 27:
            var p = o.stateNode,
              v = Kd(n);
            gh(n, v, p);
            break;
          case 5:
            var C = o.stateNode;
            o.flags & 32 && (hi(C, ''), (o.flags &= -33));
            var B = Kd(n);
            gh(n, B, C);
            break;
          case 3:
          case 4:
            var Y = o.stateNode.containerInfo,
              mt = Kd(n);
            Qd(n, mt, Y);
            break;
          default:
            throw Error(s(161));
        }
      } catch (Rt) {
        _n(n, n.return, Rt);
      }
      n.flags &= -3;
    }
    i & 4096 && (n.flags &= -4097);
  }
  function Wv(n) {
    if (n.subtreeFlags & 1024)
      for (n = n.child; n !== null; ) {
        var i = n;
        Wv(i), i.tag === 5 && i.flags & 1024 && i.stateNode.reset(), (n = n.sibling);
      }
  }
  function hs(n, i) {
    if (i.subtreeFlags & 8772)
      for (i = i.child; i !== null; ) kv(n, i.alternate, i), (i = i.sibling);
  }
  function so(n) {
    for (n = n.child; n !== null; ) {
      var i = n;
      switch (i.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          us(4, i, i.return), so(i);
          break;
        case 1:
          Ha(i, i.return);
          var o = i.stateNode;
          typeof o.componentWillUnmount == 'function' && Uv(i, i.return, o), so(i);
          break;
        case 27:
          Bc(i.stateNode);
        case 26:
        case 5:
          Ha(i, i.return), so(i);
          break;
        case 22:
          i.memoizedState === null && so(i);
          break;
        case 30:
          so(i);
          break;
        default:
          so(i);
      }
      n = n.sibling;
    }
  }
  function fs(n, i, o) {
    for (o = o && (i.subtreeFlags & 8772) !== 0, i = i.child; i !== null; ) {
      var u = i.alternate,
        p = n,
        v = i,
        C = v.flags;
      switch (v.tag) {
        case 0:
        case 11:
        case 15:
          fs(p, v, o), Cc(4, v);
          break;
        case 1:
          if ((fs(p, v, o), (u = v), (p = u.stateNode), typeof p.componentDidMount == 'function'))
            try {
              p.componentDidMount();
            } catch (mt) {
              _n(u, u.return, mt);
            }
          if (((u = v), (p = u.updateQueue), p !== null)) {
            var B = u.stateNode;
            try {
              var Y = p.shared.hiddenCallbacks;
              if (Y !== null)
                for (p.shared.hiddenCallbacks = null, p = 0; p < Y.length; p++) yg(Y[p], B);
            } catch (mt) {
              _n(u, u.return, mt);
            }
          }
          o && C & 64 && Ov(v), Rc(v, v.return);
          break;
        case 27:
          Iv(v);
        case 26:
        case 5:
          fs(p, v, o), o && u === null && C & 4 && Nv(v), Rc(v, v.return);
          break;
        case 12:
          fs(p, v, o);
          break;
        case 13:
          fs(p, v, o), o && C & 4 && Gv(p, v);
          break;
        case 22:
          v.memoizedState === null && fs(p, v, o), Rc(v, v.return);
          break;
        case 30:
          break;
        default:
          fs(p, v, o);
      }
      i = i.sibling;
    }
  }
  function tp(n, i) {
    var o = null;
    n !== null &&
      n.memoizedState !== null &&
      n.memoizedState.cachePool !== null &&
      (o = n.memoizedState.cachePool.pool),
      (n = null),
      i.memoizedState !== null &&
        i.memoizedState.cachePool !== null &&
        (n = i.memoizedState.cachePool.pool),
      n !== o && (n != null && n.refCount++, o != null && pc(o));
  }
  function ep(n, i) {
    (n = null),
      i.alternate !== null && (n = i.alternate.memoizedState.cache),
      (i = i.memoizedState.cache),
      i !== n && (i.refCount++, n != null && pc(n));
  }
  function Ga(n, i, o, u) {
    if (i.subtreeFlags & 10256) for (i = i.child; i !== null; ) Zv(n, i, o, u), (i = i.sibling);
  }
  function Zv(n, i, o, u) {
    var p = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        Ga(n, i, o, u), p & 2048 && Cc(9, i);
        break;
      case 1:
        Ga(n, i, o, u);
        break;
      case 3:
        Ga(n, i, o, u),
          p & 2048 &&
            ((n = null),
            i.alternate !== null && (n = i.alternate.memoizedState.cache),
            (i = i.memoizedState.cache),
            i !== n && (i.refCount++, n != null && pc(n)));
        break;
      case 12:
        if (p & 2048) {
          Ga(n, i, o, u), (n = i.stateNode);
          try {
            var v = i.memoizedProps,
              C = v.id,
              B = v.onPostCommit;
            typeof B == 'function' &&
              B(C, i.alternate === null ? 'mount' : 'update', n.passiveEffectDuration, -0);
          } catch (Y) {
            _n(i, i.return, Y);
          }
        } else Ga(n, i, o, u);
        break;
      case 13:
        Ga(n, i, o, u);
        break;
      case 23:
        break;
      case 22:
        (v = i.stateNode),
          (C = i.alternate),
          i.memoizedState !== null
            ? v._visibility & 2
              ? Ga(n, i, o, u)
              : Lc(n, i)
            : v._visibility & 2
              ? Ga(n, i, o, u)
              : ((v._visibility |= 2), el(n, i, o, u, (i.subtreeFlags & 10256) !== 0)),
          p & 2048 && tp(C, i);
        break;
      case 24:
        Ga(n, i, o, u), p & 2048 && ep(i.alternate, i);
        break;
      default:
        Ga(n, i, o, u);
    }
  }
  function el(n, i, o, u, p) {
    for (p = p && (i.subtreeFlags & 10256) !== 0, i = i.child; i !== null; ) {
      var v = n,
        C = i,
        B = o,
        Y = u,
        mt = C.flags;
      switch (C.tag) {
        case 0:
        case 11:
        case 15:
          el(v, C, B, Y, p), Cc(8, C);
          break;
        case 23:
          break;
        case 22:
          var Rt = C.stateNode;
          C.memoizedState !== null
            ? Rt._visibility & 2
              ? el(v, C, B, Y, p)
              : Lc(v, C)
            : ((Rt._visibility |= 2), el(v, C, B, Y, p)),
            p && mt & 2048 && tp(C.alternate, C);
          break;
        case 24:
          el(v, C, B, Y, p), p && mt & 2048 && ep(C.alternate, C);
          break;
        default:
          el(v, C, B, Y, p);
      }
      i = i.sibling;
    }
  }
  function Lc(n, i) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; ) {
        var o = n,
          u = i,
          p = u.flags;
        switch (u.tag) {
          case 22:
            Lc(o, u), p & 2048 && tp(u.alternate, u);
            break;
          case 24:
            Lc(o, u), p & 2048 && ep(u.alternate, u);
            break;
          default:
            Lc(o, u);
        }
        i = i.sibling;
      }
  }
  var Pc = 8192;
  function nl(n) {
    if (n.subtreeFlags & Pc) for (n = n.child; n !== null; ) Xv(n), (n = n.sibling);
  }
  function Xv(n) {
    switch (n.tag) {
      case 26:
        nl(n), n.flags & Pc && n.memoizedState !== null && Cb(Ta, n.memoizedState, n.memoizedProps);
        break;
      case 5:
        nl(n);
        break;
      case 3:
      case 4:
        var i = Ta;
        (Ta = Lh(n.stateNode.containerInfo)), nl(n), (Ta = i);
        break;
      case 22:
        n.memoizedState === null &&
          ((i = n.alternate),
          i !== null && i.memoizedState !== null
            ? ((i = Pc), (Pc = 16777216), nl(n), (Pc = i))
            : nl(n));
        break;
      default:
        nl(n);
    }
  }
  function jv(n) {
    var i = n.alternate;
    if (i !== null && ((n = i.child), n !== null)) {
      i.child = null;
      do (i = n.sibling), (n.sibling = null), (n = i);
      while (n !== null);
    }
  }
  function Dc(n) {
    var i = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (i !== null)
        for (var o = 0; o < i.length; o++) {
          var u = i[o];
          (ti = u), Yv(u, n);
        }
      jv(n);
    }
    if (n.subtreeFlags & 10256) for (n = n.child; n !== null; ) qv(n), (n = n.sibling);
  }
  function qv(n) {
    switch (n.tag) {
      case 0:
      case 11:
      case 15:
        Dc(n), n.flags & 2048 && us(9, n, n.return);
        break;
      case 3:
        Dc(n);
        break;
      case 12:
        Dc(n);
        break;
      case 22:
        var i = n.stateNode;
        n.memoizedState !== null && i._visibility & 2 && (n.return === null || n.return.tag !== 13)
          ? ((i._visibility &= -3), vh(n))
          : Dc(n);
        break;
      default:
        Dc(n);
    }
  }
  function vh(n) {
    var i = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (i !== null)
        for (var o = 0; o < i.length; o++) {
          var u = i[o];
          (ti = u), Yv(u, n);
        }
      jv(n);
    }
    for (n = n.child; n !== null; ) {
      switch (((i = n), i.tag)) {
        case 0:
        case 11:
        case 15:
          us(8, i, i.return), vh(i);
          break;
        case 22:
          (o = i.stateNode), o._visibility & 2 && ((o._visibility &= -3), vh(i));
          break;
        default:
          vh(i);
      }
      n = n.sibling;
    }
  }
  function Yv(n, i) {
    for (; ti !== null; ) {
      var o = ti;
      switch (o.tag) {
        case 0:
        case 11:
        case 15:
          us(8, o, i);
          break;
        case 23:
        case 22:
          if (o.memoizedState !== null && o.memoizedState.cachePool !== null) {
            var u = o.memoizedState.cachePool.pool;
            u != null && u.refCount++;
          }
          break;
        case 24:
          pc(o.memoizedState.cache);
      }
      if (((u = o.child), u !== null)) (u.return = o), (ti = u);
      else
        t: for (o = n; ti !== null; ) {
          u = ti;
          var p = u.sibling,
            v = u.return;
          if ((Fv(u), u === o)) {
            ti = null;
            break t;
          }
          if (p !== null) {
            (p.return = v), (ti = p);
            break t;
          }
          ti = v;
        }
    }
  }
  var WM = {
      getCacheForType: function (n) {
        var i = di(Zn),
          o = i.data.get(n);
        return o === void 0 && ((o = n()), i.data.set(n, o)), o;
      },
    },
    ZM = typeof WeakMap == 'function' ? WeakMap : Map,
    on = 0,
    yn = null,
    je = null,
    Ke = 0,
    ln = 0,
    ji = null,
    ds = !1,
    il = !1,
    np = !1,
    xr = 0,
    On = 0,
    ps = 0,
    oo = 0,
    ip = 0,
    ca = 0,
    al = 0,
    Oc = null,
    Di = null,
    ap = !1,
    rp = 0,
    yh = 1 / 0,
    xh = null,
    ms = null,
    si = 0,
    _s = null,
    rl = null,
    sl = 0,
    sp = 0,
    op = null,
    Kv = null,
    Uc = 0,
    lp = null;
  function qi() {
    if ((on & 2) !== 0 && Ke !== 0) return Ke & -Ke;
    if (X.T !== null) {
      var n = jo;
      return n !== 0 ? n : mp();
    }
    return Ye();
  }
  function Qv() {
    ca === 0 && (ca = (Ke & 536870912) === 0 || Le ? nt() : 536870912);
    var n = la.current;
    return n !== null && (n.flags |= 32), ca;
  }
  function Yi(n, i, o) {
    ((n === yn && (ln === 2 || ln === 9)) || n.cancelPendingCommit !== null) &&
      (ol(n, 0), gs(n, Ke, ca, !1)),
      Ot(n, o),
      ((on & 2) === 0 || n !== yn) &&
        (n === yn && ((on & 2) === 0 && (oo |= o), On === 4 && gs(n, Ke, ca, !1)), Va(n));
  }
  function Jv(n, i, o) {
    if ((on & 6) !== 0) throw Error(s(327));
    var u = (!o && (i & 124) === 0 && (i & n.expiredLanes) === 0) || Me(n, i),
      p = u ? qM(n, i) : hp(n, i, !0),
      v = u;
    do {
      if (p === 0) {
        il && !u && gs(n, i, 0, !1);
        break;
      } else {
        if (((o = n.current.alternate), v && !XM(o))) {
          (p = hp(n, i, !1)), (v = !1);
          continue;
        }
        if (p === 2) {
          if (((v = i), n.errorRecoveryDisabledLanes & v)) var C = 0;
          else (C = n.pendingLanes & -536870913), (C = C !== 0 ? C : C & 536870912 ? 536870912 : 0);
          if (C !== 0) {
            i = C;
            t: {
              var B = n;
              p = Oc;
              var Y = B.current.memoizedState.isDehydrated;
              if ((Y && (ol(B, C).flags |= 256), (C = hp(B, C, !1)), C !== 2)) {
                if (np && !Y) {
                  (B.errorRecoveryDisabledLanes |= v), (oo |= v), (p = 4);
                  break t;
                }
                (v = Di), (Di = p), v !== null && (Di === null ? (Di = v) : Di.push.apply(Di, v));
              }
              p = C;
            }
            if (((v = !1), p !== 2)) continue;
          }
        }
        if (p === 1) {
          ol(n, 0), gs(n, i, 0, !0);
          break;
        }
        t: {
          switch (((u = n), (v = p), v)) {
            case 0:
            case 1:
              throw Error(s(345));
            case 4:
              if ((i & 4194048) !== i) break;
            case 6:
              gs(u, i, ca, !ds);
              break t;
            case 2:
              Di = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(s(329));
          }
          if ((i & 62914560) === i && ((p = rp + 300 - Ut()), 10 < p)) {
            if ((gs(u, i, ca, !ds), Oe(u, 0, !0) !== 0)) break t;
            u.timeoutHandle = A0(
              $v.bind(null, u, o, Di, xh, ap, i, ca, oo, al, ds, v, 2, -0, 0),
              p,
            );
            break t;
          }
          $v(u, o, Di, xh, ap, i, ca, oo, al, ds, v, 0, -0, 0);
        }
      }
      break;
    } while (!0);
    Va(n);
  }
  function $v(n, i, o, u, p, v, C, B, Y, mt, Rt, Nt, vt, xt) {
    if (
      ((n.timeoutHandle = -1),
      (Nt = i.subtreeFlags),
      (Nt & 8192 || (Nt & 16785408) === 16785408) &&
        ((Hc = { stylesheets: null, count: 0, unsuspend: Ab }), Xv(i), (Nt = Rb()), Nt !== null))
    ) {
      (n.cancelPendingCommit = Nt(s0.bind(null, n, i, v, o, u, p, C, B, Y, Rt, 1, vt, xt))),
        gs(n, v, C, !mt);
      return;
    }
    s0(n, i, v, o, u, p, C, B, Y);
  }
  function XM(n) {
    for (var i = n; ; ) {
      var o = i.tag;
      if (
        (o === 0 || o === 11 || o === 15) &&
        i.flags & 16384 &&
        ((o = i.updateQueue), o !== null && ((o = o.stores), o !== null))
      )
        for (var u = 0; u < o.length; u++) {
          var p = o[u],
            v = p.getSnapshot;
          p = p.value;
          try {
            if (!Si(v(), p)) return !1;
          } catch {
            return !1;
          }
        }
      if (((o = i.child), i.subtreeFlags & 16384 && o !== null)) (o.return = i), (i = o);
      else {
        if (i === n) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === n) return !0;
          i = i.return;
        }
        (i.sibling.return = i.return), (i = i.sibling);
      }
    }
    return !0;
  }
  function gs(n, i, o, u) {
    (i &= ~ip),
      (i &= ~oo),
      (n.suspendedLanes |= i),
      (n.pingedLanes &= ~i),
      u && (n.warmLanes |= i),
      (u = n.expirationTimes);
    for (var p = i; 0 < p; ) {
      var v = 31 - $t(p),
        C = 1 << v;
      (u[v] = -1), (p &= ~C);
    }
    o !== 0 && te(n, o, i);
  }
  function Sh() {
    return (on & 6) === 0 ? (Nc(0), !1) : !0;
  }
  function cp() {
    if (je !== null) {
      if (ln === 0) var n = je.return;
      else (n = je), (ba = oa = null), wd(n), ($o = null), (Tc = 0), (n = je);
      for (; n !== null; ) Dv(n.alternate, n), (n = n.return);
      je = null;
    }
  }
  function ol(n, i) {
    var o = n.timeoutHandle;
    o !== -1 && ((n.timeoutHandle = -1), ub(o)),
      (o = n.cancelPendingCommit),
      o !== null && ((n.cancelPendingCommit = null), o()),
      cp(),
      (yn = n),
      (je = o = sa(n.current, null)),
      (Ke = i),
      (ln = 0),
      (ji = null),
      (ds = !1),
      (il = Me(n, i)),
      (np = !1),
      (al = ca = ip = oo = ps = On = 0),
      (Di = Oc = null),
      (ap = !1),
      (i & 8) !== 0 && (i |= i & 32);
    var u = n.entangledLanes;
    if (u !== 0)
      for (n = n.entanglements, u &= i; 0 < u; ) {
        var p = 31 - $t(u),
          v = 1 << p;
        (i |= n[p]), (u &= ~v);
      }
    return (xr = i), Ys(), o;
  }
  function t0(n, i) {
    (Ge = null),
      (X.H = lh),
      i === _c || i === Ju
        ? ((i = gg()), (ln = 3))
        : i === pg
          ? ((i = gg()), (ln = 4))
          : (ln =
              i === vv
                ? 8
                : i !== null && typeof i == 'object' && typeof i.then == 'function'
                  ? 6
                  : 1),
      (ji = i),
      je === null && ((On = 1), dh(n, bi(i, n.current)));
  }
  function e0() {
    var n = X.H;
    return (X.H = lh), n === null ? lh : n;
  }
  function n0() {
    var n = X.A;
    return (X.A = WM), n;
  }
  function up() {
    (On = 4),
      ds || ((Ke & 4194048) !== Ke && la.current !== null) || (il = !0),
      ((ps & 134217727) === 0 && (oo & 134217727) === 0) || yn === null || gs(yn, Ke, ca, !1);
  }
  function hp(n, i, o) {
    var u = on;
    on |= 2;
    var p = e0(),
      v = n0();
    (yn !== n || Ke !== i) && ((xh = null), ol(n, i)), (i = !1);
    var C = On;
    t: do
      try {
        if (ln !== 0 && je !== null) {
          var B = je,
            Y = ji;
          switch (ln) {
            case 8:
              cp(), (C = 6);
              break t;
            case 3:
            case 2:
            case 9:
            case 6:
              la.current === null && (i = !0);
              var mt = ln;
              if (((ln = 0), (ji = null), ll(n, B, Y, mt), o && il)) {
                C = 0;
                break t;
              }
              break;
            default:
              (mt = ln), (ln = 0), (ji = null), ll(n, B, Y, mt);
          }
        }
        jM(), (C = On);
        break;
      } catch (Rt) {
        t0(n, Rt);
      }
    while (!0);
    return (
      i && n.shellSuspendCounter++,
      (ba = oa = null),
      (on = u),
      (X.H = p),
      (X.A = v),
      je === null && ((yn = null), (Ke = 0), Ys()),
      C
    );
  }
  function jM() {
    for (; je !== null; ) i0(je);
  }
  function qM(n, i) {
    var o = on;
    on |= 2;
    var u = e0(),
      p = n0();
    yn !== n || Ke !== i ? ((xh = null), (yh = Ut() + 500), ol(n, i)) : (il = Me(n, i));
    t: do
      try {
        if (ln !== 0 && je !== null) {
          i = je;
          var v = ji;
          e: switch (ln) {
            case 1:
              (ln = 0), (ji = null), ll(n, i, v, 1);
              break;
            case 2:
            case 9:
              if (mg(v)) {
                (ln = 0), (ji = null), a0(i);
                break;
              }
              (i = function () {
                (ln !== 2 && ln !== 9) || yn !== n || (ln = 7), Va(n);
              }),
                v.then(i, i);
              break t;
            case 3:
              ln = 7;
              break t;
            case 4:
              ln = 5;
              break t;
            case 7:
              mg(v) ? ((ln = 0), (ji = null), a0(i)) : ((ln = 0), (ji = null), ll(n, i, v, 7));
              break;
            case 5:
              var C = null;
              switch (je.tag) {
                case 26:
                  C = je.memoizedState;
                case 5:
                case 27:
                  var B = je;
                  if (!C || k0(C)) {
                    (ln = 0), (ji = null);
                    var Y = B.sibling;
                    if (Y !== null) je = Y;
                    else {
                      var mt = B.return;
                      mt !== null ? ((je = mt), Mh(mt)) : (je = null);
                    }
                    break e;
                  }
              }
              (ln = 0), (ji = null), ll(n, i, v, 5);
              break;
            case 6:
              (ln = 0), (ji = null), ll(n, i, v, 6);
              break;
            case 8:
              cp(), (On = 6);
              break t;
            default:
              throw Error(s(462));
          }
        }
        YM();
        break;
      } catch (Rt) {
        t0(n, Rt);
      }
    while (!0);
    return (
      (ba = oa = null),
      (X.H = u),
      (X.A = p),
      (on = o),
      je !== null ? 0 : ((yn = null), (Ke = 0), Ys(), On)
    );
  }
  function YM() {
    for (; je !== null && !Zt(); ) i0(je);
  }
  function i0(n) {
    var i = Lv(n.alternate, n, xr);
    (n.memoizedProps = n.pendingProps), i === null ? Mh(n) : (je = i);
  }
  function a0(n) {
    var i = n,
      o = i.alternate;
    switch (i.tag) {
      case 15:
      case 0:
        i = Ev(o, i, i.pendingProps, i.type, void 0, Ke);
        break;
      case 11:
        i = Ev(o, i, i.pendingProps, i.type.render, i.ref, Ke);
        break;
      case 5:
        wd(i);
      default:
        Dv(o, i), (i = je = fc(i, xr)), (i = Lv(o, i, xr));
    }
    (n.memoizedProps = n.pendingProps), i === null ? Mh(n) : (je = i);
  }
  function ll(n, i, o, u) {
    (ba = oa = null), wd(i), ($o = null), (Tc = 0);
    var p = i.return;
    try {
      if (BM(n, p, i, o, Ke)) {
        (On = 1), dh(n, bi(o, n.current)), (je = null);
        return;
      }
    } catch (v) {
      if (p !== null) throw ((je = p), v);
      (On = 1), dh(n, bi(o, n.current)), (je = null);
      return;
    }
    i.flags & 32768
      ? (Le || u === 1
          ? (n = !0)
          : il || (Ke & 536870912) !== 0
            ? (n = !1)
            : ((ds = n = !0),
              (u === 2 || u === 9 || u === 3 || u === 6) &&
                ((u = la.current), u !== null && u.tag === 13 && (u.flags |= 16384))),
        r0(i, n))
      : Mh(i);
  }
  function Mh(n) {
    var i = n;
    do {
      if ((i.flags & 32768) !== 0) {
        r0(i, ds);
        return;
      }
      n = i.return;
      var o = FM(i.alternate, i, xr);
      if (o !== null) {
        je = o;
        return;
      }
      if (((i = i.sibling), i !== null)) {
        je = i;
        return;
      }
      je = i = n;
    } while (i !== null);
    On === 0 && (On = 5);
  }
  function r0(n, i) {
    do {
      var o = HM(n.alternate, n);
      if (o !== null) {
        (o.flags &= 32767), (je = o);
        return;
      }
      if (
        ((o = n.return),
        o !== null && ((o.flags |= 32768), (o.subtreeFlags = 0), (o.deletions = null)),
        !i && ((n = n.sibling), n !== null))
      ) {
        je = n;
        return;
      }
      je = n = o;
    } while (n !== null);
    (On = 6), (je = null);
  }
  function s0(n, i, o, u, p, v, C, B, Y) {
    n.cancelPendingCommit = null;
    do bh();
    while (si !== 0);
    if ((on & 6) !== 0) throw Error(s(327));
    if (i !== null) {
      if (i === n.current) throw Error(s(177));
      if (
        ((v = i.lanes | i.childLanes),
        (v |= Wi),
        ae(n, o, v, C, B, Y),
        n === yn && ((je = yn = null), (Ke = 0)),
        (rl = i),
        (_s = n),
        (sl = o),
        (sp = v),
        (op = p),
        (Kv = u),
        (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0
          ? ((n.callbackNode = null),
            (n.callbackPriority = 0),
            $M(H, function () {
              return h0(), null;
            }))
          : ((n.callbackNode = null), (n.callbackPriority = 0)),
        (u = (i.flags & 13878) !== 0),
        (i.subtreeFlags & 13878) !== 0 || u)
      ) {
        (u = X.T), (X.T = null), (p = it.p), (it.p = 2), (C = on), (on |= 4);
        try {
          GM(n, i, o);
        } finally {
          (on = C), (it.p = p), (X.T = u);
        }
      }
      (si = 1), o0(), l0(), c0();
    }
  }
  function o0() {
    if (si === 1) {
      si = 0;
      var n = _s,
        i = rl,
        o = (i.flags & 13878) !== 0;
      if ((i.subtreeFlags & 13878) !== 0 || o) {
        (o = X.T), (X.T = null);
        var u = it.p;
        it.p = 2;
        var p = on;
        on |= 4;
        try {
          Vv(i, n);
          var v = bp,
            C = Xs(n.containerInfo),
            B = v.focusedElem,
            Y = v.selectionRange;
          if (C !== B && B && B.ownerDocument && ko(B.ownerDocument.documentElement, B)) {
            if (Y !== null && js(B)) {
              var mt = Y.start,
                Rt = Y.end;
              if ((Rt === void 0 && (Rt = mt), 'selectionStart' in B))
                (B.selectionStart = mt), (B.selectionEnd = Math.min(Rt, B.value.length));
              else {
                var Nt = B.ownerDocument || document,
                  vt = (Nt && Nt.defaultView) || window;
                if (vt.getSelection) {
                  var xt = vt.getSelection(),
                    Ce = B.textContent.length,
                    we = Math.min(Y.start, Ce),
                    fn = Y.end === void 0 ? we : Math.min(Y.end, Ce);
                  !xt.extend && we > fn && ((C = fn), (fn = we), (we = C));
                  var ct = uc(B, we),
                    $ = uc(B, fn);
                  if (
                    ct &&
                    $ &&
                    (xt.rangeCount !== 1 ||
                      xt.anchorNode !== ct.node ||
                      xt.anchorOffset !== ct.offset ||
                      xt.focusNode !== $.node ||
                      xt.focusOffset !== $.offset)
                  ) {
                    var dt = Nt.createRange();
                    dt.setStart(ct.node, ct.offset),
                      xt.removeAllRanges(),
                      we > fn
                        ? (xt.addRange(dt), xt.extend($.node, $.offset))
                        : (dt.setEnd($.node, $.offset), xt.addRange(dt));
                  }
                }
              }
            }
            for (Nt = [], xt = B; (xt = xt.parentNode); )
              xt.nodeType === 1 && Nt.push({ element: xt, left: xt.scrollLeft, top: xt.scrollTop });
            for (typeof B.focus == 'function' && B.focus(), B = 0; B < Nt.length; B++) {
              var Pt = Nt[B];
              (Pt.element.scrollLeft = Pt.left), (Pt.element.scrollTop = Pt.top);
            }
          }
          (Nh = !!Mp), (bp = Mp = null);
        } finally {
          (on = p), (it.p = u), (X.T = o);
        }
      }
      (n.current = i), (si = 2);
    }
  }
  function l0() {
    if (si === 2) {
      si = 0;
      var n = _s,
        i = rl,
        o = (i.flags & 8772) !== 0;
      if ((i.subtreeFlags & 8772) !== 0 || o) {
        (o = X.T), (X.T = null);
        var u = it.p;
        it.p = 2;
        var p = on;
        on |= 4;
        try {
          kv(n, i.alternate, i);
        } finally {
          (on = p), (it.p = u), (X.T = o);
        }
      }
      si = 3;
    }
  }
  function c0() {
    if (si === 4 || si === 3) {
      (si = 0), Bt();
      var n = _s,
        i = rl,
        o = sl,
        u = Kv;
      (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0
        ? (si = 5)
        : ((si = 0), (rl = _s = null), u0(n, n.pendingLanes));
      var p = n.pendingLanes;
      if (
        (p === 0 && (ms = null),
        Rn(o),
        (i = i.stateNode),
        Xt && typeof Xt.onCommitFiberRoot == 'function')
      )
        try {
          Xt.onCommitFiberRoot(Et, i, void 0, (i.current.flags & 128) === 128);
        } catch {}
      if (u !== null) {
        (i = X.T), (p = it.p), (it.p = 2), (X.T = null);
        try {
          for (var v = n.onRecoverableError, C = 0; C < u.length; C++) {
            var B = u[C];
            v(B.value, { componentStack: B.stack });
          }
        } finally {
          (X.T = i), (it.p = p);
        }
      }
      (sl & 3) !== 0 && bh(),
        Va(n),
        (p = n.pendingLanes),
        (o & 4194090) !== 0 && (p & 42) !== 0 ? (n === lp ? Uc++ : ((Uc = 0), (lp = n))) : (Uc = 0),
        Nc(0);
    }
  }
  function u0(n, i) {
    (n.pooledCacheLanes &= i) === 0 &&
      ((i = n.pooledCache), i != null && ((n.pooledCache = null), pc(i)));
  }
  function bh(n) {
    return o0(), l0(), c0(), h0();
  }
  function h0() {
    if (si !== 5) return !1;
    var n = _s,
      i = sp;
    sp = 0;
    var o = Rn(sl),
      u = X.T,
      p = it.p;
    try {
      (it.p = 32 > o ? 32 : o), (X.T = null), (o = op), (op = null);
      var v = _s,
        C = sl;
      if (((si = 0), (rl = _s = null), (sl = 0), (on & 6) !== 0)) throw Error(s(331));
      var B = on;
      if (
        ((on |= 4),
        qv(v.current),
        Zv(v, v.current, C, o),
        (on = B),
        Nc(0, !1),
        Xt && typeof Xt.onPostCommitFiberRoot == 'function')
      )
        try {
          Xt.onPostCommitFiberRoot(Et, v);
        } catch {}
      return !0;
    } finally {
      (it.p = p), (X.T = u), u0(n, i);
    }
  }
  function f0(n, i, o) {
    (i = bi(o, i)), (i = Fd(n.stateNode, i, 2)), (n = ss(n, i, 2)), n !== null && (Ot(n, 2), Va(n));
  }
  function _n(n, i, o) {
    if (n.tag === 3) f0(n, n, o);
    else
      for (; i !== null; ) {
        if (i.tag === 3) {
          f0(i, n, o);
          break;
        } else if (i.tag === 1) {
          var u = i.stateNode;
          if (
            typeof i.type.getDerivedStateFromError == 'function' ||
            (typeof u.componentDidCatch == 'function' && (ms === null || !ms.has(u)))
          ) {
            (n = bi(o, n)),
              (o = _v(2)),
              (u = ss(i, o, 2)),
              u !== null && (gv(o, u, i, n), Ot(u, 2), Va(u));
            break;
          }
        }
        i = i.return;
      }
  }
  function fp(n, i, o) {
    var u = n.pingCache;
    if (u === null) {
      u = n.pingCache = new ZM();
      var p = new Set();
      u.set(i, p);
    } else (p = u.get(i)), p === void 0 && ((p = new Set()), u.set(i, p));
    p.has(o) || ((np = !0), p.add(o), (n = KM.bind(null, n, i, o)), i.then(n, n));
  }
  function KM(n, i, o) {
    var u = n.pingCache;
    u !== null && u.delete(i),
      (n.pingedLanes |= n.suspendedLanes & o),
      (n.warmLanes &= ~o),
      yn === n &&
        (Ke & o) === o &&
        (On === 4 || (On === 3 && (Ke & 62914560) === Ke && 300 > Ut() - rp)
          ? (on & 2) === 0 && ol(n, 0)
          : (ip |= o),
        al === Ke && (al = 0)),
      Va(n);
  }
  function d0(n, i) {
    i === 0 && (i = qt()), (n = ts(n, i)), n !== null && (Ot(n, i), Va(n));
  }
  function QM(n) {
    var i = n.memoizedState,
      o = 0;
    i !== null && (o = i.retryLane), d0(n, o);
  }
  function JM(n, i) {
    var o = 0;
    switch (n.tag) {
      case 13:
        var u = n.stateNode,
          p = n.memoizedState;
        p !== null && (o = p.retryLane);
        break;
      case 19:
        u = n.stateNode;
        break;
      case 22:
        u = n.stateNode._retryCache;
        break;
      default:
        throw Error(s(314));
    }
    u !== null && u.delete(i), d0(n, o);
  }
  function $M(n, i) {
    return ye(n, i);
  }
  var Eh = null,
    cl = null,
    dp = !1,
    Th = !1,
    pp = !1,
    lo = 0;
  function Va(n) {
    n !== cl && n.next === null && (cl === null ? (Eh = cl = n) : (cl = cl.next = n)),
      (Th = !0),
      dp || ((dp = !0), eb());
  }
  function Nc(n, i) {
    if (!pp && Th) {
      pp = !0;
      do
        for (var o = !1, u = Eh; u !== null; ) {
          if (n !== 0) {
            var p = u.pendingLanes;
            if (p === 0) var v = 0;
            else {
              var C = u.suspendedLanes,
                B = u.pingedLanes;
              (v = (1 << (31 - $t(42 | n) + 1)) - 1),
                (v &= p & ~(C & ~B)),
                (v = v & 201326741 ? (v & 201326741) | 1 : v ? v | 2 : 0);
            }
            v !== 0 && ((o = !0), g0(u, v));
          } else
            (v = Ke),
              (v = Oe(
                u,
                u === yn ? v : 0,
                u.cancelPendingCommit !== null || u.timeoutHandle !== -1,
              )),
              (v & 3) === 0 || Me(u, v) || ((o = !0), g0(u, v));
          u = u.next;
        }
      while (o);
      pp = !1;
    }
  }
  function tb() {
    p0();
  }
  function p0() {
    Th = dp = !1;
    var n = 0;
    lo !== 0 && (cb() && (n = lo), (lo = 0));
    for (var i = Ut(), o = null, u = Eh; u !== null; ) {
      var p = u.next,
        v = m0(u, i);
      v === 0
        ? ((u.next = null), o === null ? (Eh = p) : (o.next = p), p === null && (cl = o))
        : ((o = u), (n !== 0 || (v & 3) !== 0) && (Th = !0)),
        (u = p);
    }
    Nc(n);
  }
  function m0(n, i) {
    for (
      var o = n.suspendedLanes,
        u = n.pingedLanes,
        p = n.expirationTimes,
        v = n.pendingLanes & -62914561;
      0 < v;

    ) {
      var C = 31 - $t(v),
        B = 1 << C,
        Y = p[C];
      Y === -1
        ? ((B & o) === 0 || (B & u) !== 0) && (p[C] = Je(B, i))
        : Y <= i && (n.expiredLanes |= B),
        (v &= ~B);
    }
    if (
      ((i = yn),
      (o = Ke),
      (o = Oe(n, n === i ? o : 0, n.cancelPendingCommit !== null || n.timeoutHandle !== -1)),
      (u = n.callbackNode),
      o === 0 || (n === i && (ln === 2 || ln === 9)) || n.cancelPendingCommit !== null)
    )
      return u !== null && u !== null && G(u), (n.callbackNode = null), (n.callbackPriority = 0);
    if ((o & 3) === 0 || Me(n, o)) {
      if (((i = o & -o), i === n.callbackPriority)) return i;
      switch ((u !== null && G(u), Rn(o))) {
        case 2:
        case 8:
          o = kt;
          break;
        case 32:
          o = H;
          break;
        case 268435456:
          o = rt;
          break;
        default:
          o = H;
      }
      return (
        (u = _0.bind(null, n)), (o = ye(o, u)), (n.callbackPriority = i), (n.callbackNode = o), i
      );
    }
    return u !== null && u !== null && G(u), (n.callbackPriority = 2), (n.callbackNode = null), 2;
  }
  function _0(n, i) {
    if (si !== 0 && si !== 5) return (n.callbackNode = null), (n.callbackPriority = 0), null;
    var o = n.callbackNode;
    if (bh() && n.callbackNode !== o) return null;
    var u = Ke;
    return (
      (u = Oe(n, n === yn ? u : 0, n.cancelPendingCommit !== null || n.timeoutHandle !== -1)),
      u === 0
        ? null
        : (Jv(n, u, i),
          m0(n, Ut()),
          n.callbackNode != null && n.callbackNode === o ? _0.bind(null, n) : null)
    );
  }
  function g0(n, i) {
    if (bh()) return null;
    Jv(n, i, !0);
  }
  function eb() {
    hb(function () {
      (on & 6) !== 0 ? ye(le, tb) : p0();
    });
  }
  function mp() {
    return lo === 0 && (lo = nt()), lo;
  }
  function v0(n) {
    return n == null || typeof n == 'symbol' || typeof n == 'boolean'
      ? null
      : typeof n == 'function'
        ? n
        : Hr('' + n);
  }
  function y0(n, i) {
    var o = i.ownerDocument.createElement('input');
    return (
      (o.name = i.name),
      (o.value = i.value),
      n.id && o.setAttribute('form', n.id),
      i.parentNode.insertBefore(o, i),
      (n = new FormData(n)),
      o.parentNode.removeChild(o),
      n
    );
  }
  function nb(n, i, o, u, p) {
    if (i === 'submit' && o && o.stateNode === p) {
      var v = v0((p[Wn] || null).action),
        C = u.submitter;
      C &&
        ((i = (i = C[Wn] || null) ? v0(i.formAction) : C.getAttribute('formAction')),
        i !== null && ((v = i), (C = null)));
      var B = new Hs('action', 'action', null, u, p);
      n.push({
        event: B,
        listeners: [
          {
            instance: null,
            listener: function () {
              if (u.defaultPrevented) {
                if (lo !== 0) {
                  var Y = C ? y0(p, C) : new FormData(p);
                  Nd(o, { pending: !0, data: Y, method: p.method, action: v }, null, Y);
                }
              } else
                typeof v == 'function' &&
                  (B.preventDefault(),
                  (Y = C ? y0(p, C) : new FormData(p)),
                  Nd(o, { pending: !0, data: Y, method: p.method, action: v }, v, Y));
            },
            currentTarget: p,
          },
        ],
      });
    }
  }
  for (var _p = 0; _p < cr.length; _p++) {
    var gp = cr[_p],
      ib = gp.toLowerCase(),
      ab = gp[0].toUpperCase() + gp.slice(1);
    Vi(ib, 'on' + ab);
  }
  Vi(Vu, 'onAnimationEnd'),
    Vi(Gi, 'onAnimationIteration'),
    Vi(qs, 'onAnimationStart'),
    Vi('dblclick', 'onDoubleClick'),
    Vi('focusin', 'onFocus'),
    Vi('focusout', 'onBlur'),
    Vi(ud, 'onTransitionRun'),
    Vi(Vo, 'onTransitionStart'),
    Vi(hd, 'onTransitionCancel'),
    Vi(hc, 'onTransitionEnd'),
    k('onMouseEnter', ['mouseout', 'mouseover']),
    k('onMouseLeave', ['mouseout', 'mouseover']),
    k('onPointerEnter', ['pointerout', 'pointerover']),
    k('onPointerLeave', ['pointerout', 'pointerover']),
    ya('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' ')),
    ya(
      'onSelect',
      'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
        ' ',
      ),
    ),
    ya('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']),
    ya('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' ')),
    ya(
      'onCompositionStart',
      'compositionstart focusout keydown keypress keyup mousedown'.split(' '),
    ),
    ya(
      'onCompositionUpdate',
      'compositionupdate focusout keydown keypress keyup mousedown'.split(' '),
    );
  var zc =
      'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
        ' ',
      ),
    rb = new Set(
      'beforetoggle cancel close invalid load scroll scrollend toggle'.split(' ').concat(zc),
    );
  function x0(n, i) {
    i = (i & 4) !== 0;
    for (var o = 0; o < n.length; o++) {
      var u = n[o],
        p = u.event;
      u = u.listeners;
      t: {
        var v = void 0;
        if (i)
          for (var C = u.length - 1; 0 <= C; C--) {
            var B = u[C],
              Y = B.instance,
              mt = B.currentTarget;
            if (((B = B.listener), Y !== v && p.isPropagationStopped())) break t;
            (v = B), (p.currentTarget = mt);
            try {
              v(p);
            } catch (Rt) {
              fh(Rt);
            }
            (p.currentTarget = null), (v = Y);
          }
        else
          for (C = 0; C < u.length; C++) {
            if (
              ((B = u[C]),
              (Y = B.instance),
              (mt = B.currentTarget),
              (B = B.listener),
              Y !== v && p.isPropagationStopped())
            )
              break t;
            (v = B), (p.currentTarget = mt);
            try {
              v(p);
            } catch (Rt) {
              fh(Rt);
            }
            (p.currentTarget = null), (v = Y);
          }
      }
    }
  }
  function qe(n, i) {
    var o = i[Kn];
    o === void 0 && (o = i[Kn] = new Set());
    var u = n + '__bubble';
    o.has(u) || (S0(i, n, 2, !1), o.add(u));
  }
  function vp(n, i, o) {
    var u = 0;
    i && (u |= 4), S0(o, n, u, i);
  }
  var wh = '_reactListening' + Math.random().toString(36).slice(2);
  function yp(n) {
    if (!n[wh]) {
      (n[wh] = !0),
        Ro.forEach(function (o) {
          o !== 'selectionchange' && (rb.has(o) || vp(o, !1, n), vp(o, !0, n));
        });
      var i = n.nodeType === 9 ? n : n.ownerDocument;
      i === null || i[wh] || ((i[wh] = !0), vp('selectionchange', !1, i));
    }
  }
  function S0(n, i, o, u) {
    switch (Z0(i)) {
      case 2:
        var p = Db;
        break;
      case 8:
        p = Ob;
        break;
      default:
        p = Op;
    }
    (o = p.bind(null, i, o, n)),
      (p = void 0),
      !Fs || (i !== 'touchstart' && i !== 'touchmove' && i !== 'wheel') || (p = !0),
      u
        ? p !== void 0
          ? n.addEventListener(i, o, { capture: !0, passive: p })
          : n.addEventListener(i, o, !0)
        : p !== void 0
          ? n.addEventListener(i, o, { passive: p })
          : n.addEventListener(i, o, !1);
  }
  function xp(n, i, o, u, p) {
    var v = u;
    if ((i & 1) === 0 && (i & 2) === 0 && u !== null)
      t: for (;;) {
        if (u === null) return;
        var C = u.tag;
        if (C === 3 || C === 4) {
          var B = u.stateNode.containerInfo;
          if (B === p) break;
          if (C === 4)
            for (C = u.return; C !== null; ) {
              var Y = C.tag;
              if ((Y === 3 || Y === 4) && C.stateNode.containerInfo === p) return;
              C = C.return;
            }
          for (; B !== null; ) {
            if (((C = Ii(B)), C === null)) return;
            if (((Y = C.tag), Y === 5 || Y === 6 || Y === 26 || Y === 27)) {
              u = v = C;
              continue t;
            }
            B = B.parentNode;
          }
        }
        u = u.return;
      }
    Bi(function () {
      var mt = v,
        Rt = Gr(o),
        Nt = [];
      t: {
        var vt = Wu.get(n);
        if (vt !== void 0) {
          var xt = Hs,
            Ce = n;
          switch (n) {
            case 'keypress':
              if (Dn(o) === 0) break t;
            case 'keydown':
            case 'keyup':
              xt = nd;
              break;
            case 'focusin':
              (Ce = 'focus'), (xt = ec);
              break;
            case 'focusout':
              (Ce = 'blur'), (xt = ec);
              break;
            case 'beforeblur':
            case 'afterblur':
              xt = ec;
              break;
            case 'click':
              if (o.button === 2) break t;
            case 'auxclick':
            case 'dblclick':
            case 'mousedown':
            case 'mousemove':
            case 'mouseup':
            case 'mouseout':
            case 'mouseover':
            case 'contextmenu':
              xt = Zr;
              break;
            case 'drag':
            case 'dragend':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'dragstart':
            case 'drop':
              xt = Qf;
              break;
            case 'touchcancel':
            case 'touchend':
            case 'touchmove':
            case 'touchstart':
              xt = ad;
              break;
            case Vu:
            case Gi:
            case qs:
              xt = Jf;
              break;
            case hc:
              xt = rd;
              break;
            case 'scroll':
            case 'scrollend':
              xt = Kf;
              break;
            case 'wheel':
              xt = Uu;
              break;
            case 'copy':
            case 'cut':
            case 'paste':
              xt = nc;
              break;
            case 'gotpointercapture':
            case 'lostpointercapture':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'pointerup':
              xt = ac;
              break;
            case 'toggle':
            case 'beforetoggle':
              xt = rr;
          }
          var we = (i & 4) !== 0,
            fn = !we && (n === 'scroll' || n === 'scrollend'),
            ct = we ? (vt !== null ? vt + 'Capture' : null) : vt;
          we = [];
          for (var $ = mt, dt; $ !== null; ) {
            var Pt = $;
            if (
              ((dt = Pt.stateNode),
              (Pt = Pt.tag),
              (Pt !== 5 && Pt !== 26 && Pt !== 27) ||
                dt === null ||
                ct === null ||
                ((Pt = $e($, ct)), Pt != null && we.push(Ic($, Pt, dt))),
              fn)
            )
              break;
            $ = $.return;
          }
          0 < we.length &&
            ((vt = new xt(vt, Ce, null, o, Rt)), Nt.push({ event: vt, listeners: we }));
        }
      }
      if ((i & 7) === 0) {
        t: {
          if (
            ((vt = n === 'mouseover' || n === 'pointerover'),
            (xt = n === 'mouseout' || n === 'pointerout'),
            vt && o !== ks && (Ce = o.relatedTarget || o.fromElement) && (Ii(Ce) || Ce[ui]))
          )
            break t;
          if (
            (xt || vt) &&
            ((vt =
              Rt.window === Rt
                ? Rt
                : (vt = Rt.ownerDocument)
                  ? vt.defaultView || vt.parentWindow
                  : window),
            xt
              ? ((Ce = o.relatedTarget || o.toElement),
                (xt = mt),
                (Ce = Ce ? Ii(Ce) : null),
                Ce !== null &&
                  ((fn = h(Ce)), (we = Ce.tag), Ce !== fn || (we !== 5 && we !== 27 && we !== 6)) &&
                  (Ce = null))
              : ((xt = null), (Ce = mt)),
            xt !== Ce)
          ) {
            if (
              ((we = Zr),
              (Pt = 'onMouseLeave'),
              (ct = 'onMouseEnter'),
              ($ = 'mouse'),
              (n === 'pointerout' || n === 'pointerover') &&
                ((we = ac), (Pt = 'onPointerLeave'), (ct = 'onPointerEnter'), ($ = 'pointer')),
              (fn = xt == null ? vt : Ci(xt)),
              (dt = Ce == null ? vt : Ci(Ce)),
              (vt = new we(Pt, $ + 'leave', xt, o, Rt)),
              (vt.target = fn),
              (vt.relatedTarget = dt),
              (Pt = null),
              Ii(Rt) === mt &&
                ((we = new we(ct, $ + 'enter', Ce, o, Rt)),
                (we.target = dt),
                (we.relatedTarget = fn),
                (Pt = we)),
              (fn = Pt),
              xt && Ce)
            )
              e: {
                for (we = xt, ct = Ce, $ = 0, dt = we; dt; dt = ul(dt)) $++;
                for (dt = 0, Pt = ct; Pt; Pt = ul(Pt)) dt++;
                for (; 0 < $ - dt; ) (we = ul(we)), $--;
                for (; 0 < dt - $; ) (ct = ul(ct)), dt--;
                for (; $--; ) {
                  if (we === ct || (ct !== null && we === ct.alternate)) break e;
                  (we = ul(we)), (ct = ul(ct));
                }
                we = null;
              }
            else we = null;
            xt !== null && M0(Nt, vt, xt, we, !1),
              Ce !== null && fn !== null && M0(Nt, fn, Ce, we, !0);
          }
        }
        t: {
          if (
            ((vt = mt ? Ci(mt) : window),
            (xt = vt.nodeName && vt.nodeName.toLowerCase()),
            xt === 'select' || (xt === 'input' && vt.type === 'file'))
          )
            var de = qr;
          else if (or(vt))
            if (oc) de = cd;
            else {
              de = ld;
              var Xe = cc;
            }
          else
            (xt = vt.nodeName),
              !xt || xt.toLowerCase() !== 'input' || (vt.type !== 'checkbox' && vt.type !== 'radio')
                ? mt && Bs(mt.elementType) && (de = qr)
                : (de = Ma);
          if (de && (de = de(n, mt))) {
            ku(Nt, de, o, Rt);
            break t;
          }
          Xe && Xe(n, vt, mt),
            n === 'focusout' &&
              mt &&
              vt.type === 'number' &&
              mt.memoizedProps.value != null &&
              zn(vt, 'number', vt.value);
        }
        switch (((Xe = mt ? Ci(mt) : window), n)) {
          case 'focusin':
            (or(Xe) || Xe.contentEditable === 'true') && ((Hi = Xe), (Qr = mt), (lr = null));
            break;
          case 'focusout':
            lr = Qr = Hi = null;
            break;
          case 'mousedown':
            Ho = !0;
            break;
          case 'contextmenu':
          case 'mouseup':
          case 'dragend':
            (Ho = !1), Hu(Nt, o, Rt);
            break;
          case 'selectionchange':
            if (Fo) break;
          case 'keydown':
          case 'keyup':
            Hu(Nt, o, Rt);
        }
        var xe;
        if (sr)
          t: {
            switch (n) {
              case 'compositionstart':
                var Ae = 'onCompositionStart';
                break t;
              case 'compositionend':
                Ae = 'onCompositionEnd';
                break t;
              case 'compositionupdate':
                Ae = 'onCompositionUpdate';
                break t;
            }
            Ae = void 0;
          }
        else
          Xr
            ? Io(n, o) && (Ae = 'onCompositionEnd')
            : n === 'keydown' && o.keyCode === 229 && (Ae = 'onCompositionStart');
        Ae &&
          (sc &&
            o.locale !== 'ko' &&
            (Xr || Ae !== 'onCompositionStart'
              ? Ae === 'onCompositionEnd' && Xr && (xe = Wr())
              : ((ia = Rt), (xa = 'value' in ia ? ia.value : ia.textContent), (Xr = !0))),
          (Xe = Ah(mt, Ae)),
          0 < Xe.length &&
            ((Ae = new ki(Ae, n, null, o, Rt)),
            Nt.push({ event: Ae, listeners: Xe }),
            xe ? (Ae.data = xe) : ((xe = Iu(o)), xe !== null && (Ae.data = xe)))),
          (xe = Nu ? Bu(n, o) : od(n, o)) &&
            ((Ae = Ah(mt, 'onBeforeInput')),
            0 < Ae.length &&
              ((Xe = new ki('onBeforeInput', 'beforeinput', null, o, Rt)),
              Nt.push({ event: Xe, listeners: Ae }),
              (Xe.data = xe))),
          nb(Nt, n, mt, o, Rt);
      }
      x0(Nt, i);
    });
  }
  function Ic(n, i, o) {
    return { instance: n, listener: i, currentTarget: o };
  }
  function Ah(n, i) {
    for (var o = i + 'Capture', u = []; n !== null; ) {
      var p = n,
        v = p.stateNode;
      if (
        ((p = p.tag),
        (p !== 5 && p !== 26 && p !== 27) ||
          v === null ||
          ((p = $e(n, o)),
          p != null && u.unshift(Ic(n, p, v)),
          (p = $e(n, i)),
          p != null && u.push(Ic(n, p, v))),
        n.tag === 3)
      )
        return u;
      n = n.return;
    }
    return [];
  }
  function ul(n) {
    if (n === null) return null;
    do n = n.return;
    while (n && n.tag !== 5 && n.tag !== 27);
    return n || null;
  }
  function M0(n, i, o, u, p) {
    for (var v = i._reactName, C = []; o !== null && o !== u; ) {
      var B = o,
        Y = B.alternate,
        mt = B.stateNode;
      if (((B = B.tag), Y !== null && Y === u)) break;
      (B !== 5 && B !== 26 && B !== 27) ||
        mt === null ||
        ((Y = mt),
        p
          ? ((mt = $e(o, v)), mt != null && C.unshift(Ic(o, mt, Y)))
          : p || ((mt = $e(o, v)), mt != null && C.push(Ic(o, mt, Y)))),
        (o = o.return);
    }
    C.length !== 0 && n.push({ event: i, listeners: C });
  }
  var sb = /\r\n?/g,
    ob = /\u0000|\uFFFD/g;
  function b0(n) {
    return (typeof n == 'string' ? n : '' + n)
      .replace(
        sb,
        `
`,
      )
      .replace(ob, '');
  }
  function E0(n, i) {
    return (i = b0(i)), b0(n) === i;
  }
  function Ch() {}
  function hn(n, i, o, u, p, v) {
    switch (o) {
      case 'children':
        typeof u == 'string'
          ? i === 'body' || (i === 'textarea' && u === '') || hi(n, u)
          : (typeof u == 'number' || typeof u == 'bigint') && i !== 'body' && hi(n, '' + u);
        break;
      case 'className':
        Kt(n, 'class', u);
        break;
      case 'tabIndex':
        Kt(n, 'tabindex', u);
        break;
      case 'dir':
      case 'role':
      case 'viewBox':
      case 'width':
      case 'height':
        Kt(n, o, u);
        break;
      case 'style':
        Fr(n, u, v);
        break;
      case 'data':
        if (i !== 'object') {
          Kt(n, 'data', u);
          break;
        }
      case 'src':
      case 'href':
        if (u === '' && (i !== 'a' || o !== 'href')) {
          n.removeAttribute(o);
          break;
        }
        if (u == null || typeof u == 'function' || typeof u == 'symbol' || typeof u == 'boolean') {
          n.removeAttribute(o);
          break;
        }
        (u = Hr('' + u)), n.setAttribute(o, u);
        break;
      case 'action':
      case 'formAction':
        if (typeof u == 'function') {
          n.setAttribute(
            o,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')",
          );
          break;
        } else
          typeof v == 'function' &&
            (o === 'formAction'
              ? (i !== 'input' && hn(n, i, 'name', p.name, p, null),
                hn(n, i, 'formEncType', p.formEncType, p, null),
                hn(n, i, 'formMethod', p.formMethod, p, null),
                hn(n, i, 'formTarget', p.formTarget, p, null))
              : (hn(n, i, 'encType', p.encType, p, null),
                hn(n, i, 'method', p.method, p, null),
                hn(n, i, 'target', p.target, p, null)));
        if (u == null || typeof u == 'symbol' || typeof u == 'boolean') {
          n.removeAttribute(o);
          break;
        }
        (u = Hr('' + u)), n.setAttribute(o, u);
        break;
      case 'onClick':
        u != null && (n.onclick = Ch);
        break;
      case 'onScroll':
        u != null && qe('scroll', n);
        break;
      case 'onScrollEnd':
        u != null && qe('scrollend', n);
        break;
      case 'dangerouslySetInnerHTML':
        if (u != null) {
          if (typeof u != 'object' || !('__html' in u)) throw Error(s(61));
          if (((o = u.__html), o != null)) {
            if (p.children != null) throw Error(s(60));
            n.innerHTML = o;
          }
        }
        break;
      case 'multiple':
        n.multiple = u && typeof u != 'function' && typeof u != 'symbol';
        break;
      case 'muted':
        n.muted = u && typeof u != 'function' && typeof u != 'symbol';
        break;
      case 'suppressContentEditableWarning':
      case 'suppressHydrationWarning':
      case 'defaultValue':
      case 'defaultChecked':
      case 'innerHTML':
      case 'ref':
        break;
      case 'autoFocus':
        break;
      case 'xlinkHref':
        if (u == null || typeof u == 'function' || typeof u == 'boolean' || typeof u == 'symbol') {
          n.removeAttribute('xlink:href');
          break;
        }
        (o = Hr('' + u)), n.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', o);
        break;
      case 'contentEditable':
      case 'spellCheck':
      case 'draggable':
      case 'value':
      case 'autoReverse':
      case 'externalResourcesRequired':
      case 'focusable':
      case 'preserveAlpha':
        u != null && typeof u != 'function' && typeof u != 'symbol'
          ? n.setAttribute(o, '' + u)
          : n.removeAttribute(o);
        break;
      case 'inert':
      case 'allowFullScreen':
      case 'async':
      case 'autoPlay':
      case 'controls':
      case 'default':
      case 'defer':
      case 'disabled':
      case 'disablePictureInPicture':
      case 'disableRemotePlayback':
      case 'formNoValidate':
      case 'hidden':
      case 'loop':
      case 'noModule':
      case 'noValidate':
      case 'open':
      case 'playsInline':
      case 'readOnly':
      case 'required':
      case 'reversed':
      case 'scoped':
      case 'seamless':
      case 'itemScope':
        u && typeof u != 'function' && typeof u != 'symbol'
          ? n.setAttribute(o, '')
          : n.removeAttribute(o);
        break;
      case 'capture':
      case 'download':
        u === !0
          ? n.setAttribute(o, '')
          : u !== !1 && u != null && typeof u != 'function' && typeof u != 'symbol'
            ? n.setAttribute(o, u)
            : n.removeAttribute(o);
        break;
      case 'cols':
      case 'rows':
      case 'size':
      case 'span':
        u != null && typeof u != 'function' && typeof u != 'symbol' && !isNaN(u) && 1 <= u
          ? n.setAttribute(o, u)
          : n.removeAttribute(o);
        break;
      case 'rowSpan':
      case 'start':
        u == null || typeof u == 'function' || typeof u == 'symbol' || isNaN(u)
          ? n.removeAttribute(o)
          : n.setAttribute(o, u);
        break;
      case 'popover':
        qe('beforetoggle', n), qe('toggle', n), Vt(n, 'popover', u);
        break;
      case 'xlinkActuate':
        Jt(n, 'http://www.w3.org/1999/xlink', 'xlink:actuate', u);
        break;
      case 'xlinkArcrole':
        Jt(n, 'http://www.w3.org/1999/xlink', 'xlink:arcrole', u);
        break;
      case 'xlinkRole':
        Jt(n, 'http://www.w3.org/1999/xlink', 'xlink:role', u);
        break;
      case 'xlinkShow':
        Jt(n, 'http://www.w3.org/1999/xlink', 'xlink:show', u);
        break;
      case 'xlinkTitle':
        Jt(n, 'http://www.w3.org/1999/xlink', 'xlink:title', u);
        break;
      case 'xlinkType':
        Jt(n, 'http://www.w3.org/1999/xlink', 'xlink:type', u);
        break;
      case 'xmlBase':
        Jt(n, 'http://www.w3.org/XML/1998/namespace', 'xml:base', u);
        break;
      case 'xmlLang':
        Jt(n, 'http://www.w3.org/XML/1998/namespace', 'xml:lang', u);
        break;
      case 'xmlSpace':
        Jt(n, 'http://www.w3.org/XML/1998/namespace', 'xml:space', u);
        break;
      case 'is':
        Vt(n, 'is', u);
        break;
      case 'innerText':
      case 'textContent':
        break;
      default:
        (!(2 < o.length) || (o[0] !== 'o' && o[0] !== 'O') || (o[1] !== 'n' && o[1] !== 'N')) &&
          ((o = Jl.get(o) || o), Vt(n, o, u));
    }
  }
  function Sp(n, i, o, u, p, v) {
    switch (o) {
      case 'style':
        Fr(n, u, v);
        break;
      case 'dangerouslySetInnerHTML':
        if (u != null) {
          if (typeof u != 'object' || !('__html' in u)) throw Error(s(61));
          if (((o = u.__html), o != null)) {
            if (p.children != null) throw Error(s(60));
            n.innerHTML = o;
          }
        }
        break;
      case 'children':
        typeof u == 'string'
          ? hi(n, u)
          : (typeof u == 'number' || typeof u == 'bigint') && hi(n, '' + u);
        break;
      case 'onScroll':
        u != null && qe('scroll', n);
        break;
      case 'onScrollEnd':
        u != null && qe('scrollend', n);
        break;
      case 'onClick':
        u != null && (n.onclick = Ch);
        break;
      case 'suppressContentEditableWarning':
      case 'suppressHydrationWarning':
      case 'innerHTML':
      case 'ref':
        break;
      case 'innerText':
      case 'textContent':
        break;
      default:
        if (!Lo.hasOwnProperty(o))
          t: {
            if (
              o[0] === 'o' &&
              o[1] === 'n' &&
              ((p = o.endsWith('Capture')),
              (i = o.slice(2, p ? o.length - 7 : void 0)),
              (v = n[Wn] || null),
              (v = v != null ? v[o] : null),
              typeof v == 'function' && n.removeEventListener(i, v, p),
              typeof u == 'function')
            ) {
              typeof v != 'function' &&
                v !== null &&
                (o in n ? (n[o] = null) : n.hasAttribute(o) && n.removeAttribute(o)),
                n.addEventListener(i, u, p);
              break t;
            }
            o in n ? (n[o] = u) : u === !0 ? n.setAttribute(o, '') : Vt(n, o, u);
          }
    }
  }
  function oi(n, i, o) {
    switch (i) {
      case 'div':
      case 'span':
      case 'svg':
      case 'path':
      case 'a':
      case 'g':
      case 'p':
      case 'li':
        break;
      case 'img':
        qe('error', n), qe('load', n);
        var u = !1,
          p = !1,
          v;
        for (v in o)
          if (o.hasOwnProperty(v)) {
            var C = o[v];
            if (C != null)
              switch (v) {
                case 'src':
                  u = !0;
                  break;
                case 'srcSet':
                  p = !0;
                  break;
                case 'children':
                case 'dangerouslySetInnerHTML':
                  throw Error(s(137, i));
                default:
                  hn(n, i, v, C, o, null);
              }
          }
        p && hn(n, i, 'srcSet', o.srcSet, o, null), u && hn(n, i, 'src', o.src, o, null);
        return;
      case 'input':
        qe('invalid', n);
        var B = (v = C = p = null),
          Y = null,
          mt = null;
        for (u in o)
          if (o.hasOwnProperty(u)) {
            var Rt = o[u];
            if (Rt != null)
              switch (u) {
                case 'name':
                  p = Rt;
                  break;
                case 'type':
                  C = Rt;
                  break;
                case 'checked':
                  Y = Rt;
                  break;
                case 'defaultChecked':
                  mt = Rt;
                  break;
                case 'value':
                  v = Rt;
                  break;
                case 'defaultValue':
                  B = Rt;
                  break;
                case 'children':
                case 'dangerouslySetInnerHTML':
                  if (Rt != null) throw Error(s(137, i));
                  break;
                default:
                  hn(n, i, u, Rt, o, null);
              }
          }
        sn(n, v, B, Y, mt, C, p, !1), gn(n);
        return;
      case 'select':
        qe('invalid', n), (u = C = v = null);
        for (p in o)
          if (o.hasOwnProperty(p) && ((B = o[p]), B != null))
            switch (p) {
              case 'value':
                v = B;
                break;
              case 'defaultValue':
                C = B;
                break;
              case 'multiple':
                u = B;
              default:
                hn(n, i, p, B, o, null);
            }
        (i = v),
          (o = C),
          (n.multiple = !!u),
          i != null ? mn(n, !!u, i, !1) : o != null && mn(n, !!u, o, !0);
        return;
      case 'textarea':
        qe('invalid', n), (v = p = u = null);
        for (C in o)
          if (o.hasOwnProperty(C) && ((B = o[C]), B != null))
            switch (C) {
              case 'value':
                u = B;
                break;
              case 'defaultValue':
                p = B;
                break;
              case 'children':
                v = B;
                break;
              case 'dangerouslySetInnerHTML':
                if (B != null) throw Error(s(91));
                break;
              default:
                hn(n, i, C, B, o, null);
            }
        xn(n, u, p, v), gn(n);
        return;
      case 'option':
        for (Y in o)
          if (o.hasOwnProperty(Y) && ((u = o[Y]), u != null))
            switch (Y) {
              case 'selected':
                n.selected = u && typeof u != 'function' && typeof u != 'symbol';
                break;
              default:
                hn(n, i, Y, u, o, null);
            }
        return;
      case 'dialog':
        qe('beforetoggle', n), qe('toggle', n), qe('cancel', n), qe('close', n);
        break;
      case 'iframe':
      case 'object':
        qe('load', n);
        break;
      case 'video':
      case 'audio':
        for (u = 0; u < zc.length; u++) qe(zc[u], n);
        break;
      case 'image':
        qe('error', n), qe('load', n);
        break;
      case 'details':
        qe('toggle', n);
        break;
      case 'embed':
      case 'source':
      case 'link':
        qe('error', n), qe('load', n);
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'hr':
      case 'keygen':
      case 'meta':
      case 'param':
      case 'track':
      case 'wbr':
      case 'menuitem':
        for (mt in o)
          if (o.hasOwnProperty(mt) && ((u = o[mt]), u != null))
            switch (mt) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw Error(s(137, i));
              default:
                hn(n, i, mt, u, o, null);
            }
        return;
      default:
        if (Bs(i)) {
          for (Rt in o)
            o.hasOwnProperty(Rt) && ((u = o[Rt]), u !== void 0 && Sp(n, i, Rt, u, o, void 0));
          return;
        }
    }
    for (B in o) o.hasOwnProperty(B) && ((u = o[B]), u != null && hn(n, i, B, u, o, null));
  }
  function lb(n, i, o, u) {
    switch (i) {
      case 'div':
      case 'span':
      case 'svg':
      case 'path':
      case 'a':
      case 'g':
      case 'p':
      case 'li':
        break;
      case 'input':
        var p = null,
          v = null,
          C = null,
          B = null,
          Y = null,
          mt = null,
          Rt = null;
        for (xt in o) {
          var Nt = o[xt];
          if (o.hasOwnProperty(xt) && Nt != null)
            switch (xt) {
              case 'checked':
                break;
              case 'value':
                break;
              case 'defaultValue':
                Y = Nt;
              default:
                u.hasOwnProperty(xt) || hn(n, i, xt, null, u, Nt);
            }
        }
        for (var vt in u) {
          var xt = u[vt];
          if (((Nt = o[vt]), u.hasOwnProperty(vt) && (xt != null || Nt != null)))
            switch (vt) {
              case 'type':
                v = xt;
                break;
              case 'name':
                p = xt;
                break;
              case 'checked':
                mt = xt;
                break;
              case 'defaultChecked':
                Rt = xt;
                break;
              case 'value':
                C = xt;
                break;
              case 'defaultValue':
                B = xt;
                break;
              case 'children':
              case 'dangerouslySetInnerHTML':
                if (xt != null) throw Error(s(137, i));
                break;
              default:
                xt !== Nt && hn(n, i, vt, xt, u, Nt);
            }
        }
        Pn(n, C, B, Y, mt, Rt, v, p);
        return;
      case 'select':
        xt = C = B = vt = null;
        for (v in o)
          if (((Y = o[v]), o.hasOwnProperty(v) && Y != null))
            switch (v) {
              case 'value':
                break;
              case 'multiple':
                xt = Y;
              default:
                u.hasOwnProperty(v) || hn(n, i, v, null, u, Y);
            }
        for (p in u)
          if (((v = u[p]), (Y = o[p]), u.hasOwnProperty(p) && (v != null || Y != null)))
            switch (p) {
              case 'value':
                vt = v;
                break;
              case 'defaultValue':
                B = v;
                break;
              case 'multiple':
                C = v;
              default:
                v !== Y && hn(n, i, p, v, u, Y);
            }
        (i = B),
          (o = C),
          (u = xt),
          vt != null
            ? mn(n, !!o, vt, !1)
            : !!u != !!o && (i != null ? mn(n, !!o, i, !0) : mn(n, !!o, o ? [] : '', !1));
        return;
      case 'textarea':
        xt = vt = null;
        for (B in o)
          if (((p = o[B]), o.hasOwnProperty(B) && p != null && !u.hasOwnProperty(B)))
            switch (B) {
              case 'value':
                break;
              case 'children':
                break;
              default:
                hn(n, i, B, null, u, p);
            }
        for (C in u)
          if (((p = u[C]), (v = o[C]), u.hasOwnProperty(C) && (p != null || v != null)))
            switch (C) {
              case 'value':
                vt = p;
                break;
              case 'defaultValue':
                xt = p;
                break;
              case 'children':
                break;
              case 'dangerouslySetInnerHTML':
                if (p != null) throw Error(s(91));
                break;
              default:
                p !== v && hn(n, i, C, p, u, v);
            }
        He(n, vt, xt);
        return;
      case 'option':
        for (var Ce in o)
          if (((vt = o[Ce]), o.hasOwnProperty(Ce) && vt != null && !u.hasOwnProperty(Ce)))
            switch (Ce) {
              case 'selected':
                n.selected = !1;
                break;
              default:
                hn(n, i, Ce, null, u, vt);
            }
        for (Y in u)
          if (
            ((vt = u[Y]),
            (xt = o[Y]),
            u.hasOwnProperty(Y) && vt !== xt && (vt != null || xt != null))
          )
            switch (Y) {
              case 'selected':
                n.selected = vt && typeof vt != 'function' && typeof vt != 'symbol';
                break;
              default:
                hn(n, i, Y, vt, u, xt);
            }
        return;
      case 'img':
      case 'link':
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'embed':
      case 'hr':
      case 'keygen':
      case 'meta':
      case 'param':
      case 'source':
      case 'track':
      case 'wbr':
      case 'menuitem':
        for (var we in o)
          (vt = o[we]),
            o.hasOwnProperty(we) &&
              vt != null &&
              !u.hasOwnProperty(we) &&
              hn(n, i, we, null, u, vt);
        for (mt in u)
          if (
            ((vt = u[mt]),
            (xt = o[mt]),
            u.hasOwnProperty(mt) && vt !== xt && (vt != null || xt != null))
          )
            switch (mt) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                if (vt != null) throw Error(s(137, i));
                break;
              default:
                hn(n, i, mt, vt, u, xt);
            }
        return;
      default:
        if (Bs(i)) {
          for (var fn in o)
            (vt = o[fn]),
              o.hasOwnProperty(fn) &&
                vt !== void 0 &&
                !u.hasOwnProperty(fn) &&
                Sp(n, i, fn, void 0, u, vt);
          for (Rt in u)
            (vt = u[Rt]),
              (xt = o[Rt]),
              !u.hasOwnProperty(Rt) ||
                vt === xt ||
                (vt === void 0 && xt === void 0) ||
                Sp(n, i, Rt, vt, u, xt);
          return;
        }
    }
    for (var ct in o)
      (vt = o[ct]),
        o.hasOwnProperty(ct) && vt != null && !u.hasOwnProperty(ct) && hn(n, i, ct, null, u, vt);
    for (Nt in u)
      (vt = u[Nt]),
        (xt = o[Nt]),
        !u.hasOwnProperty(Nt) || vt === xt || (vt == null && xt == null) || hn(n, i, Nt, vt, u, xt);
  }
  var Mp = null,
    bp = null;
  function Rh(n) {
    return n.nodeType === 9 ? n : n.ownerDocument;
  }
  function T0(n) {
    switch (n) {
      case 'http://www.w3.org/2000/svg':
        return 1;
      case 'http://www.w3.org/1998/Math/MathML':
        return 2;
      default:
        return 0;
    }
  }
  function w0(n, i) {
    if (n === 0)
      switch (i) {
        case 'svg':
          return 1;
        case 'math':
          return 2;
        default:
          return 0;
      }
    return n === 1 && i === 'foreignObject' ? 0 : n;
  }
  function Ep(n, i) {
    return (
      n === 'textarea' ||
      n === 'noscript' ||
      typeof i.children == 'string' ||
      typeof i.children == 'number' ||
      typeof i.children == 'bigint' ||
      (typeof i.dangerouslySetInnerHTML == 'object' &&
        i.dangerouslySetInnerHTML !== null &&
        i.dangerouslySetInnerHTML.__html != null)
    );
  }
  var Tp = null;
  function cb() {
    var n = window.event;
    return n && n.type === 'popstate' ? (n === Tp ? !1 : ((Tp = n), !0)) : ((Tp = null), !1);
  }
  var A0 = typeof setTimeout == 'function' ? setTimeout : void 0,
    ub = typeof clearTimeout == 'function' ? clearTimeout : void 0,
    C0 = typeof Promise == 'function' ? Promise : void 0,
    hb =
      typeof queueMicrotask == 'function'
        ? queueMicrotask
        : typeof C0 < 'u'
          ? function (n) {
              return C0.resolve(null).then(n).catch(fb);
            }
          : A0;
  function fb(n) {
    setTimeout(function () {
      throw n;
    });
  }
  function vs(n) {
    return n === 'head';
  }
  function R0(n, i) {
    var o = i,
      u = 0,
      p = 0;
    do {
      var v = o.nextSibling;
      if ((n.removeChild(o), v && v.nodeType === 8))
        if (((o = v.data), o === '/$')) {
          if (0 < u && 8 > u) {
            o = u;
            var C = n.ownerDocument;
            if ((o & 1 && Bc(C.documentElement), o & 2 && Bc(C.body), o & 4))
              for (o = C.head, Bc(o), C = o.firstChild; C; ) {
                var B = C.nextSibling,
                  Y = C.nodeName;
                C[_a] ||
                  Y === 'SCRIPT' ||
                  Y === 'STYLE' ||
                  (Y === 'LINK' && C.rel.toLowerCase() === 'stylesheet') ||
                  o.removeChild(C),
                  (C = B);
              }
          }
          if (p === 0) {
            n.removeChild(v), Xc(i);
            return;
          }
          p--;
        } else o === '$' || o === '$?' || o === '$!' ? p++ : (u = o.charCodeAt(0) - 48);
      else u = 0;
      o = v;
    } while (o);
    Xc(i);
  }
  function wp(n) {
    var i = n.firstChild;
    for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
      var o = i;
      switch (((i = i.nextSibling), o.nodeName)) {
        case 'HTML':
        case 'HEAD':
        case 'BODY':
          wp(o), ga(o);
          continue;
        case 'SCRIPT':
        case 'STYLE':
          continue;
        case 'LINK':
          if (o.rel.toLowerCase() === 'stylesheet') continue;
      }
      n.removeChild(o);
    }
  }
  function db(n, i, o, u) {
    for (; n.nodeType === 1; ) {
      var p = o;
      if (n.nodeName.toLowerCase() !== i.toLowerCase()) {
        if (!u && (n.nodeName !== 'INPUT' || n.type !== 'hidden')) break;
      } else if (u) {
        if (!n[_a])
          switch (i) {
            case 'meta':
              if (!n.hasAttribute('itemprop')) break;
              return n;
            case 'link':
              if (
                ((v = n.getAttribute('rel')),
                v === 'stylesheet' && n.hasAttribute('data-precedence'))
              )
                break;
              if (
                v !== p.rel ||
                n.getAttribute('href') !== (p.href == null || p.href === '' ? null : p.href) ||
                n.getAttribute('crossorigin') !== (p.crossOrigin == null ? null : p.crossOrigin) ||
                n.getAttribute('title') !== (p.title == null ? null : p.title)
              )
                break;
              return n;
            case 'style':
              if (n.hasAttribute('data-precedence')) break;
              return n;
            case 'script':
              if (
                ((v = n.getAttribute('src')),
                (v !== (p.src == null ? null : p.src) ||
                  n.getAttribute('type') !== (p.type == null ? null : p.type) ||
                  n.getAttribute('crossorigin') !==
                    (p.crossOrigin == null ? null : p.crossOrigin)) &&
                  v &&
                  n.hasAttribute('async') &&
                  !n.hasAttribute('itemprop'))
              )
                break;
              return n;
            default:
              return n;
          }
      } else if (i === 'input' && n.type === 'hidden') {
        var v = p.name == null ? null : '' + p.name;
        if (p.type === 'hidden' && n.getAttribute('name') === v) return n;
      } else return n;
      if (((n = wa(n.nextSibling)), n === null)) break;
    }
    return null;
  }
  function pb(n, i, o) {
    if (i === '') return null;
    for (; n.nodeType !== 3; )
      if (
        ((n.nodeType !== 1 || n.nodeName !== 'INPUT' || n.type !== 'hidden') && !o) ||
        ((n = wa(n.nextSibling)), n === null)
      )
        return null;
    return n;
  }
  function Ap(n) {
    return n.data === '$!' || (n.data === '$?' && n.ownerDocument.readyState === 'complete');
  }
  function mb(n, i) {
    var o = n.ownerDocument;
    if (n.data !== '$?' || o.readyState === 'complete') i();
    else {
      var u = function () {
        i(), o.removeEventListener('DOMContentLoaded', u);
      };
      o.addEventListener('DOMContentLoaded', u), (n._reactRetry = u);
    }
  }
  function wa(n) {
    for (; n != null; n = n.nextSibling) {
      var i = n.nodeType;
      if (i === 1 || i === 3) break;
      if (i === 8) {
        if (((i = n.data), i === '$' || i === '$!' || i === '$?' || i === 'F!' || i === 'F')) break;
        if (i === '/$') return null;
      }
    }
    return n;
  }
  var Cp = null;
  function L0(n) {
    n = n.previousSibling;
    for (var i = 0; n; ) {
      if (n.nodeType === 8) {
        var o = n.data;
        if (o === '$' || o === '$!' || o === '$?') {
          if (i === 0) return n;
          i--;
        } else o === '/$' && i++;
      }
      n = n.previousSibling;
    }
    return null;
  }
  function P0(n, i, o) {
    switch (((i = Rh(o)), n)) {
      case 'html':
        if (((n = i.documentElement), !n)) throw Error(s(452));
        return n;
      case 'head':
        if (((n = i.head), !n)) throw Error(s(453));
        return n;
      case 'body':
        if (((n = i.body), !n)) throw Error(s(454));
        return n;
      default:
        throw Error(s(451));
    }
  }
  function Bc(n) {
    for (var i = n.attributes; i.length; ) n.removeAttributeNode(i[0]);
    ga(n);
  }
  var ua = new Map(),
    D0 = new Set();
  function Lh(n) {
    return typeof n.getRootNode == 'function'
      ? n.getRootNode()
      : n.nodeType === 9
        ? n
        : n.ownerDocument;
  }
  var Sr = it.d;
  it.d = { f: _b, r: gb, D: vb, C: yb, L: xb, m: Sb, X: bb, S: Mb, M: Eb };
  function _b() {
    var n = Sr.f(),
      i = Sh();
    return n || i;
  }
  function gb(n) {
    var i = ta(n);
    i !== null && i.tag === 5 && i.type === 'form' ? Jg(i) : Sr.r(n);
  }
  var hl = typeof document > 'u' ? null : document;
  function O0(n, i, o) {
    var u = hl;
    if (u && typeof i == 'string' && i) {
      var p = nn(i);
      (p = 'link[rel="' + n + '"][href="' + p + '"]'),
        typeof o == 'string' && (p += '[crossorigin="' + o + '"]'),
        D0.has(p) ||
          (D0.add(p),
          (n = { rel: n, crossOrigin: o, href: i }),
          u.querySelector(p) === null &&
            ((i = u.createElement('link')), oi(i, 'link', n), Ln(i), u.head.appendChild(i)));
    }
  }
  function vb(n) {
    Sr.D(n), O0('dns-prefetch', n, null);
  }
  function yb(n, i) {
    Sr.C(n, i), O0('preconnect', n, i);
  }
  function xb(n, i, o) {
    Sr.L(n, i, o);
    var u = hl;
    if (u && n && i) {
      var p = 'link[rel="preload"][as="' + nn(i) + '"]';
      i === 'image' && o && o.imageSrcSet
        ? ((p += '[imagesrcset="' + nn(o.imageSrcSet) + '"]'),
          typeof o.imageSizes == 'string' && (p += '[imagesizes="' + nn(o.imageSizes) + '"]'))
        : (p += '[href="' + nn(n) + '"]');
      var v = p;
      switch (i) {
        case 'style':
          v = fl(n);
          break;
        case 'script':
          v = dl(n);
      }
      ua.has(v) ||
        ((n = x(
          { rel: 'preload', href: i === 'image' && o && o.imageSrcSet ? void 0 : n, as: i },
          o,
        )),
        ua.set(v, n),
        u.querySelector(p) !== null ||
          (i === 'style' && u.querySelector(kc(v))) ||
          (i === 'script' && u.querySelector(Fc(v))) ||
          ((i = u.createElement('link')), oi(i, 'link', n), Ln(i), u.head.appendChild(i)));
    }
  }
  function Sb(n, i) {
    Sr.m(n, i);
    var o = hl;
    if (o && n) {
      var u = i && typeof i.as == 'string' ? i.as : 'script',
        p = 'link[rel="modulepreload"][as="' + nn(u) + '"][href="' + nn(n) + '"]',
        v = p;
      switch (u) {
        case 'audioworklet':
        case 'paintworklet':
        case 'serviceworker':
        case 'sharedworker':
        case 'worker':
        case 'script':
          v = dl(n);
      }
      if (
        !ua.has(v) &&
        ((n = x({ rel: 'modulepreload', href: n }, i)), ua.set(v, n), o.querySelector(p) === null)
      ) {
        switch (u) {
          case 'audioworklet':
          case 'paintworklet':
          case 'serviceworker':
          case 'sharedworker':
          case 'worker':
          case 'script':
            if (o.querySelector(Fc(v))) return;
        }
        (u = o.createElement('link')), oi(u, 'link', n), Ln(u), o.head.appendChild(u);
      }
    }
  }
  function Mb(n, i, o) {
    Sr.S(n, i, o);
    var u = hl;
    if (u && n) {
      var p = va(u).hoistableStyles,
        v = fl(n);
      i = i || 'default';
      var C = p.get(v);
      if (!C) {
        var B = { loading: 0, preload: null };
        if ((C = u.querySelector(kc(v)))) B.loading = 5;
        else {
          (n = x({ rel: 'stylesheet', href: n, 'data-precedence': i }, o)),
            (o = ua.get(v)) && Rp(n, o);
          var Y = (C = u.createElement('link'));
          Ln(Y),
            oi(Y, 'link', n),
            (Y._p = new Promise(function (mt, Rt) {
              (Y.onload = mt), (Y.onerror = Rt);
            })),
            Y.addEventListener('load', function () {
              B.loading |= 1;
            }),
            Y.addEventListener('error', function () {
              B.loading |= 2;
            }),
            (B.loading |= 4),
            Ph(C, i, u);
        }
        (C = { type: 'stylesheet', instance: C, count: 1, state: B }), p.set(v, C);
      }
    }
  }
  function bb(n, i) {
    Sr.X(n, i);
    var o = hl;
    if (o && n) {
      var u = va(o).hoistableScripts,
        p = dl(n),
        v = u.get(p);
      v ||
        ((v = o.querySelector(Fc(p))),
        v ||
          ((n = x({ src: n, async: !0 }, i)),
          (i = ua.get(p)) && Lp(n, i),
          (v = o.createElement('script')),
          Ln(v),
          oi(v, 'link', n),
          o.head.appendChild(v)),
        (v = { type: 'script', instance: v, count: 1, state: null }),
        u.set(p, v));
    }
  }
  function Eb(n, i) {
    Sr.M(n, i);
    var o = hl;
    if (o && n) {
      var u = va(o).hoistableScripts,
        p = dl(n),
        v = u.get(p);
      v ||
        ((v = o.querySelector(Fc(p))),
        v ||
          ((n = x({ src: n, async: !0, type: 'module' }, i)),
          (i = ua.get(p)) && Lp(n, i),
          (v = o.createElement('script')),
          Ln(v),
          oi(v, 'link', n),
          o.head.appendChild(v)),
        (v = { type: 'script', instance: v, count: 1, state: null }),
        u.set(p, v));
    }
  }
  function U0(n, i, o, u) {
    var p = (p = _t.current) ? Lh(p) : null;
    if (!p) throw Error(s(446));
    switch (n) {
      case 'meta':
      case 'title':
        return null;
      case 'style':
        return typeof o.precedence == 'string' && typeof o.href == 'string'
          ? ((i = fl(o.href)),
            (o = va(p).hoistableStyles),
            (u = o.get(i)),
            u || ((u = { type: 'style', instance: null, count: 0, state: null }), o.set(i, u)),
            u)
          : { type: 'void', instance: null, count: 0, state: null };
      case 'link':
        if (
          o.rel === 'stylesheet' &&
          typeof o.href == 'string' &&
          typeof o.precedence == 'string'
        ) {
          n = fl(o.href);
          var v = va(p).hoistableStyles,
            C = v.get(n);
          if (
            (C ||
              ((p = p.ownerDocument || p),
              (C = {
                type: 'stylesheet',
                instance: null,
                count: 0,
                state: { loading: 0, preload: null },
              }),
              v.set(n, C),
              (v = p.querySelector(kc(n))) && !v._p && ((C.instance = v), (C.state.loading = 5)),
              ua.has(n) ||
                ((o = {
                  rel: 'preload',
                  as: 'style',
                  href: o.href,
                  crossOrigin: o.crossOrigin,
                  integrity: o.integrity,
                  media: o.media,
                  hrefLang: o.hrefLang,
                  referrerPolicy: o.referrerPolicy,
                }),
                ua.set(n, o),
                v || Tb(p, n, o, C.state))),
            i && u === null)
          )
            throw Error(s(528, ''));
          return C;
        }
        if (i && u !== null) throw Error(s(529, ''));
        return null;
      case 'script':
        return (
          (i = o.async),
          (o = o.src),
          typeof o == 'string' && i && typeof i != 'function' && typeof i != 'symbol'
            ? ((i = dl(o)),
              (o = va(p).hoistableScripts),
              (u = o.get(i)),
              u || ((u = { type: 'script', instance: null, count: 0, state: null }), o.set(i, u)),
              u)
            : { type: 'void', instance: null, count: 0, state: null }
        );
      default:
        throw Error(s(444, n));
    }
  }
  function fl(n) {
    return 'href="' + nn(n) + '"';
  }
  function kc(n) {
    return 'link[rel="stylesheet"][' + n + ']';
  }
  function N0(n) {
    return x({}, n, { 'data-precedence': n.precedence, precedence: null });
  }
  function Tb(n, i, o, u) {
    n.querySelector('link[rel="preload"][as="style"][' + i + ']')
      ? (u.loading = 1)
      : ((i = n.createElement('link')),
        (u.preload = i),
        i.addEventListener('load', function () {
          return (u.loading |= 1);
        }),
        i.addEventListener('error', function () {
          return (u.loading |= 2);
        }),
        oi(i, 'link', o),
        Ln(i),
        n.head.appendChild(i));
  }
  function dl(n) {
    return '[src="' + nn(n) + '"]';
  }
  function Fc(n) {
    return 'script[async]' + n;
  }
  function z0(n, i, o) {
    if ((i.count++, i.instance === null))
      switch (i.type) {
        case 'style':
          var u = n.querySelector('style[data-href~="' + nn(o.href) + '"]');
          if (u) return (i.instance = u), Ln(u), u;
          var p = x({}, o, {
            'data-href': o.href,
            'data-precedence': o.precedence,
            href: null,
            precedence: null,
          });
          return (
            (u = (n.ownerDocument || n).createElement('style')),
            Ln(u),
            oi(u, 'style', p),
            Ph(u, o.precedence, n),
            (i.instance = u)
          );
        case 'stylesheet':
          p = fl(o.href);
          var v = n.querySelector(kc(p));
          if (v) return (i.state.loading |= 4), (i.instance = v), Ln(v), v;
          (u = N0(o)),
            (p = ua.get(p)) && Rp(u, p),
            (v = (n.ownerDocument || n).createElement('link')),
            Ln(v);
          var C = v;
          return (
            (C._p = new Promise(function (B, Y) {
              (C.onload = B), (C.onerror = Y);
            })),
            oi(v, 'link', u),
            (i.state.loading |= 4),
            Ph(v, o.precedence, n),
            (i.instance = v)
          );
        case 'script':
          return (
            (v = dl(o.src)),
            (p = n.querySelector(Fc(v)))
              ? ((i.instance = p), Ln(p), p)
              : ((u = o),
                (p = ua.get(v)) && ((u = x({}, o)), Lp(u, p)),
                (n = n.ownerDocument || n),
                (p = n.createElement('script')),
                Ln(p),
                oi(p, 'link', u),
                n.head.appendChild(p),
                (i.instance = p))
          );
        case 'void':
          return null;
        default:
          throw Error(s(443, i.type));
      }
    else
      i.type === 'stylesheet' &&
        (i.state.loading & 4) === 0 &&
        ((u = i.instance), (i.state.loading |= 4), Ph(u, o.precedence, n));
    return i.instance;
  }
  function Ph(n, i, o) {
    for (
      var u = o.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),
        p = u.length ? u[u.length - 1] : null,
        v = p,
        C = 0;
      C < u.length;
      C++
    ) {
      var B = u[C];
      if (B.dataset.precedence === i) v = B;
      else if (v !== p) break;
    }
    v
      ? v.parentNode.insertBefore(n, v.nextSibling)
      : ((i = o.nodeType === 9 ? o.head : o), i.insertBefore(n, i.firstChild));
  }
  function Rp(n, i) {
    n.crossOrigin == null && (n.crossOrigin = i.crossOrigin),
      n.referrerPolicy == null && (n.referrerPolicy = i.referrerPolicy),
      n.title == null && (n.title = i.title);
  }
  function Lp(n, i) {
    n.crossOrigin == null && (n.crossOrigin = i.crossOrigin),
      n.referrerPolicy == null && (n.referrerPolicy = i.referrerPolicy),
      n.integrity == null && (n.integrity = i.integrity);
  }
  var Dh = null;
  function I0(n, i, o) {
    if (Dh === null) {
      var u = new Map(),
        p = (Dh = new Map());
      p.set(o, u);
    } else (p = Dh), (u = p.get(o)), u || ((u = new Map()), p.set(o, u));
    if (u.has(n)) return u;
    for (u.set(n, null), o = o.getElementsByTagName(n), p = 0; p < o.length; p++) {
      var v = o[p];
      if (
        !(v[_a] || v[Nn] || (n === 'link' && v.getAttribute('rel') === 'stylesheet')) &&
        v.namespaceURI !== 'http://www.w3.org/2000/svg'
      ) {
        var C = v.getAttribute(i) || '';
        C = n + C;
        var B = u.get(C);
        B ? B.push(v) : u.set(C, [v]);
      }
    }
    return u;
  }
  function B0(n, i, o) {
    (n = n.ownerDocument || n),
      n.head.insertBefore(o, i === 'title' ? n.querySelector('head > title') : null);
  }
  function wb(n, i, o) {
    if (o === 1 || i.itemProp != null) return !1;
    switch (n) {
      case 'meta':
      case 'title':
        return !0;
      case 'style':
        if (typeof i.precedence != 'string' || typeof i.href != 'string' || i.href === '') break;
        return !0;
      case 'link':
        if (
          typeof i.rel != 'string' ||
          typeof i.href != 'string' ||
          i.href === '' ||
          i.onLoad ||
          i.onError
        )
          break;
        switch (i.rel) {
          case 'stylesheet':
            return (n = i.disabled), typeof i.precedence == 'string' && n == null;
          default:
            return !0;
        }
      case 'script':
        if (
          i.async &&
          typeof i.async != 'function' &&
          typeof i.async != 'symbol' &&
          !i.onLoad &&
          !i.onError &&
          i.src &&
          typeof i.src == 'string'
        )
          return !0;
    }
    return !1;
  }
  function k0(n) {
    return !(n.type === 'stylesheet' && (n.state.loading & 3) === 0);
  }
  var Hc = null;
  function Ab() {}
  function Cb(n, i, o) {
    if (Hc === null) throw Error(s(475));
    var u = Hc;
    if (
      i.type === 'stylesheet' &&
      (typeof o.media != 'string' || matchMedia(o.media).matches !== !1) &&
      (i.state.loading & 4) === 0
    ) {
      if (i.instance === null) {
        var p = fl(o.href),
          v = n.querySelector(kc(p));
        if (v) {
          (n = v._p),
            n !== null &&
              typeof n == 'object' &&
              typeof n.then == 'function' &&
              (u.count++, (u = Oh.bind(u)), n.then(u, u)),
            (i.state.loading |= 4),
            (i.instance = v),
            Ln(v);
          return;
        }
        (v = n.ownerDocument || n),
          (o = N0(o)),
          (p = ua.get(p)) && Rp(o, p),
          (v = v.createElement('link')),
          Ln(v);
        var C = v;
        (C._p = new Promise(function (B, Y) {
          (C.onload = B), (C.onerror = Y);
        })),
          oi(v, 'link', o),
          (i.instance = v);
      }
      u.stylesheets === null && (u.stylesheets = new Map()),
        u.stylesheets.set(i, n),
        (n = i.state.preload) &&
          (i.state.loading & 3) === 0 &&
          (u.count++,
          (i = Oh.bind(u)),
          n.addEventListener('load', i),
          n.addEventListener('error', i));
    }
  }
  function Rb() {
    if (Hc === null) throw Error(s(475));
    var n = Hc;
    return (
      n.stylesheets && n.count === 0 && Pp(n, n.stylesheets),
      0 < n.count
        ? function (i) {
            var o = setTimeout(function () {
              if ((n.stylesheets && Pp(n, n.stylesheets), n.unsuspend)) {
                var u = n.unsuspend;
                (n.unsuspend = null), u();
              }
            }, 6e4);
            return (
              (n.unsuspend = i),
              function () {
                (n.unsuspend = null), clearTimeout(o);
              }
            );
          }
        : null
    );
  }
  function Oh() {
    if ((this.count--, this.count === 0)) {
      if (this.stylesheets) Pp(this, this.stylesheets);
      else if (this.unsuspend) {
        var n = this.unsuspend;
        (this.unsuspend = null), n();
      }
    }
  }
  var Uh = null;
  function Pp(n, i) {
    (n.stylesheets = null),
      n.unsuspend !== null &&
        (n.count++, (Uh = new Map()), i.forEach(Lb, n), (Uh = null), Oh.call(n));
  }
  function Lb(n, i) {
    if (!(i.state.loading & 4)) {
      var o = Uh.get(n);
      if (o) var u = o.get(null);
      else {
        (o = new Map()), Uh.set(n, o);
        for (
          var p = n.querySelectorAll('link[data-precedence],style[data-precedence]'), v = 0;
          v < p.length;
          v++
        ) {
          var C = p[v];
          (C.nodeName === 'LINK' || C.getAttribute('media') !== 'not all') &&
            (o.set(C.dataset.precedence, C), (u = C));
        }
        u && o.set(null, u);
      }
      (p = i.instance),
        (C = p.getAttribute('data-precedence')),
        (v = o.get(C) || u),
        v === u && o.set(null, p),
        o.set(C, p),
        this.count++,
        (u = Oh.bind(this)),
        p.addEventListener('load', u),
        p.addEventListener('error', u),
        v
          ? v.parentNode.insertBefore(p, v.nextSibling)
          : ((n = n.nodeType === 9 ? n.head : n), n.insertBefore(p, n.firstChild)),
        (i.state.loading |= 4);
    }
  }
  var Gc = {
    $$typeof: P,
    Provider: null,
    Consumer: null,
    _currentValue: K,
    _currentValue2: K,
    _threadCount: 0,
  };
  function Pb(n, i, o, u, p, v, C, B) {
    (this.tag = 1),
      (this.containerInfo = n),
      (this.pingCache = this.current = this.pendingChildren = null),
      (this.timeoutHandle = -1),
      (this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null),
      (this.callbackPriority = 0),
      (this.expirationTimes = Ct(-1)),
      (this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Ct(0)),
      (this.hiddenUpdates = Ct(null)),
      (this.identifierPrefix = u),
      (this.onUncaughtError = p),
      (this.onCaughtError = v),
      (this.onRecoverableError = C),
      (this.pooledCache = null),
      (this.pooledCacheLanes = 0),
      (this.formState = B),
      (this.incompleteTransitions = new Map());
  }
  function F0(n, i, o, u, p, v, C, B, Y, mt, Rt, Nt) {
    return (
      (n = new Pb(n, i, o, C, B, Y, mt, Nt)),
      (i = 1),
      v === !0 && (i |= 24),
      (v = Ti(3, null, null, i)),
      (n.current = v),
      (v.stateNode = n),
      (i = fd()),
      i.refCount++,
      (n.pooledCache = i),
      i.refCount++,
      (v.memoizedState = { element: u, isDehydrated: o, cache: i }),
      _d(v),
      n
    );
  }
  function H0(n) {
    return n ? ((n = fr), n) : fr;
  }
  function G0(n, i, o, u, p, v) {
    (p = H0(p)),
      u.context === null ? (u.context = p) : (u.pendingContext = p),
      (u = rs(i)),
      (u.payload = { element: o }),
      (v = v === void 0 ? null : v),
      v !== null && (u.callback = v),
      (o = ss(n, u, i)),
      o !== null && (Yi(o, n, i), vc(o, n, i));
  }
  function V0(n, i) {
    if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
      var o = n.retryLane;
      n.retryLane = o !== 0 && o < i ? o : i;
    }
  }
  function Dp(n, i) {
    V0(n, i), (n = n.alternate) && V0(n, i);
  }
  function W0(n) {
    if (n.tag === 13) {
      var i = ts(n, 67108864);
      i !== null && Yi(i, n, 67108864), Dp(n, 67108864);
    }
  }
  var Nh = !0;
  function Db(n, i, o, u) {
    var p = X.T;
    X.T = null;
    var v = it.p;
    try {
      (it.p = 2), Op(n, i, o, u);
    } finally {
      (it.p = v), (X.T = p);
    }
  }
  function Ob(n, i, o, u) {
    var p = X.T;
    X.T = null;
    var v = it.p;
    try {
      (it.p = 8), Op(n, i, o, u);
    } finally {
      (it.p = v), (X.T = p);
    }
  }
  function Op(n, i, o, u) {
    if (Nh) {
      var p = Up(u);
      if (p === null) xp(n, i, u, zh, o), X0(n, u);
      else if (Nb(p, n, i, o, u)) u.stopPropagation();
      else if ((X0(n, u), i & 4 && -1 < Ub.indexOf(n))) {
        for (; p !== null; ) {
          var v = ta(p);
          if (v !== null)
            switch (v.tag) {
              case 3:
                if (((v = v.stateNode), v.current.memoizedState.isDehydrated)) {
                  var C = Qt(v.pendingLanes);
                  if (C !== 0) {
                    var B = v;
                    for (B.pendingLanes |= 2, B.entangledLanes |= 2; C; ) {
                      var Y = 1 << (31 - $t(C));
                      (B.entanglements[1] |= Y), (C &= ~Y);
                    }
                    Va(v), (on & 6) === 0 && ((yh = Ut() + 500), Nc(0));
                  }
                }
                break;
              case 13:
                (B = ts(v, 2)), B !== null && Yi(B, v, 2), Sh(), Dp(v, 2);
            }
          if (((v = Up(u)), v === null && xp(n, i, u, zh, o), v === p)) break;
          p = v;
        }
        p !== null && u.stopPropagation();
      } else xp(n, i, u, null, o);
    }
  }
  function Up(n) {
    return (n = Gr(n)), Np(n);
  }
  var zh = null;
  function Np(n) {
    if (((zh = null), (n = Ii(n)), n !== null)) {
      var i = h(n);
      if (i === null) n = null;
      else {
        var o = i.tag;
        if (o === 13) {
          if (((n = f(i)), n !== null)) return n;
          n = null;
        } else if (o === 3) {
          if (i.stateNode.current.memoizedState.isDehydrated)
            return i.tag === 3 ? i.stateNode.containerInfo : null;
          n = null;
        } else i !== n && (n = null);
      }
    }
    return (zh = n), null;
  }
  function Z0(n) {
    switch (n) {
      case 'beforetoggle':
      case 'cancel':
      case 'click':
      case 'close':
      case 'contextmenu':
      case 'copy':
      case 'cut':
      case 'auxclick':
      case 'dblclick':
      case 'dragend':
      case 'dragstart':
      case 'drop':
      case 'focusin':
      case 'focusout':
      case 'input':
      case 'invalid':
      case 'keydown':
      case 'keypress':
      case 'keyup':
      case 'mousedown':
      case 'mouseup':
      case 'paste':
      case 'pause':
      case 'play':
      case 'pointercancel':
      case 'pointerdown':
      case 'pointerup':
      case 'ratechange':
      case 'reset':
      case 'resize':
      case 'seeked':
      case 'submit':
      case 'toggle':
      case 'touchcancel':
      case 'touchend':
      case 'touchstart':
      case 'volumechange':
      case 'change':
      case 'selectionchange':
      case 'textInput':
      case 'compositionstart':
      case 'compositionend':
      case 'compositionupdate':
      case 'beforeblur':
      case 'afterblur':
      case 'beforeinput':
      case 'blur':
      case 'fullscreenchange':
      case 'focus':
      case 'hashchange':
      case 'popstate':
      case 'select':
      case 'selectstart':
        return 2;
      case 'drag':
      case 'dragenter':
      case 'dragexit':
      case 'dragleave':
      case 'dragover':
      case 'mousemove':
      case 'mouseout':
      case 'mouseover':
      case 'pointermove':
      case 'pointerout':
      case 'pointerover':
      case 'scroll':
      case 'touchmove':
      case 'wheel':
      case 'mouseenter':
      case 'mouseleave':
      case 'pointerenter':
      case 'pointerleave':
        return 8;
      case 'message':
        switch (Lt()) {
          case le:
            return 2;
          case kt:
            return 8;
          case H:
          case O:
            return 32;
          case rt:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var zp = !1,
    ys = null,
    xs = null,
    Ss = null,
    Vc = new Map(),
    Wc = new Map(),
    Ms = [],
    Ub =
      'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset'.split(
        ' ',
      );
  function X0(n, i) {
    switch (n) {
      case 'focusin':
      case 'focusout':
        ys = null;
        break;
      case 'dragenter':
      case 'dragleave':
        xs = null;
        break;
      case 'mouseover':
      case 'mouseout':
        Ss = null;
        break;
      case 'pointerover':
      case 'pointerout':
        Vc.delete(i.pointerId);
        break;
      case 'gotpointercapture':
      case 'lostpointercapture':
        Wc.delete(i.pointerId);
    }
  }
  function Zc(n, i, o, u, p, v) {
    return n === null || n.nativeEvent !== v
      ? ((n = {
          blockedOn: i,
          domEventName: o,
          eventSystemFlags: u,
          nativeEvent: v,
          targetContainers: [p],
        }),
        i !== null && ((i = ta(i)), i !== null && W0(i)),
        n)
      : ((n.eventSystemFlags |= u),
        (i = n.targetContainers),
        p !== null && i.indexOf(p) === -1 && i.push(p),
        n);
  }
  function Nb(n, i, o, u, p) {
    switch (i) {
      case 'focusin':
        return (ys = Zc(ys, n, i, o, u, p)), !0;
      case 'dragenter':
        return (xs = Zc(xs, n, i, o, u, p)), !0;
      case 'mouseover':
        return (Ss = Zc(Ss, n, i, o, u, p)), !0;
      case 'pointerover':
        var v = p.pointerId;
        return Vc.set(v, Zc(Vc.get(v) || null, n, i, o, u, p)), !0;
      case 'gotpointercapture':
        return (v = p.pointerId), Wc.set(v, Zc(Wc.get(v) || null, n, i, o, u, p)), !0;
    }
    return !1;
  }
  function j0(n) {
    var i = Ii(n.target);
    if (i !== null) {
      var o = h(i);
      if (o !== null) {
        if (((i = o.tag), i === 13)) {
          if (((i = f(o)), i !== null)) {
            (n.blockedOn = i),
              ii(n.priority, function () {
                if (o.tag === 13) {
                  var u = qi();
                  u = cn(u);
                  var p = ts(o, u);
                  p !== null && Yi(p, o, u), Dp(o, u);
                }
              });
            return;
          }
        } else if (i === 3 && o.stateNode.current.memoizedState.isDehydrated) {
          n.blockedOn = o.tag === 3 ? o.stateNode.containerInfo : null;
          return;
        }
      }
    }
    n.blockedOn = null;
  }
  function Ih(n) {
    if (n.blockedOn !== null) return !1;
    for (var i = n.targetContainers; 0 < i.length; ) {
      var o = Up(n.nativeEvent);
      if (o === null) {
        o = n.nativeEvent;
        var u = new o.constructor(o.type, o);
        (ks = u), o.target.dispatchEvent(u), (ks = null);
      } else return (i = ta(o)), i !== null && W0(i), (n.blockedOn = o), !1;
      i.shift();
    }
    return !0;
  }
  function q0(n, i, o) {
    Ih(n) && o.delete(i);
  }
  function zb() {
    (zp = !1),
      ys !== null && Ih(ys) && (ys = null),
      xs !== null && Ih(xs) && (xs = null),
      Ss !== null && Ih(Ss) && (Ss = null),
      Vc.forEach(q0),
      Wc.forEach(q0);
  }
  function Bh(n, i) {
    n.blockedOn === i &&
      ((n.blockedOn = null),
      zp || ((zp = !0), a.unstable_scheduleCallback(a.unstable_NormalPriority, zb)));
  }
  var kh = null;
  function Y0(n) {
    kh !== n &&
      ((kh = n),
      a.unstable_scheduleCallback(a.unstable_NormalPriority, function () {
        kh === n && (kh = null);
        for (var i = 0; i < n.length; i += 3) {
          var o = n[i],
            u = n[i + 1],
            p = n[i + 2];
          if (typeof u != 'function') {
            if (Np(u || o) === null) continue;
            break;
          }
          var v = ta(o);
          v !== null &&
            (n.splice(i, 3),
            (i -= 3),
            Nd(v, { pending: !0, data: p, method: o.method, action: u }, u, p));
        }
      }));
  }
  function Xc(n) {
    function i(Y) {
      return Bh(Y, n);
    }
    ys !== null && Bh(ys, n),
      xs !== null && Bh(xs, n),
      Ss !== null && Bh(Ss, n),
      Vc.forEach(i),
      Wc.forEach(i);
    for (var o = 0; o < Ms.length; o++) {
      var u = Ms[o];
      u.blockedOn === n && (u.blockedOn = null);
    }
    for (; 0 < Ms.length && ((o = Ms[0]), o.blockedOn === null); )
      j0(o), o.blockedOn === null && Ms.shift();
    if (((o = (n.ownerDocument || n).$$reactFormReplay), o != null))
      for (u = 0; u < o.length; u += 3) {
        var p = o[u],
          v = o[u + 1],
          C = p[Wn] || null;
        if (typeof v == 'function') C || Y0(o);
        else if (C) {
          var B = null;
          if (v && v.hasAttribute('formAction')) {
            if (((p = v), (C = v[Wn] || null))) B = C.formAction;
            else if (Np(p) !== null) continue;
          } else B = C.action;
          typeof B == 'function' ? (o[u + 1] = B) : (o.splice(u, 3), (u -= 3)), Y0(o);
        }
      }
  }
  function Ip(n) {
    this._internalRoot = n;
  }
  (Fh.prototype.render = Ip.prototype.render =
    function (n) {
      var i = this._internalRoot;
      if (i === null) throw Error(s(409));
      var o = i.current,
        u = qi();
      G0(o, u, n, i, null, null);
    }),
    (Fh.prototype.unmount = Ip.prototype.unmount =
      function () {
        var n = this._internalRoot;
        if (n !== null) {
          this._internalRoot = null;
          var i = n.containerInfo;
          G0(n.current, 2, null, n, null, null), Sh(), (i[ui] = null);
        }
      });
  function Fh(n) {
    this._internalRoot = n;
  }
  Fh.prototype.unstable_scheduleHydration = function (n) {
    if (n) {
      var i = Ye();
      n = { blockedOn: null, target: n, priority: i };
      for (var o = 0; o < Ms.length && i !== 0 && i < Ms[o].priority; o++);
      Ms.splice(o, 0, n), o === 0 && j0(n);
    }
  };
  var K0 = t.version;
  if (K0 !== '19.1.0') throw Error(s(527, K0, '19.1.0'));
  it.findDOMNode = function (n) {
    var i = n._reactInternals;
    if (i === void 0)
      throw typeof n.render == 'function'
        ? Error(s(188))
        : ((n = Object.keys(n).join(',')), Error(s(268, n)));
    return (n = _(i)), (n = n !== null ? g(n) : null), (n = n === null ? null : n.stateNode), n;
  };
  var Ib = {
    bundleType: 0,
    version: '19.1.0',
    rendererPackageName: 'react-dom',
    currentDispatcherRef: X,
    reconcilerVersion: '19.1.0',
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
    var Hh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Hh.isDisabled && Hh.supportsFiber)
      try {
        (Et = Hh.inject(Ib)), (Xt = Hh);
      } catch {}
  }
  return (
    (qc.createRoot = function (n, i) {
      if (!l(n)) throw Error(s(299));
      var o = !1,
        u = '',
        p = fv,
        v = dv,
        C = pv,
        B = null;
      return (
        i != null &&
          (i.unstable_strictMode === !0 && (o = !0),
          i.identifierPrefix !== void 0 && (u = i.identifierPrefix),
          i.onUncaughtError !== void 0 && (p = i.onUncaughtError),
          i.onCaughtError !== void 0 && (v = i.onCaughtError),
          i.onRecoverableError !== void 0 && (C = i.onRecoverableError),
          i.unstable_transitionCallbacks !== void 0 && (B = i.unstable_transitionCallbacks)),
        (i = F0(n, 1, !1, null, null, o, u, p, v, C, B, null)),
        (n[ui] = i.current),
        yp(n),
        new Ip(i)
      );
    }),
    (qc.hydrateRoot = function (n, i, o) {
      if (!l(n)) throw Error(s(299));
      var u = !1,
        p = '',
        v = fv,
        C = dv,
        B = pv,
        Y = null,
        mt = null;
      return (
        o != null &&
          (o.unstable_strictMode === !0 && (u = !0),
          o.identifierPrefix !== void 0 && (p = o.identifierPrefix),
          o.onUncaughtError !== void 0 && (v = o.onUncaughtError),
          o.onCaughtError !== void 0 && (C = o.onCaughtError),
          o.onRecoverableError !== void 0 && (B = o.onRecoverableError),
          o.unstable_transitionCallbacks !== void 0 && (Y = o.unstable_transitionCallbacks),
          o.formState !== void 0 && (mt = o.formState)),
        (i = F0(n, 1, !0, i, o ?? null, u, p, v, C, B, Y, mt)),
        (i.context = H0(null)),
        (o = i.current),
        (u = qi()),
        (u = cn(u)),
        (p = rs(u)),
        (p.callback = null),
        ss(o, p, u),
        (o = u),
        (i.current.lanes = o),
        Ot(i, o),
        Va(i),
        (n[ui] = i.current),
        yp(n),
        new Fh(i)
      );
    }),
    (qc.version = '19.1.0'),
    qc
  );
}
var oy;
function jb() {
  if (oy) return Fp.exports;
  oy = 1;
  function a() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(a);
      } catch (t) {
        console.error(t);
      }
  }
  return a(), (Fp.exports = Xb()), Fp.exports;
}
var qb = jb(),
  Yc = {},
  ly;
function Yb() {
  if (ly) return Yc;
  (ly = 1),
    Object.defineProperty(Yc, '__esModule', { value: !0 }),
    (Yc.parse = f),
    (Yc.serialize = g);
  const a = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
    t = /^[\u0021-\u003A\u003C-\u007E]*$/,
    e = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    s = /^[\u0020-\u003A\u003D-\u007E]*$/,
    l = Object.prototype.toString,
    h = (() => {
      const b = function () {};
      return (b.prototype = Object.create(null)), b;
    })();
  function f(b, E) {
    const A = new h(),
      R = b.length;
    if (R < 2) return A;
    const T = (E == null ? void 0 : E.decode) || x;
    let M = 0;
    do {
      const z = b.indexOf('=', M);
      if (z === -1) break;
      const P = b.indexOf(';', M),
        D = P === -1 ? R : P;
      if (z > D) {
        M = b.lastIndexOf(';', z - 1) + 1;
        continue;
      }
      const W = m(b, M, z),
        Z = _(b, z, W),
        V = b.slice(W, Z);
      if (A[V] === void 0) {
        let J = m(b, z + 1, D),
          F = _(b, D, J);
        const I = T(b.slice(J, F));
        A[V] = I;
      }
      M = D + 1;
    } while (M < R);
    return A;
  }
  function m(b, E, A) {
    do {
      const R = b.charCodeAt(E);
      if (R !== 32 && R !== 9) return E;
    } while (++E < A);
    return A;
  }
  function _(b, E, A) {
    for (; E > A; ) {
      const R = b.charCodeAt(--E);
      if (R !== 32 && R !== 9) return E + 1;
    }
    return A;
  }
  function g(b, E, A) {
    const R = (A == null ? void 0 : A.encode) || encodeURIComponent;
    if (!a.test(b)) throw new TypeError(`argument name is invalid: ${b}`);
    const T = R(E);
    if (!t.test(T)) throw new TypeError(`argument val is invalid: ${E}`);
    let M = b + '=' + T;
    if (!A) return M;
    if (A.maxAge !== void 0) {
      if (!Number.isInteger(A.maxAge)) throw new TypeError(`option maxAge is invalid: ${A.maxAge}`);
      M += '; Max-Age=' + A.maxAge;
    }
    if (A.domain) {
      if (!e.test(A.domain)) throw new TypeError(`option domain is invalid: ${A.domain}`);
      M += '; Domain=' + A.domain;
    }
    if (A.path) {
      if (!s.test(A.path)) throw new TypeError(`option path is invalid: ${A.path}`);
      M += '; Path=' + A.path;
    }
    if (A.expires) {
      if (!S(A.expires) || !Number.isFinite(A.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${A.expires}`);
      M += '; Expires=' + A.expires.toUTCString();
    }
    if (
      (A.httpOnly && (M += '; HttpOnly'),
      A.secure && (M += '; Secure'),
      A.partitioned && (M += '; Partitioned'),
      A.priority)
    )
      switch (typeof A.priority == 'string' ? A.priority.toLowerCase() : void 0) {
        case 'low':
          M += '; Priority=Low';
          break;
        case 'medium':
          M += '; Priority=Medium';
          break;
        case 'high':
          M += '; Priority=High';
          break;
        default:
          throw new TypeError(`option priority is invalid: ${A.priority}`);
      }
    if (A.sameSite)
      switch (typeof A.sameSite == 'string' ? A.sameSite.toLowerCase() : A.sameSite) {
        case !0:
        case 'strict':
          M += '; SameSite=Strict';
          break;
        case 'lax':
          M += '; SameSite=Lax';
          break;
        case 'none':
          M += '; SameSite=None';
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${A.sameSite}`);
      }
    return M;
  }
  function x(b) {
    if (b.indexOf('%') === -1) return b;
    try {
      return decodeURIComponent(b);
    } catch {
      return b;
    }
  }
  function S(b) {
    return l.call(b) === '[object Date]';
  }
  return Yc;
}
Yb();
var cy = 'popstate';
function Kb(a = {}) {
  function t(s, l) {
    let { pathname: h, search: f, hash: m } = s.location;
    return Om(
      '',
      { pathname: h, search: f, hash: m },
      (l.state && l.state.usr) || null,
      (l.state && l.state.key) || 'default',
    );
  }
  function e(s, l) {
    return typeof l == 'string' ? l : cu(l);
  }
  return Jb(t, e, null, a);
}
function Cn(a, t) {
  if (a === !1 || a === null || typeof a > 'u') throw new Error(t);
}
function Ya(a, t) {
  if (!a) {
    typeof console < 'u' && console.warn(t);
    try {
      throw new Error(t);
    } catch {}
  }
}
function Qb() {
  return Math.random().toString(36).substring(2, 10);
}
function uy(a, t) {
  return { usr: a.state, key: a.key, idx: t };
}
function Om(a, t, e = null, s) {
  return {
    pathname: typeof a == 'string' ? a : a.pathname,
    search: '',
    hash: '',
    ...(typeof t == 'string' ? Zl(t) : t),
    state: e,
    key: (t && t.key) || s || Qb(),
  };
}
function cu({ pathname: a = '/', search: t = '', hash: e = '' }) {
  return (
    t && t !== '?' && (a += t.charAt(0) === '?' ? t : '?' + t),
    e && e !== '#' && (a += e.charAt(0) === '#' ? e : '#' + e),
    a
  );
}
function Zl(a) {
  let t = {};
  if (a) {
    let e = a.indexOf('#');
    e >= 0 && ((t.hash = a.substring(e)), (a = a.substring(0, e)));
    let s = a.indexOf('?');
    s >= 0 && ((t.search = a.substring(s)), (a = a.substring(0, s))), a && (t.pathname = a);
  }
  return t;
}
function Jb(a, t, e, s = {}) {
  let { window: l = document.defaultView, v5Compat: h = !1 } = s,
    f = l.history,
    m = 'POP',
    _ = null,
    g = x();
  g == null && ((g = 0), f.replaceState({ ...f.state, idx: g }, ''));
  function x() {
    return (f.state || { idx: null }).idx;
  }
  function S() {
    m = 'POP';
    let T = x(),
      M = T == null ? null : T - g;
    (g = T), _ && _({ action: m, location: R.location, delta: M });
  }
  function b(T, M) {
    m = 'PUSH';
    let z = Om(R.location, T, M);
    g = x() + 1;
    let P = uy(z, g),
      D = R.createHref(z);
    try {
      f.pushState(P, '', D);
    } catch (W) {
      if (W instanceof DOMException && W.name === 'DataCloneError') throw W;
      l.location.assign(D);
    }
    h && _ && _({ action: m, location: R.location, delta: 1 });
  }
  function E(T, M) {
    m = 'REPLACE';
    let z = Om(R.location, T, M);
    g = x();
    let P = uy(z, g),
      D = R.createHref(z);
    f.replaceState(P, '', D), h && _ && _({ action: m, location: R.location, delta: 0 });
  }
  function A(T) {
    return $b(T);
  }
  let R = {
    get action() {
      return m;
    },
    get location() {
      return a(l, f);
    },
    listen(T) {
      if (_) throw new Error('A history only accepts one active listener');
      return (
        l.addEventListener(cy, S),
        (_ = T),
        () => {
          l.removeEventListener(cy, S), (_ = null);
        }
      );
    },
    createHref(T) {
      return t(l, T);
    },
    createURL: A,
    encodeLocation(T) {
      let M = A(T);
      return { pathname: M.pathname, search: M.search, hash: M.hash };
    },
    push: b,
    replace: E,
    go(T) {
      return f.go(T);
    },
  };
  return R;
}
function $b(a, t = !1) {
  let e = 'http://localhost';
  typeof window < 'u' &&
    (e = window.location.origin !== 'null' ? window.location.origin : window.location.href),
    Cn(e, 'No window.location.(origin|href) available to create URL');
  let s = typeof a == 'string' ? a : cu(a);
  return (s = s.replace(/ $/, '%20')), !t && s.startsWith('//') && (s = e + s), new URL(s, e);
}
function Yx(a, t, e = '/') {
  return tE(a, t, e, !1);
}
function tE(a, t, e, s) {
  let l = typeof t == 'string' ? Zl(t) : t,
    h = Br(l.pathname || '/', e);
  if (h == null) return null;
  let f = Kx(a);
  eE(f);
  let m = null;
  for (let _ = 0; m == null && _ < f.length; ++_) {
    let g = fE(h);
    m = uE(f[_], g, s);
  }
  return m;
}
function Kx(a, t = [], e = [], s = '') {
  let l = (h, f, m) => {
    let _ = {
      relativePath: m === void 0 ? h.path || '' : m,
      caseSensitive: h.caseSensitive === !0,
      childrenIndex: f,
      route: h,
    };
    _.relativePath.startsWith('/') &&
      (Cn(
        _.relativePath.startsWith(s),
        `Absolute route path "${_.relativePath}" nested under path "${s}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`,
      ),
      (_.relativePath = _.relativePath.slice(s.length)));
    let g = zr([s, _.relativePath]),
      x = e.concat(_);
    h.children &&
      h.children.length > 0 &&
      (Cn(
        h.index !== !0,
        `Index routes must not have child routes. Please remove all child routes from route path "${g}".`,
      ),
      Kx(h.children, t, x, g)),
      !(h.path == null && !h.index) && t.push({ path: g, score: lE(g, h.index), routesMeta: x });
  };
  return (
    a.forEach((h, f) => {
      var m;
      if (h.path === '' || !((m = h.path) != null && m.includes('?'))) l(h, f);
      else for (let _ of Qx(h.path)) l(h, f, _);
    }),
    t
  );
}
function Qx(a) {
  let t = a.split('/');
  if (t.length === 0) return [];
  let [e, ...s] = t,
    l = e.endsWith('?'),
    h = e.replace(/\?$/, '');
  if (s.length === 0) return l ? [h, ''] : [h];
  let f = Qx(s.join('/')),
    m = [];
  return (
    m.push(...f.map((_) => (_ === '' ? h : [h, _].join('/')))),
    l && m.push(...f),
    m.map((_) => (a.startsWith('/') && _ === '' ? '/' : _))
  );
}
function eE(a) {
  a.sort((t, e) =>
    t.score !== e.score
      ? e.score - t.score
      : cE(
          t.routesMeta.map((s) => s.childrenIndex),
          e.routesMeta.map((s) => s.childrenIndex),
        ),
  );
}
var nE = /^:[\w-]+$/,
  iE = 3,
  aE = 2,
  rE = 1,
  sE = 10,
  oE = -2,
  hy = (a) => a === '*';
function lE(a, t) {
  let e = a.split('/'),
    s = e.length;
  return (
    e.some(hy) && (s += oE),
    t && (s += aE),
    e.filter((l) => !hy(l)).reduce((l, h) => l + (nE.test(h) ? iE : h === '' ? rE : sE), s)
  );
}
function cE(a, t) {
  return a.length === t.length && a.slice(0, -1).every((s, l) => s === t[l])
    ? a[a.length - 1] - t[t.length - 1]
    : 0;
}
function uE(a, t, e = !1) {
  let { routesMeta: s } = a,
    l = {},
    h = '/',
    f = [];
  for (let m = 0; m < s.length; ++m) {
    let _ = s[m],
      g = m === s.length - 1,
      x = h === '/' ? t : t.slice(h.length) || '/',
      S = Of({ path: _.relativePath, caseSensitive: _.caseSensitive, end: g }, x),
      b = _.route;
    if (
      (!S &&
        g &&
        e &&
        !s[s.length - 1].route.index &&
        (S = Of({ path: _.relativePath, caseSensitive: _.caseSensitive, end: !1 }, x)),
      !S)
    )
      return null;
    Object.assign(l, S.params),
      f.push({
        params: l,
        pathname: zr([h, S.pathname]),
        pathnameBase: _E(zr([h, S.pathnameBase])),
        route: b,
      }),
      S.pathnameBase !== '/' && (h = zr([h, S.pathnameBase]));
  }
  return f;
}
function Of(a, t) {
  typeof a == 'string' && (a = { path: a, caseSensitive: !1, end: !0 });
  let [e, s] = hE(a.path, a.caseSensitive, a.end),
    l = t.match(e);
  if (!l) return null;
  let h = l[0],
    f = h.replace(/(.)\/+$/, '$1'),
    m = l.slice(1);
  return {
    params: s.reduce((g, { paramName: x, isOptional: S }, b) => {
      if (x === '*') {
        let A = m[b] || '';
        f = h.slice(0, h.length - A.length).replace(/(.)\/+$/, '$1');
      }
      const E = m[b];
      return S && !E ? (g[x] = void 0) : (g[x] = (E || '').replace(/%2F/g, '/')), g;
    }, {}),
    pathname: h,
    pathnameBase: f,
    pattern: a,
  };
}
function hE(a, t = !1, e = !0) {
  Ya(
    a === '*' || !a.endsWith('*') || a.endsWith('/*'),
    `Route path "${a}" will be treated as if it were "${a.replace(/\*$/, '/*')}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${a.replace(/\*$/, '/*')}".`,
  );
  let s = [],
    l =
      '^' +
      a
        .replace(/\/*\*?$/, '')
        .replace(/^\/*/, '/')
        .replace(/[\\.*+^${}|()[\]]/g, '\\$&')
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (f, m, _) => (
            s.push({ paramName: m, isOptional: _ != null }), _ ? '/?([^\\/]+)?' : '/([^\\/]+)'
          ),
        );
  return (
    a.endsWith('*')
      ? (s.push({ paramName: '*' }), (l += a === '*' || a === '/*' ? '(.*)$' : '(?:\\/(.+)|\\/*)$'))
      : e
        ? (l += '\\/*$')
        : a !== '' && a !== '/' && (l += '(?:(?=\\/|$))'),
    [new RegExp(l, t ? void 0 : 'i'), s]
  );
}
function fE(a) {
  try {
    return a
      .split('/')
      .map((t) => decodeURIComponent(t).replace(/\//g, '%2F'))
      .join('/');
  } catch (t) {
    return (
      Ya(
        !1,
        `The URL path "${a}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`,
      ),
      a
    );
  }
}
function Br(a, t) {
  if (t === '/') return a;
  if (!a.toLowerCase().startsWith(t.toLowerCase())) return null;
  let e = t.endsWith('/') ? t.length - 1 : t.length,
    s = a.charAt(e);
  return s && s !== '/' ? null : a.slice(e) || '/';
}
function dE(a, t = '/') {
  let { pathname: e, search: s = '', hash: l = '' } = typeof a == 'string' ? Zl(a) : a;
  return { pathname: e ? (e.startsWith('/') ? e : pE(e, t)) : t, search: gE(s), hash: vE(l) };
}
function pE(a, t) {
  let e = t.replace(/\/+$/, '').split('/');
  return (
    a.split('/').forEach((l) => {
      l === '..' ? e.length > 1 && e.pop() : l !== '.' && e.push(l);
    }),
    e.length > 1 ? e.join('/') : '/'
  );
}
function Wp(a, t, e, s) {
  return `Cannot include a '${a}' character in a manually specified \`to.${t}\` field [${JSON.stringify(s)}].  Please separate it out to the \`to.${e}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function mE(a) {
  return a.filter((t, e) => e === 0 || (t.route.path && t.route.path.length > 0));
}
function Jx(a) {
  let t = mE(a);
  return t.map((e, s) => (s === t.length - 1 ? e.pathname : e.pathnameBase));
}
function $x(a, t, e, s = !1) {
  let l;
  typeof a == 'string'
    ? (l = Zl(a))
    : ((l = { ...a }),
      Cn(!l.pathname || !l.pathname.includes('?'), Wp('?', 'pathname', 'search', l)),
      Cn(!l.pathname || !l.pathname.includes('#'), Wp('#', 'pathname', 'hash', l)),
      Cn(!l.search || !l.search.includes('#'), Wp('#', 'search', 'hash', l)));
  let h = a === '' || l.pathname === '',
    f = h ? '/' : l.pathname,
    m;
  if (f == null) m = e;
  else {
    let S = t.length - 1;
    if (!s && f.startsWith('..')) {
      let b = f.split('/');
      for (; b[0] === '..'; ) b.shift(), (S -= 1);
      l.pathname = b.join('/');
    }
    m = S >= 0 ? t[S] : '/';
  }
  let _ = dE(l, m),
    g = f && f !== '/' && f.endsWith('/'),
    x = (h || f === '.') && e.endsWith('/');
  return !_.pathname.endsWith('/') && (g || x) && (_.pathname += '/'), _;
}
var zr = (a) => a.join('/').replace(/\/\/+/g, '/'),
  _E = (a) => a.replace(/\/+$/, '').replace(/^\/*/, '/'),
  gE = (a) => (!a || a === '?' ? '' : a.startsWith('?') ? a : '?' + a),
  vE = (a) => (!a || a === '#' ? '' : a.startsWith('#') ? a : '#' + a);
function yE(a) {
  return (
    a != null &&
    typeof a.status == 'number' &&
    typeof a.statusText == 'string' &&
    typeof a.internal == 'boolean' &&
    'data' in a
  );
}
var tS = ['POST', 'PUT', 'PATCH', 'DELETE'];
new Set(tS);
var xE = ['GET', ...tS];
new Set(xE);
var Xl = ot.createContext(null);
Xl.displayName = 'DataRouter';
var Hf = ot.createContext(null);
Hf.displayName = 'DataRouterState';
var eS = ot.createContext({ isTransitioning: !1 });
eS.displayName = 'ViewTransition';
var SE = ot.createContext(new Map());
SE.displayName = 'Fetchers';
var ME = ot.createContext(null);
ME.displayName = 'Await';
var Ja = ot.createContext(null);
Ja.displayName = 'Navigation';
var Su = ot.createContext(null);
Su.displayName = 'Location';
var $a = ot.createContext({ outlet: null, matches: [], isDataRoute: !1 });
$a.displayName = 'Route';
var O_ = ot.createContext(null);
O_.displayName = 'RouteError';
function bE(a, { relative: t } = {}) {
  Cn(Mu(), 'useHref() may be used only in the context of a <Router> component.');
  let { basename: e, navigator: s } = ot.useContext(Ja),
    { hash: l, pathname: h, search: f } = bu(a, { relative: t }),
    m = h;
  return (
    e !== '/' && (m = h === '/' ? e : zr([e, h])), s.createHref({ pathname: m, search: f, hash: l })
  );
}
function Mu() {
  return ot.useContext(Su) != null;
}
function wo() {
  return (
    Cn(Mu(), 'useLocation() may be used only in the context of a <Router> component.'),
    ot.useContext(Su).location
  );
}
var nS =
  'You should call navigate() in a React.useEffect(), not when your component is first rendered.';
function iS(a) {
  ot.useContext(Ja).static || ot.useLayoutEffect(a);
}
function Ao() {
  let { isDataRoute: a } = ot.useContext($a);
  return a ? zE() : EE();
}
function EE() {
  Cn(Mu(), 'useNavigate() may be used only in the context of a <Router> component.');
  let a = ot.useContext(Xl),
    { basename: t, navigator: e } = ot.useContext(Ja),
    { matches: s } = ot.useContext($a),
    { pathname: l } = wo(),
    h = JSON.stringify(Jx(s)),
    f = ot.useRef(!1);
  return (
    iS(() => {
      f.current = !0;
    }),
    ot.useCallback(
      (_, g = {}) => {
        if ((Ya(f.current, nS), !f.current)) return;
        if (typeof _ == 'number') {
          e.go(_);
          return;
        }
        let x = $x(_, JSON.parse(h), l, g.relative === 'path');
        a == null && t !== '/' && (x.pathname = x.pathname === '/' ? t : zr([t, x.pathname])),
          (g.replace ? e.replace : e.push)(x, g.state, g);
      },
      [t, e, h, l, a],
    )
  );
}
ot.createContext(null);
function aS() {
  let { matches: a } = ot.useContext($a),
    t = a[a.length - 1];
  return t ? t.params : {};
}
function bu(a, { relative: t } = {}) {
  let { matches: e } = ot.useContext($a),
    { pathname: s } = wo(),
    l = JSON.stringify(Jx(e));
  return ot.useMemo(() => $x(a, JSON.parse(l), s, t === 'path'), [a, l, s, t]);
}
function TE(a, t) {
  return rS(a, t);
}
function rS(a, t, e, s) {
  var M;
  Cn(Mu(), 'useRoutes() may be used only in the context of a <Router> component.');
  let { navigator: l } = ot.useContext(Ja),
    { matches: h } = ot.useContext($a),
    f = h[h.length - 1],
    m = f ? f.params : {},
    _ = f ? f.pathname : '/',
    g = f ? f.pathnameBase : '/',
    x = f && f.route;
  {
    let z = (x && x.path) || '';
    sS(
      _,
      !x || z.endsWith('*') || z.endsWith('*?'),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${_}" (under <Route path="${z}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${z}"> to <Route path="${z === '/' ? '*' : `${z}/*`}">.`,
    );
  }
  let S = wo(),
    b;
  if (t) {
    let z = typeof t == 'string' ? Zl(t) : t;
    Cn(
      g === '/' || ((M = z.pathname) == null ? void 0 : M.startsWith(g)),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${g}" but pathname "${z.pathname}" was given in the \`location\` prop.`,
    ),
      (b = z);
  } else b = S;
  let E = b.pathname || '/',
    A = E;
  if (g !== '/') {
    let z = g.replace(/^\//, '').split('/');
    A = '/' + E.replace(/^\//, '').split('/').slice(z.length).join('/');
  }
  let R = Yx(a, { pathname: A });
  Ya(x || R != null, `No routes matched location "${b.pathname}${b.search}${b.hash}" `),
    Ya(
      R == null ||
        R[R.length - 1].route.element !== void 0 ||
        R[R.length - 1].route.Component !== void 0 ||
        R[R.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${b.pathname}${b.search}${b.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`,
    );
  let T = LE(
    R &&
      R.map((z) =>
        Object.assign({}, z, {
          params: Object.assign({}, m, z.params),
          pathname: zr([g, l.encodeLocation ? l.encodeLocation(z.pathname).pathname : z.pathname]),
          pathnameBase:
            z.pathnameBase === '/'
              ? g
              : zr([
                  g,
                  l.encodeLocation ? l.encodeLocation(z.pathnameBase).pathname : z.pathnameBase,
                ]),
        }),
      ),
    h,
    e,
    s,
  );
  return t && T
    ? ot.createElement(
        Su.Provider,
        {
          value: {
            location: { pathname: '/', search: '', hash: '', state: null, key: 'default', ...b },
            navigationType: 'POP',
          },
        },
        T,
      )
    : T;
}
function wE() {
  let a = NE(),
    t = yE(a) ? `${a.status} ${a.statusText}` : a instanceof Error ? a.message : JSON.stringify(a),
    e = a instanceof Error ? a.stack : null,
    s = 'rgba(200,200,200, 0.5)',
    l = { padding: '0.5rem', backgroundColor: s },
    h = { padding: '2px 4px', backgroundColor: s },
    f = null;
  return (
    console.error('Error handled by React Router default ErrorBoundary:', a),
    (f = ot.createElement(
      ot.Fragment,
      null,
      ot.createElement('p', null, '💿 Hey developer 👋'),
      ot.createElement(
        'p',
        null,
        'You can provide a way better UX than this when your app throws errors by providing your own ',
        ot.createElement('code', { style: h }, 'ErrorBoundary'),
        ' or',
        ' ',
        ot.createElement('code', { style: h }, 'errorElement'),
        ' prop on your route.',
      ),
    )),
    ot.createElement(
      ot.Fragment,
      null,
      ot.createElement('h2', null, 'Unexpected Application Error!'),
      ot.createElement('h3', { style: { fontStyle: 'italic' } }, t),
      e ? ot.createElement('pre', { style: l }, e) : null,
      f,
    )
  );
}
var AE = ot.createElement(wE, null),
  CE = class extends ot.Component {
    constructor(a) {
      super(a),
        (this.state = { location: a.location, revalidation: a.revalidation, error: a.error });
    }
    static getDerivedStateFromError(a) {
      return { error: a };
    }
    static getDerivedStateFromProps(a, t) {
      return t.location !== a.location || (t.revalidation !== 'idle' && a.revalidation === 'idle')
        ? { error: a.error, location: a.location, revalidation: a.revalidation }
        : {
            error: a.error !== void 0 ? a.error : t.error,
            location: t.location,
            revalidation: a.revalidation || t.revalidation,
          };
    }
    componentDidCatch(a, t) {
      console.error('React Router caught the following error during render', a, t);
    }
    render() {
      return this.state.error !== void 0
        ? ot.createElement(
            $a.Provider,
            { value: this.props.routeContext },
            ot.createElement(O_.Provider, {
              value: this.state.error,
              children: this.props.component,
            }),
          )
        : this.props.children;
    }
  };
function RE({ routeContext: a, match: t, children: e }) {
  let s = ot.useContext(Xl);
  return (
    s &&
      s.static &&
      s.staticContext &&
      (t.route.errorElement || t.route.ErrorBoundary) &&
      (s.staticContext._deepestRenderedBoundaryId = t.route.id),
    ot.createElement($a.Provider, { value: a }, e)
  );
}
function LE(a, t = [], e = null, s = null) {
  if (a == null) {
    if (!e) return null;
    if (e.errors) a = e.matches;
    else if (t.length === 0 && !e.initialized && e.matches.length > 0) a = e.matches;
    else return null;
  }
  let l = a,
    h = e == null ? void 0 : e.errors;
  if (h != null) {
    let _ = l.findIndex((g) => g.route.id && (h == null ? void 0 : h[g.route.id]) !== void 0);
    Cn(
      _ >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(h).join(',')}`,
    ),
      (l = l.slice(0, Math.min(l.length, _ + 1)));
  }
  let f = !1,
    m = -1;
  if (e)
    for (let _ = 0; _ < l.length; _++) {
      let g = l[_];
      if (((g.route.HydrateFallback || g.route.hydrateFallbackElement) && (m = _), g.route.id)) {
        let { loaderData: x, errors: S } = e,
          b = g.route.loader && !x.hasOwnProperty(g.route.id) && (!S || S[g.route.id] === void 0);
        if (g.route.lazy || b) {
          (f = !0), m >= 0 ? (l = l.slice(0, m + 1)) : (l = [l[0]]);
          break;
        }
      }
    }
  return l.reduceRight((_, g, x) => {
    let S,
      b = !1,
      E = null,
      A = null;
    e &&
      ((S = h && g.route.id ? h[g.route.id] : void 0),
      (E = g.route.errorElement || AE),
      f &&
        (m < 0 && x === 0
          ? (sS(
              'route-fallback',
              !1,
              'No `HydrateFallback` element provided to render during initial hydration',
            ),
            (b = !0),
            (A = null))
          : m === x && ((b = !0), (A = g.route.hydrateFallbackElement || null))));
    let R = t.concat(l.slice(0, x + 1)),
      T = () => {
        let M;
        return (
          S
            ? (M = E)
            : b
              ? (M = A)
              : g.route.Component
                ? (M = ot.createElement(g.route.Component, null))
                : g.route.element
                  ? (M = g.route.element)
                  : (M = _),
          ot.createElement(RE, {
            match: g,
            routeContext: { outlet: _, matches: R, isDataRoute: e != null },
            children: M,
          })
        );
      };
    return e && (g.route.ErrorBoundary || g.route.errorElement || x === 0)
      ? ot.createElement(CE, {
          location: e.location,
          revalidation: e.revalidation,
          component: E,
          error: S,
          children: T(),
          routeContext: { outlet: null, matches: R, isDataRoute: !0 },
        })
      : T();
  }, null);
}
function U_(a) {
  return `${a} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function PE(a) {
  let t = ot.useContext(Xl);
  return Cn(t, U_(a)), t;
}
function DE(a) {
  let t = ot.useContext(Hf);
  return Cn(t, U_(a)), t;
}
function OE(a) {
  let t = ot.useContext($a);
  return Cn(t, U_(a)), t;
}
function N_(a) {
  let t = OE(a),
    e = t.matches[t.matches.length - 1];
  return Cn(e.route.id, `${a} can only be used on routes that contain a unique "id"`), e.route.id;
}
function UE() {
  return N_('useRouteId');
}
function NE() {
  var s;
  let a = ot.useContext(O_),
    t = DE('useRouteError'),
    e = N_('useRouteError');
  return a !== void 0 ? a : (s = t.errors) == null ? void 0 : s[e];
}
function zE() {
  let { router: a } = PE('useNavigate'),
    t = N_('useNavigate'),
    e = ot.useRef(!1);
  return (
    iS(() => {
      e.current = !0;
    }),
    ot.useCallback(
      async (l, h = {}) => {
        Ya(e.current, nS),
          e.current &&
            (typeof l == 'number' ? a.navigate(l) : await a.navigate(l, { fromRouteId: t, ...h }));
      },
      [a, t],
    )
  );
}
var fy = {};
function sS(a, t, e) {
  !t && !fy[a] && ((fy[a] = !0), Ya(!1, e));
}
ot.memo(IE);
function IE({ routes: a, future: t, state: e }) {
  return rS(a, void 0, e, t);
}
function Cl(a) {
  Cn(
    !1,
    'A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.',
  );
}
function BE({
  basename: a = '/',
  children: t = null,
  location: e,
  navigationType: s = 'POP',
  navigator: l,
  static: h = !1,
}) {
  Cn(
    !Mu(),
    'You cannot render a <Router> inside another <Router>. You should never have more than one in your app.',
  );
  let f = a.replace(/^\/*/, '/'),
    m = ot.useMemo(() => ({ basename: f, navigator: l, static: h, future: {} }), [f, l, h]);
  typeof e == 'string' && (e = Zl(e));
  let { pathname: _ = '/', search: g = '', hash: x = '', state: S = null, key: b = 'default' } = e,
    E = ot.useMemo(() => {
      let A = Br(_, f);
      return A == null
        ? null
        : { location: { pathname: A, search: g, hash: x, state: S, key: b }, navigationType: s };
    }, [f, _, g, x, S, b, s]);
  return (
    Ya(
      E != null,
      `<Router basename="${f}"> is not able to match the URL "${_}${g}${x}" because it does not start with the basename, so the <Router> won't render anything.`,
    ),
    E == null
      ? null
      : ot.createElement(
          Ja.Provider,
          { value: m },
          ot.createElement(Su.Provider, { children: t, value: E }),
        )
  );
}
function kE({ children: a, location: t }) {
  return TE(Um(a), t);
}
function Um(a, t = []) {
  let e = [];
  return (
    ot.Children.forEach(a, (s, l) => {
      if (!ot.isValidElement(s)) return;
      let h = [...t, l];
      if (s.type === ot.Fragment) {
        e.push.apply(e, Um(s.props.children, h));
        return;
      }
      Cn(
        s.type === Cl,
        `[${typeof s.type == 'string' ? s.type : s.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`,
      ),
        Cn(!s.props.index || !s.props.children, 'An index route cannot have child routes.');
      let f = {
        id: s.props.id || h.join('-'),
        caseSensitive: s.props.caseSensitive,
        element: s.props.element,
        Component: s.props.Component,
        index: s.props.index,
        path: s.props.path,
        loader: s.props.loader,
        action: s.props.action,
        hydrateFallbackElement: s.props.hydrateFallbackElement,
        HydrateFallback: s.props.HydrateFallback,
        errorElement: s.props.errorElement,
        ErrorBoundary: s.props.ErrorBoundary,
        hasErrorBoundary:
          s.props.hasErrorBoundary === !0 ||
          s.props.ErrorBoundary != null ||
          s.props.errorElement != null,
        shouldRevalidate: s.props.shouldRevalidate,
        handle: s.props.handle,
        lazy: s.props.lazy,
      };
      s.props.children && (f.children = Um(s.props.children, h)), e.push(f);
    }),
    e
  );
}
var yf = 'get',
  xf = 'application/x-www-form-urlencoded';
function Gf(a) {
  return a != null && typeof a.tagName == 'string';
}
function FE(a) {
  return Gf(a) && a.tagName.toLowerCase() === 'button';
}
function HE(a) {
  return Gf(a) && a.tagName.toLowerCase() === 'form';
}
function GE(a) {
  return Gf(a) && a.tagName.toLowerCase() === 'input';
}
function VE(a) {
  return !!(a.metaKey || a.altKey || a.ctrlKey || a.shiftKey);
}
function WE(a, t) {
  return a.button === 0 && (!t || t === '_self') && !VE(a);
}
var Gh = null;
function ZE() {
  if (Gh === null)
    try {
      new FormData(document.createElement('form'), 0), (Gh = !1);
    } catch {
      Gh = !0;
    }
  return Gh;
}
var XE = new Set(['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain']);
function Zp(a) {
  return a != null && !XE.has(a)
    ? (Ya(
        !1,
        `"${a}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${xf}"`,
      ),
      null)
    : a;
}
function jE(a, t) {
  let e, s, l, h, f;
  if (HE(a)) {
    let m = a.getAttribute('action');
    (s = m ? Br(m, t) : null),
      (e = a.getAttribute('method') || yf),
      (l = Zp(a.getAttribute('enctype')) || xf),
      (h = new FormData(a));
  } else if (FE(a) || (GE(a) && (a.type === 'submit' || a.type === 'image'))) {
    let m = a.form;
    if (m == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let _ = a.getAttribute('formaction') || m.getAttribute('action');
    if (
      ((s = _ ? Br(_, t) : null),
      (e = a.getAttribute('formmethod') || m.getAttribute('method') || yf),
      (l = Zp(a.getAttribute('formenctype')) || Zp(m.getAttribute('enctype')) || xf),
      (h = new FormData(m, a)),
      !ZE())
    ) {
      let { name: g, type: x, value: S } = a;
      if (x === 'image') {
        let b = g ? `${g}.` : '';
        h.append(`${b}x`, '0'), h.append(`${b}y`, '0');
      } else g && h.append(g, S);
    }
  } else {
    if (Gf(a))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">',
      );
    (e = yf), (s = null), (l = xf), (f = a);
  }
  return (
    h && l === 'text/plain' && ((f = h), (h = void 0)),
    { action: s, method: e.toLowerCase(), encType: l, formData: h, body: f }
  );
}
function z_(a, t) {
  if (a === !1 || a === null || typeof a > 'u') throw new Error(t);
}
async function qE(a, t) {
  if (a.id in t) return t[a.id];
  try {
    let e = await import(a.module);
    return (t[a.id] = e), e;
  } catch (e) {
    return (
      console.error(`Error loading route module \`${a.module}\`, reloading page...`),
      console.error(e),
      window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
      window.location.reload(),
      new Promise(() => {})
    );
  }
}
function YE(a) {
  return a == null
    ? !1
    : a.href == null
      ? a.rel === 'preload' && typeof a.imageSrcSet == 'string' && typeof a.imageSizes == 'string'
      : typeof a.rel == 'string' && typeof a.href == 'string';
}
async function KE(a, t, e) {
  let s = await Promise.all(
    a.map(async (l) => {
      let h = t.routes[l.route.id];
      if (h) {
        let f = await qE(h, e);
        return f.links ? f.links() : [];
      }
      return [];
    }),
  );
  return t1(
    s
      .flat(1)
      .filter(YE)
      .filter((l) => l.rel === 'stylesheet' || l.rel === 'preload')
      .map((l) =>
        l.rel === 'stylesheet' ? { ...l, rel: 'prefetch', as: 'style' } : { ...l, rel: 'prefetch' },
      ),
  );
}
function dy(a, t, e, s, l, h) {
  let f = (_, g) => (e[g] ? _.route.id !== e[g].route.id : !0),
    m = (_, g) => {
      var x;
      return (
        e[g].pathname !== _.pathname ||
        (((x = e[g].route.path) == null ? void 0 : x.endsWith('*')) &&
          e[g].params['*'] !== _.params['*'])
      );
    };
  return h === 'assets'
    ? t.filter((_, g) => f(_, g) || m(_, g))
    : h === 'data'
      ? t.filter((_, g) => {
          var S;
          let x = s.routes[_.route.id];
          if (!x || !x.hasLoader) return !1;
          if (f(_, g) || m(_, g)) return !0;
          if (_.route.shouldRevalidate) {
            let b = _.route.shouldRevalidate({
              currentUrl: new URL(l.pathname + l.search + l.hash, window.origin),
              currentParams: ((S = e[0]) == null ? void 0 : S.params) || {},
              nextUrl: new URL(a, window.origin),
              nextParams: _.params,
              defaultShouldRevalidate: !0,
            });
            if (typeof b == 'boolean') return b;
          }
          return !0;
        })
      : [];
}
function QE(a, t, { includeHydrateFallback: e } = {}) {
  return JE(
    a
      .map((s) => {
        let l = t.routes[s.route.id];
        if (!l) return [];
        let h = [l.module];
        return (
          l.clientActionModule && (h = h.concat(l.clientActionModule)),
          l.clientLoaderModule && (h = h.concat(l.clientLoaderModule)),
          e && l.hydrateFallbackModule && (h = h.concat(l.hydrateFallbackModule)),
          l.imports && (h = h.concat(l.imports)),
          h
        );
      })
      .flat(1),
  );
}
function JE(a) {
  return [...new Set(a)];
}
function $E(a) {
  let t = {},
    e = Object.keys(a).sort();
  for (let s of e) t[s] = a[s];
  return t;
}
function t1(a, t) {
  let e = new Set();
  return (
    new Set(t),
    a.reduce((s, l) => {
      let h = JSON.stringify($E(l));
      return e.has(h) || (e.add(h), s.push({ key: h, link: l })), s;
    }, [])
  );
}
Object.getOwnPropertyNames(Object.prototype).sort().join('\0');
var e1 = new Set([100, 101, 204, 205]);
function n1(a, t) {
  let e =
    typeof a == 'string'
      ? new URL(a, typeof window > 'u' ? 'server://singlefetch/' : window.location.origin)
      : a;
  return (
    e.pathname === '/'
      ? (e.pathname = '_root.data')
      : t && Br(e.pathname, t) === '/'
        ? (e.pathname = `${t.replace(/\/$/, '')}/_root.data`)
        : (e.pathname = `${e.pathname.replace(/\/$/, '')}.data`),
    e
  );
}
function oS() {
  let a = ot.useContext(Xl);
  return z_(a, 'You must render this element inside a <DataRouterContext.Provider> element'), a;
}
function i1() {
  let a = ot.useContext(Hf);
  return (
    z_(a, 'You must render this element inside a <DataRouterStateContext.Provider> element'), a
  );
}
var I_ = ot.createContext(void 0);
I_.displayName = 'FrameworkContext';
function lS() {
  let a = ot.useContext(I_);
  return z_(a, 'You must render this element inside a <HydratedRouter> element'), a;
}
function a1(a, t) {
  let e = ot.useContext(I_),
    [s, l] = ot.useState(!1),
    [h, f] = ot.useState(!1),
    { onFocus: m, onBlur: _, onMouseEnter: g, onMouseLeave: x, onTouchStart: S } = t,
    b = ot.useRef(null);
  ot.useEffect(() => {
    if ((a === 'render' && f(!0), a === 'viewport')) {
      let R = (M) => {
          M.forEach((z) => {
            f(z.isIntersecting);
          });
        },
        T = new IntersectionObserver(R, { threshold: 0.5 });
      return (
        b.current && T.observe(b.current),
        () => {
          T.disconnect();
        }
      );
    }
  }, [a]),
    ot.useEffect(() => {
      if (s) {
        let R = setTimeout(() => {
          f(!0);
        }, 100);
        return () => {
          clearTimeout(R);
        };
      }
    }, [s]);
  let E = () => {
      l(!0);
    },
    A = () => {
      l(!1), f(!1);
    };
  return e
    ? a !== 'intent'
      ? [h, b, {}]
      : [
          h,
          b,
          {
            onFocus: Kc(m, E),
            onBlur: Kc(_, A),
            onMouseEnter: Kc(g, E),
            onMouseLeave: Kc(x, A),
            onTouchStart: Kc(S, E),
          },
        ]
    : [!1, b, {}];
}
function Kc(a, t) {
  return (e) => {
    a && a(e), e.defaultPrevented || t(e);
  };
}
function r1({ page: a, ...t }) {
  let { router: e } = oS(),
    s = ot.useMemo(() => Yx(e.routes, a, e.basename), [e.routes, a, e.basename]);
  return s ? ot.createElement(o1, { page: a, matches: s, ...t }) : null;
}
function s1(a) {
  let { manifest: t, routeModules: e } = lS(),
    [s, l] = ot.useState([]);
  return (
    ot.useEffect(() => {
      let h = !1;
      return (
        KE(a, t, e).then((f) => {
          h || l(f);
        }),
        () => {
          h = !0;
        }
      );
    }, [a, t, e]),
    s
  );
}
function o1({ page: a, matches: t, ...e }) {
  let s = wo(),
    { manifest: l, routeModules: h } = lS(),
    { basename: f } = oS(),
    { loaderData: m, matches: _ } = i1(),
    g = ot.useMemo(() => dy(a, t, _, l, s, 'data'), [a, t, _, l, s]),
    x = ot.useMemo(() => dy(a, t, _, l, s, 'assets'), [a, t, _, l, s]),
    S = ot.useMemo(() => {
      if (a === s.pathname + s.search + s.hash) return [];
      let A = new Set(),
        R = !1;
      if (
        (t.forEach((M) => {
          var P;
          let z = l.routes[M.route.id];
          !z ||
            !z.hasLoader ||
            ((!g.some((D) => D.route.id === M.route.id) &&
              M.route.id in m &&
              (P = h[M.route.id]) != null &&
              P.shouldRevalidate) ||
            z.hasClientLoader
              ? (R = !0)
              : A.add(M.route.id));
        }),
        A.size === 0)
      )
        return [];
      let T = n1(a, f);
      return (
        R &&
          A.size > 0 &&
          T.searchParams.set(
            '_routes',
            t
              .filter((M) => A.has(M.route.id))
              .map((M) => M.route.id)
              .join(','),
          ),
        [T.pathname + T.search]
      );
    }, [f, m, s, l, g, t, a, h]),
    b = ot.useMemo(() => QE(x, l), [x, l]),
    E = s1(x);
  return ot.createElement(
    ot.Fragment,
    null,
    S.map((A) => ot.createElement('link', { key: A, rel: 'prefetch', as: 'fetch', href: A, ...e })),
    b.map((A) => ot.createElement('link', { key: A, rel: 'modulepreload', href: A, ...e })),
    E.map(({ key: A, link: R }) => ot.createElement('link', { key: A, ...R })),
  );
}
function l1(...a) {
  return (t) => {
    a.forEach((e) => {
      typeof e == 'function' ? e(t) : e != null && (e.current = t);
    });
  };
}
var cS =
  typeof window < 'u' && typeof window.document < 'u' && typeof window.document.createElement < 'u';
try {
  cS && (window.__reactRouterVersion = '7.6.2');
} catch {}
function c1({ basename: a, children: t, window: e }) {
  let s = ot.useRef();
  s.current == null && (s.current = Kb({ window: e, v5Compat: !0 }));
  let l = s.current,
    [h, f] = ot.useState({ action: l.action, location: l.location }),
    m = ot.useCallback(
      (_) => {
        ot.startTransition(() => f(_));
      },
      [f],
    );
  return (
    ot.useLayoutEffect(() => l.listen(m), [l, m]),
    ot.createElement(BE, {
      basename: a,
      children: t,
      location: h.location,
      navigationType: h.action,
      navigator: l,
    })
  );
}
var uS = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  hS = ot.forwardRef(function (
    {
      onClick: t,
      discover: e = 'render',
      prefetch: s = 'none',
      relative: l,
      reloadDocument: h,
      replace: f,
      state: m,
      target: _,
      to: g,
      preventScrollReset: x,
      viewTransition: S,
      ...b
    },
    E,
  ) {
    let { basename: A } = ot.useContext(Ja),
      R = typeof g == 'string' && uS.test(g),
      T,
      M = !1;
    if (typeof g == 'string' && R && ((T = g), cS))
      try {
        let F = new URL(window.location.href),
          I = g.startsWith('//') ? new URL(F.protocol + g) : new URL(g),
          j = Br(I.pathname, A);
        I.origin === F.origin && j != null ? (g = j + I.search + I.hash) : (M = !0);
      } catch {
        Ya(
          !1,
          `<Link to="${g}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`,
        );
      }
    let z = bE(g, { relative: l }),
      [P, D, W] = a1(s, b),
      Z = d1(g, {
        replace: f,
        state: m,
        target: _,
        preventScrollReset: x,
        relative: l,
        viewTransition: S,
      });
    function V(F) {
      t && t(F), F.defaultPrevented || Z(F);
    }
    let J = ot.createElement('a', {
      ...b,
      ...W,
      href: T || z,
      onClick: M || h ? t : V,
      ref: l1(E, D),
      target: _,
      'data-discover': !R && e === 'render' ? 'true' : void 0,
    });
    return P && !R ? ot.createElement(ot.Fragment, null, J, ot.createElement(r1, { page: z })) : J;
  });
hS.displayName = 'Link';
var u1 = ot.forwardRef(function (
  {
    'aria-current': t = 'page',
    caseSensitive: e = !1,
    className: s = '',
    end: l = !1,
    style: h,
    to: f,
    viewTransition: m,
    children: _,
    ...g
  },
  x,
) {
  let S = bu(f, { relative: g.relative }),
    b = wo(),
    E = ot.useContext(Hf),
    { navigator: A, basename: R } = ot.useContext(Ja),
    T = E != null && v1(S) && m === !0,
    M = A.encodeLocation ? A.encodeLocation(S).pathname : S.pathname,
    z = b.pathname,
    P = E && E.navigation && E.navigation.location ? E.navigation.location.pathname : null;
  e || ((z = z.toLowerCase()), (P = P ? P.toLowerCase() : null), (M = M.toLowerCase())),
    P && R && (P = Br(P, R) || P);
  const D = M !== '/' && M.endsWith('/') ? M.length - 1 : M.length;
  let W = z === M || (!l && z.startsWith(M) && z.charAt(D) === '/'),
    Z = P != null && (P === M || (!l && P.startsWith(M) && P.charAt(M.length) === '/')),
    V = { isActive: W, isPending: Z, isTransitioning: T },
    J = W ? t : void 0,
    F;
  typeof s == 'function'
    ? (F = s(V))
    : (F = [s, W ? 'active' : null, Z ? 'pending' : null, T ? 'transitioning' : null]
        .filter(Boolean)
        .join(' '));
  let I = typeof h == 'function' ? h(V) : h;
  return ot.createElement(
    hS,
    { ...g, 'aria-current': J, className: F, ref: x, style: I, to: f, viewTransition: m },
    typeof _ == 'function' ? _(V) : _,
  );
});
u1.displayName = 'NavLink';
var h1 = ot.forwardRef(
  (
    {
      discover: a = 'render',
      fetcherKey: t,
      navigate: e,
      reloadDocument: s,
      replace: l,
      state: h,
      method: f = yf,
      action: m,
      onSubmit: _,
      relative: g,
      preventScrollReset: x,
      viewTransition: S,
      ...b
    },
    E,
  ) => {
    let A = _1(),
      R = g1(m, { relative: g }),
      T = f.toLowerCase() === 'get' ? 'get' : 'post',
      M = typeof m == 'string' && uS.test(m),
      z = (P) => {
        if ((_ && _(P), P.defaultPrevented)) return;
        P.preventDefault();
        let D = P.nativeEvent.submitter,
          W = (D == null ? void 0 : D.getAttribute('formmethod')) || f;
        A(D || P.currentTarget, {
          fetcherKey: t,
          method: W,
          navigate: e,
          replace: l,
          state: h,
          relative: g,
          preventScrollReset: x,
          viewTransition: S,
        });
      };
    return ot.createElement('form', {
      ref: E,
      method: T,
      action: R,
      onSubmit: s ? _ : z,
      ...b,
      'data-discover': !M && a === 'render' ? 'true' : void 0,
    });
  },
);
h1.displayName = 'Form';
function f1(a) {
  return `${a} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function fS(a) {
  let t = ot.useContext(Xl);
  return Cn(t, f1(a)), t;
}
function d1(
  a,
  { target: t, replace: e, state: s, preventScrollReset: l, relative: h, viewTransition: f } = {},
) {
  let m = Ao(),
    _ = wo(),
    g = bu(a, { relative: h });
  return ot.useCallback(
    (x) => {
      if (WE(x, t)) {
        x.preventDefault();
        let S = e !== void 0 ? e : cu(_) === cu(g);
        m(a, { replace: S, state: s, preventScrollReset: l, relative: h, viewTransition: f });
      }
    },
    [_, m, g, e, s, t, a, l, h, f],
  );
}
var p1 = 0,
  m1 = () => `__${String(++p1)}__`;
function _1() {
  let { router: a } = fS('useSubmit'),
    { basename: t } = ot.useContext(Ja),
    e = UE();
  return ot.useCallback(
    async (s, l = {}) => {
      let { action: h, method: f, encType: m, formData: _, body: g } = jE(s, t);
      if (l.navigate === !1) {
        let x = l.fetcherKey || m1();
        await a.fetch(x, e, l.action || h, {
          preventScrollReset: l.preventScrollReset,
          formData: _,
          body: g,
          formMethod: l.method || f,
          formEncType: l.encType || m,
          flushSync: l.flushSync,
        });
      } else
        await a.navigate(l.action || h, {
          preventScrollReset: l.preventScrollReset,
          formData: _,
          body: g,
          formMethod: l.method || f,
          formEncType: l.encType || m,
          replace: l.replace,
          state: l.state,
          fromRouteId: e,
          flushSync: l.flushSync,
          viewTransition: l.viewTransition,
        });
    },
    [a, t, e],
  );
}
function g1(a, { relative: t } = {}) {
  let { basename: e } = ot.useContext(Ja),
    s = ot.useContext($a);
  Cn(s, 'useFormAction must be used inside a RouteContext');
  let [l] = s.matches.slice(-1),
    h = { ...bu(a || '.', { relative: t }) },
    f = wo();
  if (a == null) {
    h.search = f.search;
    let m = new URLSearchParams(h.search),
      _ = m.getAll('index');
    if (_.some((x) => x === '')) {
      m.delete('index'), _.filter((S) => S).forEach((S) => m.append('index', S));
      let x = m.toString();
      h.search = x ? `?${x}` : '';
    }
  }
  return (
    (!a || a === '.') &&
      l.route.index &&
      (h.search = h.search ? h.search.replace(/^\?/, '?index&') : '?index'),
    e !== '/' && (h.pathname = h.pathname === '/' ? e : zr([e, h.pathname])),
    cu(h)
  );
}
function v1(a, t = {}) {
  let e = ot.useContext(eS);
  Cn(
    e != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?",
  );
  let { basename: s } = fS('useViewTransitionState'),
    l = bu(a, { relative: t.relative });
  if (!e.isTransitioning) return !1;
  let h = Br(e.currentLocation.pathname, s) || e.currentLocation.pathname,
    f = Br(e.nextLocation.pathname, s) || e.nextLocation.pathname;
  return Of(l.pathname, f) != null || Of(l.pathname, h) != null;
}
[...e1];
var y1 = qx();
function Nm() {
  return (
    (Nm = Object.assign
      ? Object.assign.bind()
      : function (a) {
          for (var t = 1; t < arguments.length; t++) {
            var e = arguments[t];
            for (var s in e) ({}).hasOwnProperty.call(e, s) && (a[s] = e[s]);
          }
          return a;
        }),
    Nm.apply(null, arguments)
  );
}
function x1(a) {
  if (a.sheet) return a.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === a) return document.styleSheets[t];
}
function S1(a) {
  var t = document.createElement('style');
  return (
    t.setAttribute('data-emotion', a.key),
    a.nonce !== void 0 && t.setAttribute('nonce', a.nonce),
    t.appendChild(document.createTextNode('')),
    t.setAttribute('data-s', ''),
    t
  );
}
var M1 = (function () {
    function a(e) {
      var s = this;
      (this._insertTag = function (l) {
        var h;
        s.tags.length === 0
          ? s.insertionPoint
            ? (h = s.insertionPoint.nextSibling)
            : s.prepend
              ? (h = s.container.firstChild)
              : (h = s.before)
          : (h = s.tags[s.tags.length - 1].nextSibling),
          s.container.insertBefore(l, h),
          s.tags.push(l);
      }),
        (this.isSpeedy = e.speedy === void 0 ? !0 : e.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = e.nonce),
        (this.key = e.key),
        (this.container = e.container),
        (this.prepend = e.prepend),
        (this.insertionPoint = e.insertionPoint),
        (this.before = null);
    }
    var t = a.prototype;
    return (
      (t.hydrate = function (s) {
        s.forEach(this._insertTag);
      }),
      (t.insert = function (s) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(S1(this));
        var l = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var h = x1(l);
          try {
            h.insertRule(s, h.cssRules.length);
          } catch {}
        } else l.appendChild(document.createTextNode(s));
        this.ctr++;
      }),
      (t.flush = function () {
        this.tags.forEach(function (s) {
          var l;
          return (l = s.parentNode) == null ? void 0 : l.removeChild(s);
        }),
          (this.tags = []),
          (this.ctr = 0);
      }),
      a
    );
  })(),
  gi = '-ms-',
  Uf = '-moz-',
  an = '-webkit-',
  dS = 'comm',
  B_ = 'rule',
  k_ = 'decl',
  b1 = '@import',
  pS = '@keyframes',
  E1 = '@layer',
  T1 = Math.abs,
  Vf = String.fromCharCode,
  w1 = Object.assign;
function A1(a, t) {
  return li(a, 0) ^ 45
    ? (((((((t << 2) ^ li(a, 0)) << 2) ^ li(a, 1)) << 2) ^ li(a, 2)) << 2) ^ li(a, 3)
    : 0;
}
function mS(a) {
  return a.trim();
}
function C1(a, t) {
  return (a = t.exec(a)) ? a[0] : a;
}
function rn(a, t, e) {
  return a.replace(t, e);
}
function zm(a, t) {
  return a.indexOf(t);
}
function li(a, t) {
  return a.charCodeAt(t) | 0;
}
function uu(a, t, e) {
  return a.slice(t, e);
}
function Wa(a) {
  return a.length;
}
function F_(a) {
  return a.length;
}
function Vh(a, t) {
  return t.push(a), a;
}
function R1(a, t) {
  return a.map(t).join('');
}
var Wf = 1,
  Bl = 1,
  _S = 0,
  zi = 0,
  Vn = 0,
  jl = '';
function Zf(a, t, e, s, l, h, f) {
  return {
    value: a,
    root: t,
    parent: e,
    type: s,
    props: l,
    children: h,
    line: Wf,
    column: Bl,
    length: f,
    return: '',
  };
}
function Qc(a, t) {
  return w1(Zf('', null, null, '', null, null, 0), a, { length: -a.length }, t);
}
function L1() {
  return Vn;
}
function P1() {
  return (Vn = zi > 0 ? li(jl, --zi) : 0), Bl--, Vn === 10 && ((Bl = 1), Wf--), Vn;
}
function Ji() {
  return (Vn = zi < _S ? li(jl, zi++) : 0), Bl++, Vn === 10 && ((Bl = 1), Wf++), Vn;
}
function qa() {
  return li(jl, zi);
}
function Sf() {
  return zi;
}
function Eu(a, t) {
  return uu(jl, a, t);
}
function hu(a) {
  switch (a) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function gS(a) {
  return (Wf = Bl = 1), (_S = Wa((jl = a))), (zi = 0), [];
}
function vS(a) {
  return (jl = ''), a;
}
function Mf(a) {
  return mS(Eu(zi - 1, Im(a === 91 ? a + 2 : a === 40 ? a + 1 : a)));
}
function D1(a) {
  for (; (Vn = qa()) && Vn < 33; ) Ji();
  return hu(a) > 2 || hu(Vn) > 3 ? '' : ' ';
}
function O1(a, t) {
  for (; --t && Ji() && !(Vn < 48 || Vn > 102 || (Vn > 57 && Vn < 65) || (Vn > 70 && Vn < 97)); );
  return Eu(a, Sf() + (t < 6 && qa() == 32 && Ji() == 32));
}
function Im(a) {
  for (; Ji(); )
    switch (Vn) {
      case a:
        return zi;
      case 34:
      case 39:
        a !== 34 && a !== 39 && Im(Vn);
        break;
      case 40:
        a === 41 && Im(a);
        break;
      case 92:
        Ji();
        break;
    }
  return zi;
}
function U1(a, t) {
  for (; Ji() && a + Vn !== 57; ) if (a + Vn === 84 && qa() === 47) break;
  return '/*' + Eu(t, zi - 1) + '*' + Vf(a === 47 ? a : Ji());
}
function N1(a) {
  for (; !hu(qa()); ) Ji();
  return Eu(a, zi);
}
function z1(a) {
  return vS(bf('', null, null, null, [''], (a = gS(a)), 0, [0], a));
}
function bf(a, t, e, s, l, h, f, m, _) {
  for (
    var g = 0,
      x = 0,
      S = f,
      b = 0,
      E = 0,
      A = 0,
      R = 1,
      T = 1,
      M = 1,
      z = 0,
      P = '',
      D = l,
      W = h,
      Z = s,
      V = P;
    T;

  )
    switch (((A = z), (z = Ji()))) {
      case 40:
        if (A != 108 && li(V, S - 1) == 58) {
          zm((V += rn(Mf(z), '&', '&\f')), '&\f') != -1 && (M = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        V += Mf(z);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        V += D1(A);
        break;
      case 92:
        V += O1(Sf() - 1, 7);
        continue;
      case 47:
        switch (qa()) {
          case 42:
          case 47:
            Vh(I1(U1(Ji(), Sf()), t, e), _);
            break;
          default:
            V += '/';
        }
        break;
      case 123 * R:
        m[g++] = Wa(V) * M;
      case 125 * R:
      case 59:
      case 0:
        switch (z) {
          case 0:
          case 125:
            T = 0;
          case 59 + x:
            M == -1 && (V = rn(V, /\f/g, '')),
              E > 0 &&
                Wa(V) - S &&
                Vh(E > 32 ? my(V + ';', s, e, S - 1) : my(rn(V, ' ', '') + ';', s, e, S - 2), _);
            break;
          case 59:
            V += ';';
          default:
            if ((Vh((Z = py(V, t, e, g, x, l, m, P, (D = []), (W = []), S)), h), z === 123))
              if (x === 0) bf(V, t, Z, Z, D, h, S, m, W);
              else
                switch (b === 99 && li(V, 3) === 110 ? 100 : b) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    bf(
                      a,
                      Z,
                      Z,
                      s && Vh(py(a, Z, Z, 0, 0, l, m, P, l, (D = []), S), W),
                      l,
                      W,
                      S,
                      m,
                      s ? D : W,
                    );
                    break;
                  default:
                    bf(V, Z, Z, Z, [''], W, 0, m, W);
                }
        }
        (g = x = E = 0), (R = M = 1), (P = V = ''), (S = f);
        break;
      case 58:
        (S = 1 + Wa(V)), (E = A);
      default:
        if (R < 1) {
          if (z == 123) --R;
          else if (z == 125 && R++ == 0 && P1() == 125) continue;
        }
        switch (((V += Vf(z)), z * R)) {
          case 38:
            M = x > 0 ? 1 : ((V += '\f'), -1);
            break;
          case 44:
            (m[g++] = (Wa(V) - 1) * M), (M = 1);
            break;
          case 64:
            qa() === 45 && (V += Mf(Ji())), (b = qa()), (x = S = Wa((P = V += N1(Sf())))), z++;
            break;
          case 45:
            A === 45 && Wa(V) == 2 && (R = 0);
        }
    }
  return h;
}
function py(a, t, e, s, l, h, f, m, _, g, x) {
  for (var S = l - 1, b = l === 0 ? h : [''], E = F_(b), A = 0, R = 0, T = 0; A < s; ++A)
    for (var M = 0, z = uu(a, S + 1, (S = T1((R = f[A])))), P = a; M < E; ++M)
      (P = mS(R > 0 ? b[M] + ' ' + z : rn(z, /&\f/g, b[M]))) && (_[T++] = P);
  return Zf(a, t, e, l === 0 ? B_ : m, _, g, x);
}
function I1(a, t, e) {
  return Zf(a, t, e, dS, Vf(L1()), uu(a, 2, -2), 0);
}
function my(a, t, e, s) {
  return Zf(a, t, e, k_, uu(a, 0, s), uu(a, s + 1, -1), s);
}
function Ol(a, t) {
  for (var e = '', s = F_(a), l = 0; l < s; l++) e += t(a[l], l, a, t) || '';
  return e;
}
function B1(a, t, e, s) {
  switch (a.type) {
    case E1:
      if (a.children.length) break;
    case b1:
    case k_:
      return (a.return = a.return || a.value);
    case dS:
      return '';
    case pS:
      return (a.return = a.value + '{' + Ol(a.children, s) + '}');
    case B_:
      a.value = a.props.join(',');
  }
  return Wa((e = Ol(a.children, s))) ? (a.return = a.value + '{' + e + '}') : '';
}
function k1(a) {
  var t = F_(a);
  return function (e, s, l, h) {
    for (var f = '', m = 0; m < t; m++) f += a[m](e, s, l, h) || '';
    return f;
  };
}
function F1(a) {
  return function (t) {
    t.root || ((t = t.return) && a(t));
  };
}
function yS(a) {
  var t = Object.create(null);
  return function (e) {
    return t[e] === void 0 && (t[e] = a(e)), t[e];
  };
}
var H1 = function (t, e, s) {
    for (var l = 0, h = 0; (l = h), (h = qa()), l === 38 && h === 12 && (e[s] = 1), !hu(h); ) Ji();
    return Eu(t, zi);
  },
  G1 = function (t, e) {
    var s = -1,
      l = 44;
    do
      switch (hu(l)) {
        case 0:
          l === 38 && qa() === 12 && (e[s] = 1), (t[s] += H1(zi - 1, e, s));
          break;
        case 2:
          t[s] += Mf(l);
          break;
        case 4:
          if (l === 44) {
            (t[++s] = qa() === 58 ? '&\f' : ''), (e[s] = t[s].length);
            break;
          }
        default:
          t[s] += Vf(l);
      }
    while ((l = Ji()));
    return t;
  },
  V1 = function (t, e) {
    return vS(G1(gS(t), e));
  },
  _y = new WeakMap(),
  W1 = function (t) {
    if (!(t.type !== 'rule' || !t.parent || t.length < 1)) {
      for (
        var e = t.value, s = t.parent, l = t.column === s.column && t.line === s.line;
        s.type !== 'rule';

      )
        if (((s = s.parent), !s)) return;
      if (!(t.props.length === 1 && e.charCodeAt(0) !== 58 && !_y.get(s)) && !l) {
        _y.set(t, !0);
        for (var h = [], f = V1(e, h), m = s.props, _ = 0, g = 0; _ < f.length; _++)
          for (var x = 0; x < m.length; x++, g++)
            t.props[g] = h[_] ? f[_].replace(/&\f/g, m[x]) : m[x] + ' ' + f[_];
      }
    }
  },
  Z1 = function (t) {
    if (t.type === 'decl') {
      var e = t.value;
      e.charCodeAt(0) === 108 && e.charCodeAt(2) === 98 && ((t.return = ''), (t.value = ''));
    }
  };
function xS(a, t) {
  switch (A1(a, t)) {
    case 5103:
      return an + 'print-' + a + a;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return an + a + a;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return an + a + Uf + a + gi + a + a;
    case 6828:
    case 4268:
      return an + a + gi + a + a;
    case 6165:
      return an + a + gi + 'flex-' + a + a;
    case 5187:
      return an + a + rn(a, /(\w+).+(:[^]+)/, an + 'box-$1$2' + gi + 'flex-$1$2') + a;
    case 5443:
      return an + a + gi + 'flex-item-' + rn(a, /flex-|-self/, '') + a;
    case 4675:
      return an + a + gi + 'flex-line-pack' + rn(a, /align-content|flex-|-self/, '') + a;
    case 5548:
      return an + a + gi + rn(a, 'shrink', 'negative') + a;
    case 5292:
      return an + a + gi + rn(a, 'basis', 'preferred-size') + a;
    case 6060:
      return an + 'box-' + rn(a, '-grow', '') + an + a + gi + rn(a, 'grow', 'positive') + a;
    case 4554:
      return an + rn(a, /([^-])(transform)/g, '$1' + an + '$2') + a;
    case 6187:
      return rn(rn(rn(a, /(zoom-|grab)/, an + '$1'), /(image-set)/, an + '$1'), a, '') + a;
    case 5495:
    case 3959:
      return rn(a, /(image-set\([^]*)/, an + '$1$`$1');
    case 4968:
      return (
        rn(
          rn(a, /(.+:)(flex-)?(.*)/, an + 'box-pack:$3' + gi + 'flex-pack:$3'),
          /s.+-b[^;]+/,
          'justify',
        ) +
        an +
        a +
        a
      );
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return rn(a, /(.+)-inline(.+)/, an + '$1$2') + a;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Wa(a) - 1 - t > 6)
        switch (li(a, t + 1)) {
          case 109:
            if (li(a, t + 4) !== 45) break;
          case 102:
            return (
              rn(
                a,
                /(.+:)(.+)-([^]+)/,
                '$1' + an + '$2-$3$1' + Uf + (li(a, t + 3) == 108 ? '$3' : '$2-$3'),
              ) + a
            );
          case 115:
            return ~zm(a, 'stretch') ? xS(rn(a, 'stretch', 'fill-available'), t) + a : a;
        }
      break;
    case 4949:
      if (li(a, t + 1) !== 115) break;
    case 6444:
      switch (li(a, Wa(a) - 3 - (~zm(a, '!important') && 10))) {
        case 107:
          return rn(a, ':', ':' + an) + a;
        case 101:
          return (
            rn(
              a,
              /(.+:)([^;!]+)(;|!.+)?/,
              '$1' +
                an +
                (li(a, 14) === 45 ? 'inline-' : '') +
                'box$3$1' +
                an +
                '$2$3$1' +
                gi +
                '$2box$3',
            ) + a
          );
      }
      break;
    case 5936:
      switch (li(a, t + 11)) {
        case 114:
          return an + a + gi + rn(a, /[svh]\w+-[tblr]{2}/, 'tb') + a;
        case 108:
          return an + a + gi + rn(a, /[svh]\w+-[tblr]{2}/, 'tb-rl') + a;
        case 45:
          return an + a + gi + rn(a, /[svh]\w+-[tblr]{2}/, 'lr') + a;
      }
      return an + a + gi + a + a;
  }
  return a;
}
var X1 = function (t, e, s, l) {
    if (t.length > -1 && !t.return)
      switch (t.type) {
        case k_:
          t.return = xS(t.value, t.length);
          break;
        case pS:
          return Ol([Qc(t, { value: rn(t.value, '@', '@' + an) })], l);
        case B_:
          if (t.length)
            return R1(t.props, function (h) {
              switch (C1(h, /(::plac\w+|:read-\w+)/)) {
                case ':read-only':
                case ':read-write':
                  return Ol([Qc(t, { props: [rn(h, /:(read-\w+)/, ':' + Uf + '$1')] })], l);
                case '::placeholder':
                  return Ol(
                    [
                      Qc(t, { props: [rn(h, /:(plac\w+)/, ':' + an + 'input-$1')] }),
                      Qc(t, { props: [rn(h, /:(plac\w+)/, ':' + Uf + '$1')] }),
                      Qc(t, { props: [rn(h, /:(plac\w+)/, gi + 'input-$1')] }),
                    ],
                    l,
                  );
              }
              return '';
            });
      }
  },
  j1 = [X1],
  q1 = function (t) {
    var e = t.key;
    if (e === 'css') {
      var s = document.querySelectorAll('style[data-emotion]:not([data-s])');
      Array.prototype.forEach.call(s, function (R) {
        var T = R.getAttribute('data-emotion');
        T.indexOf(' ') !== -1 && (document.head.appendChild(R), R.setAttribute('data-s', ''));
      });
    }
    var l = t.stylisPlugins || j1,
      h = {},
      f,
      m = [];
    (f = t.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + e + ' "]'),
        function (R) {
          for (var T = R.getAttribute('data-emotion').split(' '), M = 1; M < T.length; M++)
            h[T[M]] = !0;
          m.push(R);
        },
      );
    var _,
      g = [W1, Z1];
    {
      var x,
        S = [
          B1,
          F1(function (R) {
            x.insert(R);
          }),
        ],
        b = k1(g.concat(l, S)),
        E = function (T) {
          return Ol(z1(T), b);
        };
      _ = function (T, M, z, P) {
        (x = z), E(T ? T + '{' + M.styles + '}' : M.styles), P && (A.inserted[M.name] = !0);
      };
    }
    var A = {
      key: e,
      sheet: new M1({
        key: e,
        container: f,
        nonce: t.nonce,
        speedy: t.speedy,
        prepend: t.prepend,
        insertionPoint: t.insertionPoint,
      }),
      nonce: t.nonce,
      inserted: h,
      registered: {},
      insert: _,
    };
    return A.sheet.hydrate(m), A;
  },
  Y1 = !0;
function K1(a, t, e) {
  var s = '';
  return (
    e.split(' ').forEach(function (l) {
      a[l] !== void 0 ? t.push(a[l] + ';') : l && (s += l + ' ');
    }),
    s
  );
}
var SS = function (t, e, s) {
    var l = t.key + '-' + e.name;
    (s === !1 || Y1 === !1) && t.registered[l] === void 0 && (t.registered[l] = e.styles);
  },
  Q1 = function (t, e, s) {
    SS(t, e, s);
    var l = t.key + '-' + e.name;
    if (t.inserted[e.name] === void 0) {
      var h = e;
      do t.insert(e === h ? '.' + l : '', h, t.sheet, !0), (h = h.next);
      while (h !== void 0);
    }
  };
function J1(a) {
  for (var t = 0, e, s = 0, l = a.length; l >= 4; ++s, l -= 4)
    (e =
      (a.charCodeAt(s) & 255) |
      ((a.charCodeAt(++s) & 255) << 8) |
      ((a.charCodeAt(++s) & 255) << 16) |
      ((a.charCodeAt(++s) & 255) << 24)),
      (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
      (e ^= e >>> 24),
      (t =
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)) ^
        ((t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)));
  switch (l) {
    case 3:
      t ^= (a.charCodeAt(s + 2) & 255) << 16;
    case 2:
      t ^= (a.charCodeAt(s + 1) & 255) << 8;
    case 1:
      (t ^= a.charCodeAt(s) & 255), (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16));
  }
  return (
    (t ^= t >>> 13),
    (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)),
    ((t ^ (t >>> 15)) >>> 0).toString(36)
  );
}
var $1 = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  tT = /[A-Z]|^ms/g,
  eT = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  MS = function (t) {
    return t.charCodeAt(1) === 45;
  },
  gy = function (t) {
    return t != null && typeof t != 'boolean';
  },
  Xp = yS(function (a) {
    return MS(a) ? a : a.replace(tT, '-$&').toLowerCase();
  }),
  vy = function (t, e) {
    switch (t) {
      case 'animation':
      case 'animationName':
        if (typeof e == 'string')
          return e.replace(eT, function (s, l, h) {
            return (Za = { name: l, styles: h, next: Za }), l;
          });
    }
    return $1[t] !== 1 && !MS(t) && typeof e == 'number' && e !== 0 ? e + 'px' : e;
  };
function fu(a, t, e) {
  if (e == null) return '';
  var s = e;
  if (s.__emotion_styles !== void 0) return s;
  switch (typeof e) {
    case 'boolean':
      return '';
    case 'object': {
      var l = e;
      if (l.anim === 1) return (Za = { name: l.name, styles: l.styles, next: Za }), l.name;
      var h = e;
      if (h.styles !== void 0) {
        var f = h.next;
        if (f !== void 0)
          for (; f !== void 0; ) (Za = { name: f.name, styles: f.styles, next: Za }), (f = f.next);
        var m = h.styles + ';';
        return m;
      }
      return nT(a, t, e);
    }
    case 'function': {
      if (a !== void 0) {
        var _ = Za,
          g = e(a);
        return (Za = _), fu(a, t, g);
      }
      break;
    }
  }
  var x = e;
  if (t == null) return x;
  var S = t[x];
  return S !== void 0 ? S : x;
}
function nT(a, t, e) {
  var s = '';
  if (Array.isArray(e)) for (var l = 0; l < e.length; l++) s += fu(a, t, e[l]) + ';';
  else
    for (var h in e) {
      var f = e[h];
      if (typeof f != 'object') {
        var m = f;
        t != null && t[m] !== void 0
          ? (s += h + '{' + t[m] + '}')
          : gy(m) && (s += Xp(h) + ':' + vy(h, m) + ';');
      } else if (Array.isArray(f) && typeof f[0] == 'string' && (t == null || t[f[0]] === void 0))
        for (var _ = 0; _ < f.length; _++) gy(f[_]) && (s += Xp(h) + ':' + vy(h, f[_]) + ';');
      else {
        var g = fu(a, t, f);
        switch (h) {
          case 'animation':
          case 'animationName': {
            s += Xp(h) + ':' + g + ';';
            break;
          }
          default:
            s += h + '{' + g + '}';
        }
      }
    }
  return s;
}
var yy = /label:\s*([^\s;{]+)\s*(;|$)/g,
  Za;
function iT(a, t, e) {
  if (a.length === 1 && typeof a[0] == 'object' && a[0] !== null && a[0].styles !== void 0)
    return a[0];
  var s = !0,
    l = '';
  Za = void 0;
  var h = a[0];
  if (h == null || h.raw === void 0) (s = !1), (l += fu(e, t, h));
  else {
    var f = h;
    l += f[0];
  }
  for (var m = 1; m < a.length; m++)
    if (((l += fu(e, t, a[m])), s)) {
      var _ = h;
      l += _[m];
    }
  yy.lastIndex = 0;
  for (var g = '', x; (x = yy.exec(l)) !== null; ) g += '-' + x[1];
  var S = J1(l) + g;
  return { name: S, styles: l, next: Za };
}
var aT = function (t) {
    return t();
  },
  rT = ey.useInsertionEffect ? ey.useInsertionEffect : !1,
  sT = rT || aT,
  bS = ot.createContext(typeof HTMLElement < 'u' ? q1({ key: 'css' }) : null);
bS.Provider;
var oT = function (t) {
    return ot.forwardRef(function (e, s) {
      var l = ot.useContext(bS);
      return t(e, l, s);
    });
  },
  lT = ot.createContext({}),
  cT =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  uT = yS(function (a) {
    return (
      cT.test(a) || (a.charCodeAt(0) === 111 && a.charCodeAt(1) === 110 && a.charCodeAt(2) < 91)
    );
  }),
  hT = uT,
  fT = function (t) {
    return t !== 'theme';
  },
  xy = function (t) {
    return typeof t == 'string' && t.charCodeAt(0) > 96 ? hT : fT;
  },
  Sy = function (t, e, s) {
    var l;
    if (e) {
      var h = e.shouldForwardProp;
      l =
        t.__emotion_forwardProp && h
          ? function (f) {
              return t.__emotion_forwardProp(f) && h(f);
            }
          : h;
    }
    return typeof l != 'function' && s && (l = t.__emotion_forwardProp), l;
  },
  dT = function (t) {
    var e = t.cache,
      s = t.serialized,
      l = t.isStringTag;
    return (
      SS(e, s, l),
      sT(function () {
        return Q1(e, s, l);
      }),
      null
    );
  },
  pT = function a(t, e) {
    var s = t.__emotion_real === t,
      l = (s && t.__emotion_base) || t,
      h,
      f;
    e !== void 0 && ((h = e.label), (f = e.target));
    var m = Sy(t, e, s),
      _ = m || xy(l),
      g = !_('as');
    return function () {
      var x = arguments,
        S = s && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
      if ((h !== void 0 && S.push('label:' + h + ';'), x[0] == null || x[0].raw === void 0))
        S.push.apply(S, x);
      else {
        var b = x[0];
        S.push(b[0]);
        for (var E = x.length, A = 1; A < E; A++) S.push(x[A], b[A]);
      }
      var R = oT(function (T, M, z) {
        var P = (g && T.as) || l,
          D = '',
          W = [],
          Z = T;
        if (T.theme == null) {
          Z = {};
          for (var V in T) Z[V] = T[V];
          Z.theme = ot.useContext(lT);
        }
        typeof T.className == 'string'
          ? (D = K1(M.registered, W, T.className))
          : T.className != null && (D = T.className + ' ');
        var J = iT(S.concat(W), M.registered, Z);
        (D += M.key + '-' + J.name), f !== void 0 && (D += ' ' + f);
        var F = g && m === void 0 ? xy(P) : _,
          I = {};
        for (var j in T) (g && j === 'as') || (F(j) && (I[j] = T[j]));
        return (
          (I.className = D),
          z && (I.ref = z),
          ot.createElement(
            ot.Fragment,
            null,
            ot.createElement(dT, { cache: M, serialized: J, isStringTag: typeof P == 'string' }),
            ot.createElement(P, I),
          )
        );
      });
      return (
        (R.displayName =
          h !== void 0
            ? h
            : 'Styled(' +
              (typeof l == 'string' ? l : l.displayName || l.name || 'Component') +
              ')'),
        (R.defaultProps = t.defaultProps),
        (R.__emotion_real = R),
        (R.__emotion_base = l),
        (R.__emotion_styles = S),
        (R.__emotion_forwardProp = m),
        Object.defineProperty(R, 'toString', {
          value: function () {
            return '.' + f;
          },
        }),
        (R.withComponent = function (T, M) {
          var z = a(T, Nm({}, e, M, { shouldForwardProp: Sy(R, M, !0) }));
          return z.apply(void 0, S);
        }),
        R
      );
    };
  },
  mT = [
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'big',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'keygen',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'marquee',
    'menu',
    'menuitem',
    'meta',
    'meter',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'u',
    'ul',
    'var',
    'video',
    'wbr',
    'circle',
    'clipPath',
    'defs',
    'ellipse',
    'foreignObject',
    'g',
    'image',
    'line',
    'linearGradient',
    'mask',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'stop',
    'svg',
    'text',
    'tspan',
  ],
  jt = pT.bind(null);
mT.forEach(function (a) {
  jt[a] = jt(a);
});
const _T = jt.div`
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2rem;
  background: linear-gradient(135deg, #f5f7fa 0%, #e4e8eb 100%);
  overflow-y: auto;
  overflow-x: hidden;
`,
  gT = jt.h1`
  color: #1a73e8;
  margin-bottom: 2rem;
  text-align: center;
  font-size: 2.9rem;
`,
  jp = jt.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
  width: 100%;
  max-width: 1200px;
  margin-bottom: 2rem;
`,
  Mr = jt.div`
  background: white;
  border-radius: 8px;
  padding: 1.5rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  cursor: pointer;
  transition:
    transform 0.2s,
    box-shadow 0.2s;
  border-top: 4px solid ${(a) => a.color};

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }
`,
  br = jt.h2`
  color: #202124;
  margin: 0 0 0.5rem 0;
  font-size: 1.25rem;
`,
  Er = jt.p`
  color: #5f6368;
  margin: 0;
  font-size: 0.9rem;
`,
  qp = jt.h2`
  color: #202124;
  margin: 2rem 0 1rem 0;
  width: 100%;
  max-width: 1200px;
  font-size: 1.5rem;
`,
  vT = jt.button`
  background: #f1c40f;
  color: #2c3e50;
  border: none;
  padding: 1rem 2rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1.2rem;
  transition:
    transform 0.2s,
    background 0.2s;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 2rem;

  &:hover {
    transform: translateY(-2px);
    background: #f39c12;
  }
`,
  yT = jt.span`
  font-size: 1.5rem;
`,
  xT = jt.div`
  position: fixed;
  left: 16px;
  bottom: 12px;
  font-size: 0.95rem;
  color: #888;
  background: rgba(255, 255, 255, 0.85);
  padding: 2px 10px;
  border-radius: 6px;
  z-index: 2000;
  pointer-events: none;
`,
  ST = ({ onSelectPackage: a }) => {
    const t = Ao();
    return at.jsxs(_T, {
      children: [
        at.jsx(gT, { children: 'Topografie Wereld: hoofd- en wereldsteden' }),
        at.jsx(qp, { children: 'Oefenpakketten' }),
        at.jsxs(jp, {
          children: [
            at.jsxs(Mr, {
              color: '#1a73e8',
              onClick: () => a('pakket1'),
              children: [
                at.jsx(br, { children: 'Pakket 1' }),
                at.jsx(Er, { children: 'Basis steden over de hele wereld' }),
              ],
            }),
            at.jsxs(Mr, {
              color: '#34a853',
              onClick: () => a('pakket2'),
              children: [
                at.jsx(br, { children: 'Pakket 2' }),
                at.jsx(Er, { children: 'Extra steden over de wereld' }),
              ],
            }),
            at.jsxs(Mr, {
              color: '#fbbc05',
              onClick: () => a('pakket3'),
              children: [
                at.jsx(br, { children: 'Pakket 3' }),
                at.jsx(Er, { children: 'Extra steden over de wereld' }),
              ],
            }),
          ],
        }),
        at.jsx(qp, { children: 'Gecombineerde Pakketten' }),
        at.jsxs(jp, {
          children: [
            at.jsxs(Mr, {
              color: '#ea4335',
              onClick: () => a('pakket1-2'),
              children: [
                at.jsx(br, { children: 'Pakket 1 + 2' }),
                at.jsx(Er, { children: 'Alle steden uit pakket 1 en 2' }),
              ],
            }),
            at.jsxs(Mr, {
              color: '#9334e6',
              onClick: () => a('pakket2-3'),
              children: [
                at.jsx(br, { children: 'Pakket 2 + 3' }),
                at.jsx(Er, { children: 'Alle steden uit pakket 2 en 3' }),
              ],
            }),
            at.jsxs(Mr, {
              color: '#4285f4',
              onClick: () => a('pakket1-2-3'),
              children: [
                at.jsx(br, { children: 'Pakket 1 + 2 + 3' }),
                at.jsx(Er, { children: 'Alle steden uit alle pakketten' }),
              ],
            }),
          ],
        }),
        at.jsx(qp, { children: 'Interactieve Kaarten' }),
        at.jsxs(jp, {
          children: [
            at.jsxs(Mr, {
              color: '#1a73e8',
              onClick: () => a('interactive1'),
              children: [
                at.jsx(br, { children: 'Interactieve kaart pakket 1' }),
                at.jsx(Er, { children: 'Bekijk alle steden uit pakket 1' }),
              ],
            }),
            at.jsxs(Mr, {
              color: '#34a853',
              onClick: () => a('interactive2'),
              children: [
                at.jsx(br, { children: 'Interactieve kaart pakket 2' }),
                at.jsx(Er, { children: 'Bekijk alle steden uit pakket 2' }),
              ],
            }),
            at.jsxs(Mr, {
              color: '#fbbc05',
              onClick: () => a('interactive3'),
              children: [
                at.jsx(br, { children: 'Interactieve kaart pakket 3' }),
                at.jsx(Er, { children: 'Bekijk alle steden uit pakket 3' }),
              ],
            }),
          ],
        }),
        at.jsxs(vT, {
          onClick: () => t('/trophy-cabinet'),
          children: [at.jsx(yT, { children: '🏆' }), 'Prijzenkast'],
        }),
        at.jsx(xT, { children: 'Versie: 7.3' }),
      ],
    });
  };
function ES(a, t) {
  const e = ot.useRef(t);
  ot.useEffect(
    function () {
      t !== e.current &&
        a.attributionControl != null &&
        (e.current != null && a.attributionControl.removeAttribution(e.current),
        t != null && a.attributionControl.addAttribution(t)),
        (e.current = t);
    },
    [a, t],
  );
}
const MT = 1;
function bT(a) {
  return Object.freeze({ __version: MT, map: a });
}
function ET(a, t) {
  return Object.freeze({ ...a, ...t });
}
const H_ = ot.createContext(null);
function TS() {
  const a = ot.use(H_);
  if (a == null)
    throw new Error(
      'No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>',
    );
  return a;
}
function TT(a) {
  function t(e, s) {
    const { instance: l, context: h } = a(e).current;
    ot.useImperativeHandle(s, () => l);
    const { children: f } = e;
    return f == null ? null : pa.createElement(H_, { value: h }, f);
  }
  return ot.forwardRef(t);
}
function wT(a) {
  function t(e, s) {
    const [l, h] = ot.useState(!1),
      { instance: f } = a(e, h).current;
    ot.useImperativeHandle(s, () => f),
      ot.useEffect(
        function () {
          l && f.update();
        },
        [f, l, e.children],
      );
    const m = f._contentNode;
    return m ? y1.createPortal(e.children, m) : null;
  }
  return ot.forwardRef(t);
}
function AT(a) {
  function t(e, s) {
    const { instance: l } = a(e).current;
    return ot.useImperativeHandle(s, () => l), null;
  }
  return ot.forwardRef(t);
}
function wS(a, t) {
  const e = ot.useRef(void 0);
  ot.useEffect(
    function () {
      return (
        t != null && a.instance.on(t),
        (e.current = t),
        function () {
          e.current != null && a.instance.off(e.current), (e.current = null);
        }
      );
    },
    [a, t],
  );
}
function G_(a, t) {
  const e = a.pane ?? t.pane;
  return e ? { ...a, pane: e } : a;
}
function CT(a, t) {
  return function (s, l) {
    const h = TS(),
      f = a(G_(s, h), h);
    return ES(h.map, s.attribution), wS(f.current, s.eventHandlers), t(f.current, h, s, l), f;
  };
}
var au = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */ var RT = au.exports,
  My;
function LT() {
  return (
    My ||
      ((My = 1),
      (function (a, t) {
        (function (e, s) {
          s(t);
        })(RT, function (e) {
          var s = '1.9.4';
          function l(r) {
            var c, d, y, w;
            for (d = 1, y = arguments.length; d < y; d++) {
              w = arguments[d];
              for (c in w) r[c] = w[c];
            }
            return r;
          }
          var h =
            Object.create ||
            (function () {
              function r() {}
              return function (c) {
                return (r.prototype = c), new r();
              };
            })();
          function f(r, c) {
            var d = Array.prototype.slice;
            if (r.bind) return r.bind.apply(r, d.call(arguments, 1));
            var y = d.call(arguments, 2);
            return function () {
              return r.apply(c, y.length ? y.concat(d.call(arguments)) : arguments);
            };
          }
          var m = 0;
          function _(r) {
            return '_leaflet_id' in r || (r._leaflet_id = ++m), r._leaflet_id;
          }
          function g(r, c, d) {
            var y, w, U, q;
            return (
              (q = function () {
                (y = !1), w && (U.apply(d, w), (w = !1));
              }),
              (U = function () {
                y ? (w = arguments) : (r.apply(d, arguments), setTimeout(q, c), (y = !0));
              }),
              U
            );
          }
          function x(r, c, d) {
            var y = c[1],
              w = c[0],
              U = y - w;
            return r === y && d ? r : ((((r - w) % U) + U) % U) + w;
          }
          function S() {
            return !1;
          }
          function b(r, c) {
            if (c === !1) return r;
            var d = Math.pow(10, c === void 0 ? 6 : c);
            return Math.round(r * d) / d;
          }
          function E(r) {
            return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, '');
          }
          function A(r) {
            return E(r).split(/\s+/);
          }
          function R(r, c) {
            Object.prototype.hasOwnProperty.call(r, 'options') ||
              (r.options = r.options ? h(r.options) : {});
            for (var d in c) r.options[d] = c[d];
            return r.options;
          }
          function T(r, c, d) {
            var y = [];
            for (var w in r)
              y.push(encodeURIComponent(d ? w.toUpperCase() : w) + '=' + encodeURIComponent(r[w]));
            return (!c || c.indexOf('?') === -1 ? '?' : '&') + y.join('&');
          }
          var M = /\{ *([\w_ -]+) *\}/g;
          function z(r, c) {
            return r.replace(M, function (d, y) {
              var w = c[y];
              if (w === void 0) throw new Error('No value provided for variable ' + d);
              return typeof w == 'function' && (w = w(c)), w;
            });
          }
          var P =
            Array.isArray ||
            function (r) {
              return Object.prototype.toString.call(r) === '[object Array]';
            };
          function D(r, c) {
            for (var d = 0; d < r.length; d++) if (r[d] === c) return d;
            return -1;
          }
          var W = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
          function Z(r) {
            return window['webkit' + r] || window['moz' + r] || window['ms' + r];
          }
          var V = 0;
          function J(r) {
            var c = +new Date(),
              d = Math.max(0, 16 - (c - V));
            return (V = c + d), window.setTimeout(r, d);
          }
          var F = window.requestAnimationFrame || Z('RequestAnimationFrame') || J,
            I =
              window.cancelAnimationFrame ||
              Z('CancelAnimationFrame') ||
              Z('CancelRequestAnimationFrame') ||
              function (r) {
                window.clearTimeout(r);
              };
          function j(r, c, d) {
            if (d && F === J) r.call(c);
            else return F.call(window, f(r, c));
          }
          function ft(r) {
            r && I.call(window, r);
          }
          var pt = {
            __proto__: null,
            extend: l,
            create: h,
            bind: f,
            get lastId() {
              return m;
            },
            stamp: _,
            throttle: g,
            wrapNum: x,
            falseFn: S,
            formatNum: b,
            trim: E,
            splitWords: A,
            setOptions: R,
            getParamString: T,
            template: z,
            isArray: P,
            indexOf: D,
            emptyImageUrl: W,
            requestFn: F,
            cancelFn: I,
            requestAnimFrame: j,
            cancelAnimFrame: ft,
          };
          function Mt() {}
          (Mt.extend = function (r) {
            var c = function () {
                R(this),
                  this.initialize && this.initialize.apply(this, arguments),
                  this.callInitHooks();
              },
              d = (c.__super__ = this.prototype),
              y = h(d);
            (y.constructor = c), (c.prototype = y);
            for (var w in this)
              Object.prototype.hasOwnProperty.call(this, w) &&
                w !== 'prototype' &&
                w !== '__super__' &&
                (c[w] = this[w]);
            return (
              r.statics && l(c, r.statics),
              r.includes && (bt(r.includes), l.apply(null, [y].concat(r.includes))),
              l(y, r),
              delete y.statics,
              delete y.includes,
              y.options && ((y.options = d.options ? h(d.options) : {}), l(y.options, r.options)),
              (y._initHooks = []),
              (y.callInitHooks = function () {
                if (!this._initHooksCalled) {
                  d.callInitHooks && d.callInitHooks.call(this), (this._initHooksCalled = !0);
                  for (var U = 0, q = y._initHooks.length; U < q; U++) y._initHooks[U].call(this);
                }
              }),
              c
            );
          }),
            (Mt.include = function (r) {
              var c = this.prototype.options;
              return (
                l(this.prototype, r),
                r.options && ((this.prototype.options = c), this.mergeOptions(r.options)),
                this
              );
            }),
            (Mt.mergeOptions = function (r) {
              return l(this.prototype.options, r), this;
            }),
            (Mt.addInitHook = function (r) {
              var c = Array.prototype.slice.call(arguments, 1),
                d =
                  typeof r == 'function'
                    ? r
                    : function () {
                        this[r].apply(this, c);
                      };
              return (
                (this.prototype._initHooks = this.prototype._initHooks || []),
                this.prototype._initHooks.push(d),
                this
              );
            });
          function bt(r) {
            if (!(typeof L > 'u' || !L || !L.Mixin)) {
              r = P(r) ? r : [r];
              for (var c = 0; c < r.length; c++)
                r[c] === L.Mixin.Events &&
                  console.warn(
                    'Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.',
                    new Error().stack,
                  );
            }
          }
          var X = {
            on: function (r, c, d) {
              if (typeof r == 'object') for (var y in r) this._on(y, r[y], c);
              else {
                r = A(r);
                for (var w = 0, U = r.length; w < U; w++) this._on(r[w], c, d);
              }
              return this;
            },
            off: function (r, c, d) {
              if (!arguments.length) delete this._events;
              else if (typeof r == 'object') for (var y in r) this._off(y, r[y], c);
              else {
                r = A(r);
                for (var w = arguments.length === 1, U = 0, q = r.length; U < q; U++)
                  w ? this._off(r[U]) : this._off(r[U], c, d);
              }
              return this;
            },
            _on: function (r, c, d, y) {
              if (typeof c != 'function') {
                console.warn('wrong listener type: ' + typeof c);
                return;
              }
              if (this._listens(r, c, d) === !1) {
                d === this && (d = void 0);
                var w = { fn: c, ctx: d };
                y && (w.once = !0),
                  (this._events = this._events || {}),
                  (this._events[r] = this._events[r] || []),
                  this._events[r].push(w);
              }
            },
            _off: function (r, c, d) {
              var y, w, U;
              if (this._events && ((y = this._events[r]), !!y)) {
                if (arguments.length === 1) {
                  if (this._firingCount) for (w = 0, U = y.length; w < U; w++) y[w].fn = S;
                  delete this._events[r];
                  return;
                }
                if (typeof c != 'function') {
                  console.warn('wrong listener type: ' + typeof c);
                  return;
                }
                var q = this._listens(r, c, d);
                if (q !== !1) {
                  var ht = y[q];
                  this._firingCount && ((ht.fn = S), (this._events[r] = y = y.slice())),
                    y.splice(q, 1);
                }
              }
            },
            fire: function (r, c, d) {
              if (!this.listens(r, d)) return this;
              var y = l({}, c, {
                type: r,
                target: this,
                sourceTarget: (c && c.sourceTarget) || this,
              });
              if (this._events) {
                var w = this._events[r];
                if (w) {
                  this._firingCount = this._firingCount + 1 || 1;
                  for (var U = 0, q = w.length; U < q; U++) {
                    var ht = w[U],
                      St = ht.fn;
                    ht.once && this.off(r, St, ht.ctx), St.call(ht.ctx || this, y);
                  }
                  this._firingCount--;
                }
              }
              return d && this._propagateEvent(y), this;
            },
            listens: function (r, c, d, y) {
              typeof r != 'string' && console.warn('"string" type argument expected');
              var w = c;
              typeof c != 'function' && ((y = !!c), (w = void 0), (d = void 0));
              var U = this._events && this._events[r];
              if (U && U.length && this._listens(r, w, d) !== !1) return !0;
              if (y) {
                for (var q in this._eventParents)
                  if (this._eventParents[q].listens(r, c, d, y)) return !0;
              }
              return !1;
            },
            _listens: function (r, c, d) {
              if (!this._events) return !1;
              var y = this._events[r] || [];
              if (!c) return !!y.length;
              d === this && (d = void 0);
              for (var w = 0, U = y.length; w < U; w++)
                if (y[w].fn === c && y[w].ctx === d) return w;
              return !1;
            },
            once: function (r, c, d) {
              if (typeof r == 'object') for (var y in r) this._on(y, r[y], c, !0);
              else {
                r = A(r);
                for (var w = 0, U = r.length; w < U; w++) this._on(r[w], c, d, !0);
              }
              return this;
            },
            addEventParent: function (r) {
              return (
                (this._eventParents = this._eventParents || {}),
                (this._eventParents[_(r)] = r),
                this
              );
            },
            removeEventParent: function (r) {
              return this._eventParents && delete this._eventParents[_(r)], this;
            },
            _propagateEvent: function (r) {
              for (var c in this._eventParents)
                this._eventParents[c].fire(
                  r.type,
                  l({ layer: r.target, propagatedFrom: r.target }, r),
                  !0,
                );
            },
          };
          (X.addEventListener = X.on),
            (X.removeEventListener = X.clearAllEventListeners = X.off),
            (X.addOneTimeEventListener = X.once),
            (X.fireEvent = X.fire),
            (X.hasEventListeners = X.listens);
          var it = Mt.extend(X);
          function K(r, c, d) {
            (this.x = d ? Math.round(r) : r), (this.y = d ? Math.round(c) : c);
          }
          var zt =
            Math.trunc ||
            function (r) {
              return r > 0 ? Math.floor(r) : Math.ceil(r);
            };
          K.prototype = {
            clone: function () {
              return new K(this.x, this.y);
            },
            add: function (r) {
              return this.clone()._add(N(r));
            },
            _add: function (r) {
              return (this.x += r.x), (this.y += r.y), this;
            },
            subtract: function (r) {
              return this.clone()._subtract(N(r));
            },
            _subtract: function (r) {
              return (this.x -= r.x), (this.y -= r.y), this;
            },
            divideBy: function (r) {
              return this.clone()._divideBy(r);
            },
            _divideBy: function (r) {
              return (this.x /= r), (this.y /= r), this;
            },
            multiplyBy: function (r) {
              return this.clone()._multiplyBy(r);
            },
            _multiplyBy: function (r) {
              return (this.x *= r), (this.y *= r), this;
            },
            scaleBy: function (r) {
              return new K(this.x * r.x, this.y * r.y);
            },
            unscaleBy: function (r) {
              return new K(this.x / r.x, this.y / r.y);
            },
            round: function () {
              return this.clone()._round();
            },
            _round: function () {
              return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
            },
            floor: function () {
              return this.clone()._floor();
            },
            _floor: function () {
              return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
            },
            ceil: function () {
              return this.clone()._ceil();
            },
            _ceil: function () {
              return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
            },
            trunc: function () {
              return this.clone()._trunc();
            },
            _trunc: function () {
              return (this.x = zt(this.x)), (this.y = zt(this.y)), this;
            },
            distanceTo: function (r) {
              r = N(r);
              var c = r.x - this.x,
                d = r.y - this.y;
              return Math.sqrt(c * c + d * d);
            },
            equals: function (r) {
              return (r = N(r)), r.x === this.x && r.y === this.y;
            },
            contains: function (r) {
              return (
                (r = N(r)), Math.abs(r.x) <= Math.abs(this.x) && Math.abs(r.y) <= Math.abs(this.y)
              );
            },
            toString: function () {
              return 'Point(' + b(this.x) + ', ' + b(this.y) + ')';
            },
          };
          function N(r, c, d) {
            return r instanceof K
              ? r
              : P(r)
                ? new K(r[0], r[1])
                : r == null
                  ? r
                  : typeof r == 'object' && 'x' in r && 'y' in r
                    ? new K(r.x, r.y)
                    : new K(r, c, d);
          }
          function Q(r, c) {
            if (r) for (var d = c ? [r, c] : r, y = 0, w = d.length; y < w; y++) this.extend(d[y]);
          }
          Q.prototype = {
            extend: function (r) {
              var c, d;
              if (!r) return this;
              if (r instanceof K || typeof r[0] == 'number' || 'x' in r) c = d = N(r);
              else if (((r = gt(r)), (c = r.min), (d = r.max), !c || !d)) return this;
              return (
                !this.min && !this.max
                  ? ((this.min = c.clone()), (this.max = d.clone()))
                  : ((this.min.x = Math.min(c.x, this.min.x)),
                    (this.max.x = Math.max(d.x, this.max.x)),
                    (this.min.y = Math.min(c.y, this.min.y)),
                    (this.max.y = Math.max(d.y, this.max.y))),
                this
              );
            },
            getCenter: function (r) {
              return N((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, r);
            },
            getBottomLeft: function () {
              return N(this.min.x, this.max.y);
            },
            getTopRight: function () {
              return N(this.max.x, this.min.y);
            },
            getTopLeft: function () {
              return this.min;
            },
            getBottomRight: function () {
              return this.max;
            },
            getSize: function () {
              return this.max.subtract(this.min);
            },
            contains: function (r) {
              var c, d;
              return (
                typeof r[0] == 'number' || r instanceof K ? (r = N(r)) : (r = gt(r)),
                r instanceof Q ? ((c = r.min), (d = r.max)) : (c = d = r),
                c.x >= this.min.x && d.x <= this.max.x && c.y >= this.min.y && d.y <= this.max.y
              );
            },
            intersects: function (r) {
              r = gt(r);
              var c = this.min,
                d = this.max,
                y = r.min,
                w = r.max,
                U = w.x >= c.x && y.x <= d.x,
                q = w.y >= c.y && y.y <= d.y;
              return U && q;
            },
            overlaps: function (r) {
              r = gt(r);
              var c = this.min,
                d = this.max,
                y = r.min,
                w = r.max,
                U = w.x > c.x && y.x < d.x,
                q = w.y > c.y && y.y < d.y;
              return U && q;
            },
            isValid: function () {
              return !!(this.min && this.max);
            },
            pad: function (r) {
              var c = this.min,
                d = this.max,
                y = Math.abs(c.x - d.x) * r,
                w = Math.abs(c.y - d.y) * r;
              return gt(N(c.x - y, c.y - w), N(d.x + y, d.y + w));
            },
            equals: function (r) {
              return r
                ? ((r = gt(r)),
                  this.min.equals(r.getTopLeft()) && this.max.equals(r.getBottomRight()))
                : !1;
            },
          };
          function gt(r, c) {
            return !r || r instanceof Q ? r : new Q(r, c);
          }
          function At(r, c) {
            if (r) for (var d = c ? [r, c] : r, y = 0, w = d.length; y < w; y++) this.extend(d[y]);
          }
          At.prototype = {
            extend: function (r) {
              var c = this._southWest,
                d = this._northEast,
                y,
                w;
              if (r instanceof st) (y = r), (w = r);
              else if (r instanceof At) {
                if (((y = r._southWest), (w = r._northEast), !y || !w)) return this;
              } else return r ? this.extend(_t(r) || tt(r)) : this;
              return (
                !c && !d
                  ? ((this._southWest = new st(y.lat, y.lng)),
                    (this._northEast = new st(w.lat, w.lng)))
                  : ((c.lat = Math.min(y.lat, c.lat)),
                    (c.lng = Math.min(y.lng, c.lng)),
                    (d.lat = Math.max(w.lat, d.lat)),
                    (d.lng = Math.max(w.lng, d.lng))),
                this
              );
            },
            pad: function (r) {
              var c = this._southWest,
                d = this._northEast,
                y = Math.abs(c.lat - d.lat) * r,
                w = Math.abs(c.lng - d.lng) * r;
              return new At(new st(c.lat - y, c.lng - w), new st(d.lat + y, d.lng + w));
            },
            getCenter: function () {
              return new st(
                (this._southWest.lat + this._northEast.lat) / 2,
                (this._southWest.lng + this._northEast.lng) / 2,
              );
            },
            getSouthWest: function () {
              return this._southWest;
            },
            getNorthEast: function () {
              return this._northEast;
            },
            getNorthWest: function () {
              return new st(this.getNorth(), this.getWest());
            },
            getSouthEast: function () {
              return new st(this.getSouth(), this.getEast());
            },
            getWest: function () {
              return this._southWest.lng;
            },
            getSouth: function () {
              return this._southWest.lat;
            },
            getEast: function () {
              return this._northEast.lng;
            },
            getNorth: function () {
              return this._northEast.lat;
            },
            contains: function (r) {
              typeof r[0] == 'number' || r instanceof st || 'lat' in r ? (r = _t(r)) : (r = tt(r));
              var c = this._southWest,
                d = this._northEast,
                y,
                w;
              return (
                r instanceof At ? ((y = r.getSouthWest()), (w = r.getNorthEast())) : (y = w = r),
                y.lat >= c.lat && w.lat <= d.lat && y.lng >= c.lng && w.lng <= d.lng
              );
            },
            intersects: function (r) {
              r = tt(r);
              var c = this._southWest,
                d = this._northEast,
                y = r.getSouthWest(),
                w = r.getNorthEast(),
                U = w.lat >= c.lat && y.lat <= d.lat,
                q = w.lng >= c.lng && y.lng <= d.lng;
              return U && q;
            },
            overlaps: function (r) {
              r = tt(r);
              var c = this._southWest,
                d = this._northEast,
                y = r.getSouthWest(),
                w = r.getNorthEast(),
                U = w.lat > c.lat && y.lat < d.lat,
                q = w.lng > c.lng && y.lng < d.lng;
              return U && q;
            },
            toBBoxString: function () {
              return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
            },
            equals: function (r, c) {
              return r
                ? ((r = tt(r)),
                  this._southWest.equals(r.getSouthWest(), c) &&
                    this._northEast.equals(r.getNorthEast(), c))
                : !1;
            },
            isValid: function () {
              return !!(this._southWest && this._northEast);
            },
          };
          function tt(r, c) {
            return r instanceof At ? r : new At(r, c);
          }
          function st(r, c, d) {
            if (isNaN(r) || isNaN(c))
              throw new Error('Invalid LatLng object: (' + r + ', ' + c + ')');
            (this.lat = +r), (this.lng = +c), d !== void 0 && (this.alt = +d);
          }
          st.prototype = {
            equals: function (r, c) {
              if (!r) return !1;
              r = _t(r);
              var d = Math.max(Math.abs(this.lat - r.lat), Math.abs(this.lng - r.lng));
              return d <= (c === void 0 ? 1e-9 : c);
            },
            toString: function (r) {
              return 'LatLng(' + b(this.lat, r) + ', ' + b(this.lng, r) + ')';
            },
            distanceTo: function (r) {
              return Gt.distance(this, _t(r));
            },
            wrap: function () {
              return Gt.wrapLatLng(this);
            },
            toBounds: function (r) {
              var c = (180 * r) / 40075017,
                d = c / Math.cos((Math.PI / 180) * this.lat);
              return tt([this.lat - c, this.lng - d], [this.lat + c, this.lng + d]);
            },
            clone: function () {
              return new st(this.lat, this.lng, this.alt);
            },
          };
          function _t(r, c, d) {
            return r instanceof st
              ? r
              : P(r) && typeof r[0] != 'object'
                ? r.length === 3
                  ? new st(r[0], r[1], r[2])
                  : r.length === 2
                    ? new st(r[0], r[1])
                    : null
                : r == null
                  ? r
                  : typeof r == 'object' && 'lat' in r
                    ? new st(r.lat, 'lng' in r ? r.lng : r.lon, r.alt)
                    : c === void 0
                      ? null
                      : new st(r, c, d);
          }
          var It = {
              latLngToPoint: function (r, c) {
                var d = this.projection.project(r),
                  y = this.scale(c);
                return this.transformation._transform(d, y);
              },
              pointToLatLng: function (r, c) {
                var d = this.scale(c),
                  y = this.transformation.untransform(r, d);
                return this.projection.unproject(y);
              },
              project: function (r) {
                return this.projection.project(r);
              },
              unproject: function (r) {
                return this.projection.unproject(r);
              },
              scale: function (r) {
                return 256 * Math.pow(2, r);
              },
              zoom: function (r) {
                return Math.log(r / 256) / Math.LN2;
              },
              getProjectedBounds: function (r) {
                if (this.infinite) return null;
                var c = this.projection.bounds,
                  d = this.scale(r),
                  y = this.transformation.transform(c.min, d),
                  w = this.transformation.transform(c.max, d);
                return new Q(y, w);
              },
              infinite: !1,
              wrapLatLng: function (r) {
                var c = this.wrapLng ? x(r.lng, this.wrapLng, !0) : r.lng,
                  d = this.wrapLat ? x(r.lat, this.wrapLat, !0) : r.lat,
                  y = r.alt;
                return new st(d, c, y);
              },
              wrapLatLngBounds: function (r) {
                var c = r.getCenter(),
                  d = this.wrapLatLng(c),
                  y = c.lat - d.lat,
                  w = c.lng - d.lng;
                if (y === 0 && w === 0) return r;
                var U = r.getSouthWest(),
                  q = r.getNorthEast(),
                  ht = new st(U.lat - y, U.lng - w),
                  St = new st(q.lat - y, q.lng - w);
                return new At(ht, St);
              },
            },
            Gt = l({}, It, {
              wrapLng: [-180, 180],
              R: 6371e3,
              distance: function (r, c) {
                var d = Math.PI / 180,
                  y = r.lat * d,
                  w = c.lat * d,
                  U = Math.sin(((c.lat - r.lat) * d) / 2),
                  q = Math.sin(((c.lng - r.lng) * d) / 2),
                  ht = U * U + Math.cos(y) * Math.cos(w) * q * q,
                  St = 2 * Math.atan2(Math.sqrt(ht), Math.sqrt(1 - ht));
                return this.R * St;
              },
            }),
            fe = 6378137,
            oe = {
              R: fe,
              MAX_LATITUDE: 85.0511287798,
              project: function (r) {
                var c = Math.PI / 180,
                  d = this.MAX_LATITUDE,
                  y = Math.max(Math.min(d, r.lat), -d),
                  w = Math.sin(y * c);
                return new K(this.R * r.lng * c, (this.R * Math.log((1 + w) / (1 - w))) / 2);
              },
              unproject: function (r) {
                var c = 180 / Math.PI;
                return new st(
                  (2 * Math.atan(Math.exp(r.y / this.R)) - Math.PI / 2) * c,
                  (r.x * c) / this.R,
                );
              },
              bounds: (function () {
                var r = fe * Math.PI;
                return new Q([-r, -r], [r, r]);
              })(),
            };
          function Ne(r, c, d, y) {
            if (P(r)) {
              (this._a = r[0]), (this._b = r[1]), (this._c = r[2]), (this._d = r[3]);
              return;
            }
            (this._a = r), (this._b = c), (this._c = d), (this._d = y);
          }
          Ne.prototype = {
            transform: function (r, c) {
              return this._transform(r.clone(), c);
            },
            _transform: function (r, c) {
              return (
                (c = c || 1),
                (r.x = c * (this._a * r.x + this._b)),
                (r.y = c * (this._c * r.y + this._d)),
                r
              );
            },
            untransform: function (r, c) {
              return (
                (c = c || 1), new K((r.x / c - this._b) / this._a, (r.y / c - this._d) / this._c)
              );
            },
          };
          function Te(r, c, d, y) {
            return new Ne(r, c, d, y);
          }
          var ye = l({}, Gt, {
              code: 'EPSG:3857',
              projection: oe,
              transformation: (function () {
                var r = 0.5 / (Math.PI * oe.R);
                return Te(r, 0.5, -r, 0.5);
              })(),
            }),
            G = l({}, ye, { code: 'EPSG:900913' });
          function Zt(r) {
            return document.createElementNS('http://www.w3.org/2000/svg', r);
          }
          function Bt(r, c) {
            var d = '',
              y,
              w,
              U,
              q,
              ht,
              St;
            for (y = 0, U = r.length; y < U; y++) {
              for (ht = r[y], w = 0, q = ht.length; w < q; w++)
                (St = ht[w]), (d += (w ? 'L' : 'M') + St.x + ' ' + St.y);
              d += c ? (me.svg ? 'z' : 'x') : '';
            }
            return d || 'M0 0';
          }
          var Ut = document.documentElement.style,
            Lt = 'ActiveXObject' in window,
            le = Lt && !document.addEventListener,
            kt = 'msLaunchUri' in navigator && !('documentMode' in document),
            H = Kn('webkit'),
            O = Kn('android'),
            rt = Kn('android 2') || Kn('android 3'),
            wt = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10),
            Dt = O && Kn('Google') && wt < 537 && !('AudioNode' in window),
            Et = !!window.opera,
            Xt = !kt && Kn('chrome'),
            Wt = Kn('gecko') && !H && !Et && !Lt,
            $t = !Xt && Kn('safari'),
            ce = Kn('phantom'),
            Ht = 'OTransition' in Ut,
            re = navigator.platform.indexOf('Win') === 0,
            pe = Lt && 'transition' in Ut,
            Se = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !rt,
            Qt = 'MozPerspective' in Ut,
            Oe = !window.L_DISABLE_3D && (pe || Se || Qt) && !Ht && !ce,
            Me = typeof orientation < 'u' || Kn('mobile'),
            Je = Me && H,
            nt = Me && Se,
            qt = !window.PointerEvent && window.MSPointerEvent,
            Ct = !!(window.PointerEvent || qt),
            Ot = 'ontouchstart' in window || !!window.TouchEvent,
            ae = !window.L_NO_TOUCH && (Ot || Ct),
            te = Me && Et,
            Pe = Me && Wt,
            cn =
              (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1,
            Rn = (function () {
              var r = !1;
              try {
                var c = Object.defineProperty({}, 'passive', {
                  get: function () {
                    r = !0;
                  },
                });
                window.addEventListener('testPassiveEventSupport', S, c),
                  window.removeEventListener('testPassiveEventSupport', S, c);
              } catch {}
              return r;
            })(),
            Ye = (function () {
              return !!document.createElement('canvas').getContext;
            })(),
            ii = !!(document.createElementNS && Zt('svg').createSVGRect),
            kn =
              !!ii &&
              (function () {
                var r = document.createElement('div');
                return (
                  (r.innerHTML = '<svg/>'),
                  (r.firstChild && r.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg'
                );
              })(),
            Nn =
              !ii &&
              (function () {
                try {
                  var r = document.createElement('div');
                  r.innerHTML = '<v:shape adj="1"/>';
                  var c = r.firstChild;
                  return (c.style.behavior = 'url(#default#VML)'), c && typeof c.adj == 'object';
                } catch {
                  return !1;
                }
              })(),
            Wn = navigator.platform.indexOf('Mac') === 0,
            ui = navigator.platform.indexOf('Linux') === 0;
          function Kn(r) {
            return navigator.userAgent.toLowerCase().indexOf(r) >= 0;
          }
          var me = {
              ie: Lt,
              ielt9: le,
              edge: kt,
              webkit: H,
              android: O,
              android23: rt,
              androidStock: Dt,
              opera: Et,
              chrome: Xt,
              gecko: Wt,
              safari: $t,
              phantom: ce,
              opera12: Ht,
              win: re,
              ie3d: pe,
              webkit3d: Se,
              gecko3d: Qt,
              any3d: Oe,
              mobile: Me,
              mobileWebkit: Je,
              mobileWebkit3d: nt,
              msPointer: qt,
              pointer: Ct,
              touch: ae,
              touchNative: Ot,
              mobileOpera: te,
              mobileGecko: Pe,
              retina: cn,
              passiveEvents: Rn,
              canvas: Ye,
              svg: ii,
              vml: Nn,
              inlineSvg: kn,
              mac: Wn,
              linux: ui,
            },
            Is = me.msPointer ? 'MSPointerDown' : 'pointerdown',
            Oa = me.msPointer ? 'MSPointerMove' : 'pointermove',
            _a = me.msPointer ? 'MSPointerUp' : 'pointerup',
            ga = me.msPointer ? 'MSPointerCancel' : 'pointercancel',
            Ii = { touchstart: Is, touchmove: Oa, touchend: _a, touchcancel: ga },
            ta = { touchstart: Tt, touchmove: yt, touchend: yt, touchcancel: yt },
            Ci = {},
            va = !1;
          function Ln(r, c, d) {
            return (
              c === 'touchstart' && lt(),
              ta[c]
                ? ((d = ta[c].bind(this, d)), r.addEventListener(Ii[c], d, !1), d)
                : (console.warn('wrong event specified:', c), S)
            );
          }
          function Ro(r, c, d) {
            if (!Ii[c]) {
              console.warn('wrong event specified:', c);
              return;
            }
            r.removeEventListener(Ii[c], d, !1);
          }
          function Lo(r) {
            Ci[r.pointerId] = r;
          }
          function ya(r) {
            Ci[r.pointerId] && (Ci[r.pointerId] = r);
          }
          function k(r) {
            delete Ci[r.pointerId];
          }
          function lt() {
            va ||
              (document.addEventListener(Is, Lo, !0),
              document.addEventListener(Oa, ya, !0),
              document.addEventListener(_a, k, !0),
              document.addEventListener(ga, k, !0),
              (va = !0));
          }
          function yt(r, c) {
            if (c.pointerType !== (c.MSPOINTER_TYPE_MOUSE || 'mouse')) {
              c.touches = [];
              for (var d in Ci) c.touches.push(Ci[d]);
              (c.changedTouches = [c]), r(c);
            }
          }
          function Tt(r, c) {
            c.MSPOINTER_TYPE_TOUCH && c.pointerType === c.MSPOINTER_TYPE_TOUCH && Dn(c), yt(r, c);
          }
          function ut(r) {
            var c = {},
              d,
              y;
            for (y in r) (d = r[y]), (c[y] = d && d.bind ? d.bind(r) : d);
            return (
              (r = c),
              (c.type = 'dblclick'),
              (c.detail = 2),
              (c.isTrusted = !1),
              (c._simulated = !0),
              c
            );
          }
          var Vt = 200;
          function Kt(r, c) {
            r.addEventListener('dblclick', c);
            var d = 0,
              y;
            function w(U) {
              if (U.detail !== 1) {
                y = U.detail;
                return;
              }
              if (
                !(
                  U.pointerType === 'mouse' ||
                  (U.sourceCapabilities && !U.sourceCapabilities.firesTouchEvents)
                )
              ) {
                var q = $l(U);
                if (
                  !(
                    q.some(function (St) {
                      return St instanceof HTMLLabelElement && St.attributes.for;
                    }) &&
                    !q.some(function (St) {
                      return St instanceof HTMLInputElement || St instanceof HTMLSelectElement;
                    })
                  )
                ) {
                  var ht = Date.now();
                  ht - d <= Vt ? (y++, y === 2 && c(ut(U))) : (y = 1), (d = ht);
                }
              }
            }
            return r.addEventListener('click', w), { dblclick: c, simDblclick: w };
          }
          function Jt(r, c) {
            r.removeEventListener('dblclick', c.dblclick),
              r.removeEventListener('click', c.simDblclick);
          }
          var se = zn([
              'transform',
              'webkitTransform',
              'OTransform',
              'MozTransform',
              'msTransform',
            ]),
            Ee = zn([
              'webkitTransition',
              'transition',
              'OTransition',
              'MozTransition',
              'msTransition',
            ]),
            be = Ee === 'webkitTransition' || Ee === 'OTransition' ? Ee + 'End' : 'transitionend';
          function ve(r) {
            return typeof r == 'string' ? document.getElementById(r) : r;
          }
          function Ue(r, c) {
            var d = r.style[c] || (r.currentStyle && r.currentStyle[c]);
            if ((!d || d === 'auto') && document.defaultView) {
              var y = document.defaultView.getComputedStyle(r, null);
              d = y ? y[c] : null;
            }
            return d === 'auto' ? null : d;
          }
          function ue(r, c, d) {
            var y = document.createElement(r);
            return (y.className = c || ''), d && d.appendChild(y), y;
          }
          function Re(r) {
            var c = r.parentNode;
            c && c.removeChild(r);
          }
          function ke(r) {
            for (; r.firstChild; ) r.removeChild(r.firstChild);
          }
          function ze(r) {
            var c = r.parentNode;
            c && c.lastChild !== r && c.appendChild(r);
          }
          function ge(r) {
            var c = r.parentNode;
            c && c.firstChild !== r && c.insertBefore(r, c.firstChild);
          }
          function gn(r, c) {
            if (r.classList !== void 0) return r.classList.contains(c);
            var d = nn(r);
            return d.length > 0 && new RegExp('(^|\\s)' + c + '(\\s|$)').test(d);
          }
          function ne(r, c) {
            if (r.classList !== void 0)
              for (var d = A(c), y = 0, w = d.length; y < w; y++) r.classList.add(d[y]);
            else if (!gn(r, c)) {
              var U = nn(r);
              ea(r, (U ? U + ' ' : '') + c);
            }
          }
          function We(r, c) {
            r.classList !== void 0
              ? r.classList.remove(c)
              : ea(r, E((' ' + nn(r) + ' ').replace(' ' + c + ' ', ' ')));
          }
          function ea(r, c) {
            r.className.baseVal === void 0 ? (r.className = c) : (r.className.baseVal = c);
          }
          function nn(r) {
            return (
              r.correspondingElement && (r = r.correspondingElement),
              r.className.baseVal === void 0 ? r.className : r.className.baseVal
            );
          }
          function Pn(r, c) {
            'opacity' in r.style ? (r.style.opacity = c) : 'filter' in r.style && sn(r, c);
          }
          function sn(r, c) {
            var d = !1,
              y = 'DXImageTransform.Microsoft.Alpha';
            try {
              d = r.filters.item(y);
            } catch {
              if (c === 1) return;
            }
            (c = Math.round(c * 100)),
              d
                ? ((d.Enabled = c !== 100), (d.Opacity = c))
                : (r.style.filter += ' progid:' + y + '(opacity=' + c + ')');
          }
          function zn(r) {
            for (var c = document.documentElement.style, d = 0; d < r.length; d++)
              if (r[d] in c) return r[d];
            return !1;
          }
          function mn(r, c, d) {
            var y = c || new K(0, 0);
            r.style[se] =
              (me.ie3d
                ? 'translate(' + y.x + 'px,' + y.y + 'px)'
                : 'translate3d(' + y.x + 'px,' + y.y + 'px,0)') + (d ? ' scale(' + d + ')' : '');
          }
          function He(r, c) {
            (r._leaflet_pos = c),
              me.any3d ? mn(r, c) : ((r.style.left = c.x + 'px'), (r.style.top = c.y + 'px'));
          }
          function xn(r) {
            return r._leaflet_pos || new K(0, 0);
          }
          var hi, yi, Po;
          if ('onselectstart' in document)
            (hi = function () {
              De(window, 'selectstart', Dn);
            }),
              (yi = function () {
                $e(window, 'selectstart', Dn);
              });
          else {
            var Fr = zn([
              'userSelect',
              'WebkitUserSelect',
              'OUserSelect',
              'MozUserSelect',
              'msUserSelect',
            ]);
            (hi = function () {
              if (Fr) {
                var r = document.documentElement.style;
                (Po = r[Fr]), (r[Fr] = 'none');
              }
            }),
              (yi = function () {
                Fr && ((document.documentElement.style[Fr] = Po), (Po = void 0));
              });
          }
          function Bs() {
            De(window, 'dragstart', Dn);
          }
          function Jl() {
            $e(window, 'dragstart', Dn);
          }
          var Do, Hr;
          function ks(r) {
            for (; r.tabIndex === -1; ) r = r.parentNode;
            r.style &&
              (Gr(),
              (Do = r),
              (Hr = r.style.outlineStyle),
              (r.style.outlineStyle = 'none'),
              De(window, 'keydown', Gr));
          }
          function Gr() {
            Do &&
              ((Do.style.outlineStyle = Hr),
              (Do = void 0),
              (Hr = void 0),
              $e(window, 'keydown', Gr));
          }
          function er(r) {
            do r = r.parentNode;
            while ((!r.offsetWidth || !r.offsetHeight) && r !== document.body);
            return r;
          }
          function Ua(r) {
            var c = r.getBoundingClientRect();
            return {
              x: c.width / r.offsetWidth || 1,
              y: c.height / r.offsetHeight || 1,
              boundingClientRect: c,
            };
          }
          var Au = {
            __proto__: null,
            TRANSFORM: se,
            TRANSITION: Ee,
            TRANSITION_END: be,
            get: ve,
            getStyle: Ue,
            create: ue,
            remove: Re,
            empty: ke,
            toFront: ze,
            toBack: ge,
            hasClass: gn,
            addClass: ne,
            removeClass: We,
            setClass: ea,
            getClass: nn,
            setOpacity: Pn,
            testProp: zn,
            setTransform: mn,
            setPosition: He,
            getPosition: xn,
            get disableTextSelection() {
              return hi;
            },
            get enableTextSelection() {
              return yi;
            },
            disableImageDrag: Bs,
            enableImageDrag: Jl,
            preventOutline: ks,
            restoreOutline: Gr,
            getSizedParentNode: er,
            getScale: Ua,
          };
          function De(r, c, d, y) {
            if (c && typeof c == 'object') for (var w in c) nr(r, w, c[w], d);
            else {
              c = A(c);
              for (var U = 0, q = c.length; U < q; U++) nr(r, c[U], d, y);
            }
            return this;
          }
          var Bi = '_leaflet_events';
          function $e(r, c, d, y) {
            if (arguments.length === 1) na(r), delete r[Bi];
            else if (c && typeof c == 'object') for (var w in c) ia(r, w, c[w], d);
            else if (((c = A(c)), arguments.length === 2))
              na(r, function (ht) {
                return D(c, ht) !== -1;
              });
            else for (var U = 0, q = c.length; U < q; U++) ia(r, c[U], d, y);
            return this;
          }
          function na(r, c) {
            for (var d in r[Bi]) {
              var y = d.split(/\d/)[0];
              (!c || c(y)) && ia(r, y, null, null, d);
            }
          }
          var Fs = {
            mouseenter: 'mouseover',
            mouseleave: 'mouseout',
            wheel: !('onwheel' in window) && 'mousewheel',
          };
          function nr(r, c, d, y) {
            var w = c + _(d) + (y ? '_' + _(y) : '');
            if (r[Bi] && r[Bi][w]) return this;
            var U = function (ht) {
                return d.call(y || r, ht || window.event);
              },
              q = U;
            !me.touchNative && me.pointer && c.indexOf('touch') === 0
              ? (U = Ln(r, c, U))
              : me.touch && c === 'dblclick'
                ? (U = Kt(r, U))
                : 'addEventListener' in r
                  ? c === 'touchstart' || c === 'touchmove' || c === 'wheel' || c === 'mousewheel'
                    ? r.addEventListener(Fs[c] || c, U, me.passiveEvents ? { passive: !1 } : !1)
                    : c === 'mouseenter' || c === 'mouseleave'
                      ? ((U = function (ht) {
                          (ht = ht || window.event), ar(r, ht) && q(ht);
                        }),
                        r.addEventListener(Fs[c], U, !1))
                      : r.addEventListener(c, q, !1)
                  : r.attachEvent('on' + c, U),
              (r[Bi] = r[Bi] || {}),
              (r[Bi][w] = U);
          }
          function ia(r, c, d, y, w) {
            w = w || c + _(d) + (y ? '_' + _(y) : '');
            var U = r[Bi] && r[Bi][w];
            if (!U) return this;
            !me.touchNative && me.pointer && c.indexOf('touch') === 0
              ? Ro(r, c, U)
              : me.touch && c === 'dblclick'
                ? Jt(r, U)
                : 'removeEventListener' in r
                  ? r.removeEventListener(Fs[c] || c, U, !1)
                  : r.detachEvent('on' + c, U),
              (r[Bi][w] = null);
          }
          function xa(r) {
            return (
              r.stopPropagation
                ? r.stopPropagation()
                : r.originalEvent
                  ? (r.originalEvent._stopped = !0)
                  : (r.cancelBubble = !0),
              this
            );
          }
          function Vr(r) {
            return nr(r, 'wheel', xa), this;
          }
          function Wr(r) {
            return (
              De(r, 'mousedown touchstart dblclick contextmenu', xa),
              (r._leaflet_disable_click = !0),
              this
            );
          }
          function Dn(r) {
            return r.preventDefault ? r.preventDefault() : (r.returnValue = !1), this;
          }
          function aa(r) {
            return Dn(r), xa(r), this;
          }
          function $l(r) {
            if (r.composedPath) return r.composedPath();
            for (var c = [], d = r.target; d; ) c.push(d), (d = d.parentNode);
            return c;
          }
          function ai(r, c) {
            if (!c) return new K(r.clientX, r.clientY);
            var d = Ua(c),
              y = d.boundingClientRect;
            return new K(
              (r.clientX - y.left) / d.x - c.clientLeft,
              (r.clientY - y.top) / d.y - c.clientTop,
            );
          }
          var ir =
            me.linux && me.chrome
              ? window.devicePixelRatio
              : me.mac
                ? window.devicePixelRatio * 3
                : window.devicePixelRatio > 0
                  ? 2 * window.devicePixelRatio
                  : 1;
          function Hs(r) {
            return me.edge
              ? r.wheelDeltaY / 2
              : r.deltaY && r.deltaMode === 0
                ? -r.deltaY / ir
                : r.deltaY && r.deltaMode === 1
                  ? -r.deltaY * 20
                  : r.deltaY && r.deltaMode === 2
                    ? -r.deltaY * 60
                    : r.deltaX || r.deltaZ
                      ? 0
                      : r.wheelDelta
                        ? (r.wheelDeltaY || r.wheelDelta) / 2
                        : r.detail && Math.abs(r.detail) < 32765
                          ? -r.detail * 20
                          : r.detail
                            ? (r.detail / -32765) * 60
                            : 0;
          }
          function ar(r, c) {
            var d = c.relatedTarget;
            if (!d) return !0;
            try {
              for (; d && d !== r; ) d = d.parentNode;
            } catch {
              return !1;
            }
            return d !== r;
          }
          var Kf = {
              __proto__: null,
              on: De,
              off: $e,
              stopPropagation: xa,
              disableScrollPropagation: Vr,
              disableClickPropagation: Wr,
              preventDefault: Dn,
              stop: aa,
              getPropagationPath: $l,
              getMousePosition: ai,
              getWheelDelta: Hs,
              isExternalTarget: ar,
              addListener: De,
              removeListener: $e,
            },
            Oo = it.extend({
              run: function (r, c, d, y) {
                this.stop(),
                  (this._el = r),
                  (this._inProgress = !0),
                  (this._duration = d || 0.25),
                  (this._easeOutPower = 1 / Math.max(y || 0.5, 0.2)),
                  (this._startPos = xn(r)),
                  (this._offset = c.subtract(this._startPos)),
                  (this._startTime = +new Date()),
                  this.fire('start'),
                  this._animate();
              },
              stop: function () {
                this._inProgress && (this._step(!0), this._complete());
              },
              _animate: function () {
                (this._animId = j(this._animate, this)), this._step();
              },
              _step: function (r) {
                var c = +new Date() - this._startTime,
                  d = this._duration * 1e3;
                c < d
                  ? this._runFrame(this._easeOut(c / d), r)
                  : (this._runFrame(1), this._complete());
              },
              _runFrame: function (r, c) {
                var d = this._startPos.add(this._offset.multiplyBy(r));
                c && d._round(), He(this._el, d), this.fire('step');
              },
              _complete: function () {
                ft(this._animId), (this._inProgress = !1), this.fire('end');
              },
              _easeOut: function (r) {
                return 1 - Math.pow(1 - r, this._easeOutPower);
              },
            }),
            Ze = it.extend({
              options: {
                crs: ye,
                center: void 0,
                zoom: void 0,
                minZoom: void 0,
                maxZoom: void 0,
                layers: [],
                maxBounds: void 0,
                renderer: void 0,
                zoomAnimation: !0,
                zoomAnimationThreshold: 4,
                fadeAnimation: !0,
                markerZoomAnimation: !0,
                transform3DLimit: 8388608,
                zoomSnap: 1,
                zoomDelta: 1,
                trackResize: !0,
              },
              initialize: function (r, c) {
                (c = R(this, c)),
                  (this._handlers = []),
                  (this._layers = {}),
                  (this._zoomBoundLayers = {}),
                  (this._sizeChanged = !0),
                  this._initContainer(r),
                  this._initLayout(),
                  (this._onResize = f(this._onResize, this)),
                  this._initEvents(),
                  c.maxBounds && this.setMaxBounds(c.maxBounds),
                  c.zoom !== void 0 && (this._zoom = this._limitZoom(c.zoom)),
                  c.center &&
                    c.zoom !== void 0 &&
                    this.setView(_t(c.center), c.zoom, { reset: !0 }),
                  this.callInitHooks(),
                  (this._zoomAnimated =
                    Ee && me.any3d && !me.mobileOpera && this.options.zoomAnimation),
                  this._zoomAnimated &&
                    (this._createAnimProxy(), De(this._proxy, be, this._catchTransitionEnd, this)),
                  this._addLayers(this.options.layers);
              },
              setView: function (r, c, d) {
                if (
                  ((c = c === void 0 ? this._zoom : this._limitZoom(c)),
                  (r = this._limitCenter(_t(r), c, this.options.maxBounds)),
                  (d = d || {}),
                  this._stop(),
                  this._loaded && !d.reset && d !== !0)
                ) {
                  d.animate !== void 0 &&
                    ((d.zoom = l({ animate: d.animate }, d.zoom)),
                    (d.pan = l({ animate: d.animate, duration: d.duration }, d.pan)));
                  var y =
                    this._zoom !== c
                      ? this._tryAnimatedZoom && this._tryAnimatedZoom(r, c, d.zoom)
                      : this._tryAnimatedPan(r, d.pan);
                  if (y) return clearTimeout(this._sizeTimer), this;
                }
                return this._resetView(r, c, d.pan && d.pan.noMoveStart), this;
              },
              setZoom: function (r, c) {
                return this._loaded
                  ? this.setView(this.getCenter(), r, { zoom: c })
                  : ((this._zoom = r), this);
              },
              zoomIn: function (r, c) {
                return (
                  (r = r || (me.any3d ? this.options.zoomDelta : 1)),
                  this.setZoom(this._zoom + r, c)
                );
              },
              zoomOut: function (r, c) {
                return (
                  (r = r || (me.any3d ? this.options.zoomDelta : 1)),
                  this.setZoom(this._zoom - r, c)
                );
              },
              setZoomAround: function (r, c, d) {
                var y = this.getZoomScale(c),
                  w = this.getSize().divideBy(2),
                  U = r instanceof K ? r : this.latLngToContainerPoint(r),
                  q = U.subtract(w).multiplyBy(1 - 1 / y),
                  ht = this.containerPointToLatLng(w.add(q));
                return this.setView(ht, c, { zoom: d });
              },
              _getBoundsCenterZoom: function (r, c) {
                (c = c || {}), (r = r.getBounds ? r.getBounds() : tt(r));
                var d = N(c.paddingTopLeft || c.padding || [0, 0]),
                  y = N(c.paddingBottomRight || c.padding || [0, 0]),
                  w = this.getBoundsZoom(r, !1, d.add(y));
                if (((w = typeof c.maxZoom == 'number' ? Math.min(c.maxZoom, w) : w), w === 1 / 0))
                  return { center: r.getCenter(), zoom: w };
                var U = y.subtract(d).divideBy(2),
                  q = this.project(r.getSouthWest(), w),
                  ht = this.project(r.getNorthEast(), w),
                  St = this.unproject(q.add(ht).divideBy(2).add(U), w);
                return { center: St, zoom: w };
              },
              fitBounds: function (r, c) {
                if (((r = tt(r)), !r.isValid())) throw new Error('Bounds are not valid.');
                var d = this._getBoundsCenterZoom(r, c);
                return this.setView(d.center, d.zoom, c);
              },
              fitWorld: function (r) {
                return this.fitBounds(
                  [
                    [-90, -180],
                    [90, 180],
                  ],
                  r,
                );
              },
              panTo: function (r, c) {
                return this.setView(r, this._zoom, { pan: c });
              },
              panBy: function (r, c) {
                if (((r = N(r).round()), (c = c || {}), !r.x && !r.y)) return this.fire('moveend');
                if (c.animate !== !0 && !this.getSize().contains(r))
                  return (
                    this._resetView(
                      this.unproject(this.project(this.getCenter()).add(r)),
                      this.getZoom(),
                    ),
                    this
                  );
                if (
                  (this._panAnim ||
                    ((this._panAnim = new Oo()),
                    this._panAnim.on(
                      { step: this._onPanTransitionStep, end: this._onPanTransitionEnd },
                      this,
                    )),
                  c.noMoveStart || this.fire('movestart'),
                  c.animate !== !1)
                ) {
                  ne(this._mapPane, 'leaflet-pan-anim');
                  var d = this._getMapPanePos().subtract(r).round();
                  this._panAnim.run(this._mapPane, d, c.duration || 0.25, c.easeLinearity);
                } else this._rawPanBy(r), this.fire('move').fire('moveend');
                return this;
              },
              flyTo: function (r, c, d) {
                if (((d = d || {}), d.animate === !1 || !me.any3d)) return this.setView(r, c, d);
                this._stop();
                var y = this.project(this.getCenter()),
                  w = this.project(r),
                  U = this.getSize(),
                  q = this._zoom;
                (r = _t(r)), (c = c === void 0 ? q : c);
                var ht = Math.max(U.x, U.y),
                  St = ht * this.getZoomScale(q, c),
                  Ft = w.distanceTo(y) || 1,
                  ie = 1.42,
                  he = ie * ie;
                function _e(Sn) {
                  var oa = Sn ? -1 : 1,
                    ba = Sn ? St : ht,
                    ka = St * St - ht * ht + oa * he * he * Ft * Ft,
                    Ea = 2 * ba * he * Ft,
                    to = ka / Ea,
                    Xo = Math.sqrt(to * to + 1) - to,
                    eo = Xo < 1e-9 ? -18 : Math.log(Xo);
                  return eo;
                }
                function Le(Sn) {
                  return (Math.exp(Sn) - Math.exp(-Sn)) / 2;
                }
                function vn(Sn) {
                  return (Math.exp(Sn) + Math.exp(-Sn)) / 2;
                }
                function Tn(Sn) {
                  return Le(Sn) / vn(Sn);
                }
                var Jn = _e(0);
                function Ri(Sn) {
                  return ht * (vn(Jn) / vn(Jn + ie * Sn));
                }
                function Xu(Sn) {
                  return (ht * (vn(Jn) * Tn(Jn + ie * Sn) - Le(Jn))) / he;
                }
                function ju(Sn) {
                  return 1 - Math.pow(1 - Sn, 1.5);
                }
                var $s = Date.now(),
                  ns = (_e(1) - Jn) / ie,
                  qu = d.duration ? 1e3 * d.duration : 1e3 * ns * 0.8;
                function is() {
                  var Sn = (Date.now() - $s) / qu,
                    oa = ju(Sn) * ns;
                  Sn <= 1
                    ? ((this._flyToFrame = j(is, this)),
                      this._move(
                        this.unproject(y.add(w.subtract(y).multiplyBy(Xu(oa) / Ft)), q),
                        this.getScaleZoom(ht / Ri(oa), q),
                        { flyTo: !0 },
                      ))
                    : this._move(r, c)._moveEnd(!0);
                }
                return this._moveStart(!0, d.noMoveStart), is.call(this), this;
              },
              flyToBounds: function (r, c) {
                var d = this._getBoundsCenterZoom(r, c);
                return this.flyTo(d.center, d.zoom, c);
              },
              setMaxBounds: function (r) {
                return (
                  (r = tt(r)),
                  this.listens('moveend', this._panInsideMaxBounds) &&
                    this.off('moveend', this._panInsideMaxBounds),
                  r.isValid()
                    ? ((this.options.maxBounds = r),
                      this._loaded && this._panInsideMaxBounds(),
                      this.on('moveend', this._panInsideMaxBounds))
                    : ((this.options.maxBounds = null), this)
                );
              },
              setMinZoom: function (r) {
                var c = this.options.minZoom;
                return (
                  (this.options.minZoom = r),
                  this._loaded &&
                  c !== r &&
                  (this.fire('zoomlevelschange'), this.getZoom() < this.options.minZoom)
                    ? this.setZoom(r)
                    : this
                );
              },
              setMaxZoom: function (r) {
                var c = this.options.maxZoom;
                return (
                  (this.options.maxZoom = r),
                  this._loaded &&
                  c !== r &&
                  (this.fire('zoomlevelschange'), this.getZoom() > this.options.maxZoom)
                    ? this.setZoom(r)
                    : this
                );
              },
              panInsideBounds: function (r, c) {
                this._enforcingBounds = !0;
                var d = this.getCenter(),
                  y = this._limitCenter(d, this._zoom, tt(r));
                return d.equals(y) || this.panTo(y, c), (this._enforcingBounds = !1), this;
              },
              panInside: function (r, c) {
                c = c || {};
                var d = N(c.paddingTopLeft || c.padding || [0, 0]),
                  y = N(c.paddingBottomRight || c.padding || [0, 0]),
                  w = this.project(this.getCenter()),
                  U = this.project(r),
                  q = this.getPixelBounds(),
                  ht = gt([q.min.add(d), q.max.subtract(y)]),
                  St = ht.getSize();
                if (!ht.contains(U)) {
                  this._enforcingBounds = !0;
                  var Ft = U.subtract(ht.getCenter()),
                    ie = ht.extend(U).getSize().subtract(St);
                  (w.x += Ft.x < 0 ? -ie.x : ie.x),
                    (w.y += Ft.y < 0 ? -ie.y : ie.y),
                    this.panTo(this.unproject(w), c),
                    (this._enforcingBounds = !1);
                }
                return this;
              },
              invalidateSize: function (r) {
                if (!this._loaded) return this;
                r = l({ animate: !1, pan: !0 }, r === !0 ? { animate: !0 } : r);
                var c = this.getSize();
                (this._sizeChanged = !0), (this._lastCenter = null);
                var d = this.getSize(),
                  y = c.divideBy(2).round(),
                  w = d.divideBy(2).round(),
                  U = y.subtract(w);
                return !U.x && !U.y
                  ? this
                  : (r.animate && r.pan
                      ? this.panBy(U)
                      : (r.pan && this._rawPanBy(U),
                        this.fire('move'),
                        r.debounceMoveend
                          ? (clearTimeout(this._sizeTimer),
                            (this._sizeTimer = setTimeout(f(this.fire, this, 'moveend'), 200)))
                          : this.fire('moveend')),
                    this.fire('resize', { oldSize: c, newSize: d }));
              },
              stop: function () {
                return (
                  this.setZoom(this._limitZoom(this._zoom)),
                  this.options.zoomSnap || this.fire('viewreset'),
                  this._stop()
                );
              },
              locate: function (r) {
                if (
                  ((r = this._locateOptions = l({ timeout: 1e4, watch: !1 }, r)),
                  !('geolocation' in navigator))
                )
                  return (
                    this._handleGeolocationError({
                      code: 0,
                      message: 'Geolocation not supported.',
                    }),
                    this
                  );
                var c = f(this._handleGeolocationResponse, this),
                  d = f(this._handleGeolocationError, this);
                return (
                  r.watch
                    ? (this._locationWatchId = navigator.geolocation.watchPosition(c, d, r))
                    : navigator.geolocation.getCurrentPosition(c, d, r),
                  this
                );
              },
              stopLocate: function () {
                return (
                  navigator.geolocation &&
                    navigator.geolocation.clearWatch &&
                    navigator.geolocation.clearWatch(this._locationWatchId),
                  this._locateOptions && (this._locateOptions.setView = !1),
                  this
                );
              },
              _handleGeolocationError: function (r) {
                if (this._container._leaflet_id) {
                  var c = r.code,
                    d =
                      r.message ||
                      (c === 1
                        ? 'permission denied'
                        : c === 2
                          ? 'position unavailable'
                          : 'timeout');
                  this._locateOptions.setView && !this._loaded && this.fitWorld(),
                    this.fire('locationerror', {
                      code: c,
                      message: 'Geolocation error: ' + d + '.',
                    });
                }
              },
              _handleGeolocationResponse: function (r) {
                if (this._container._leaflet_id) {
                  var c = r.coords.latitude,
                    d = r.coords.longitude,
                    y = new st(c, d),
                    w = y.toBounds(r.coords.accuracy * 2),
                    U = this._locateOptions;
                  if (U.setView) {
                    var q = this.getBoundsZoom(w);
                    this.setView(y, U.maxZoom ? Math.min(q, U.maxZoom) : q);
                  }
                  var ht = { latlng: y, bounds: w, timestamp: r.timestamp };
                  for (var St in r.coords)
                    typeof r.coords[St] == 'number' && (ht[St] = r.coords[St]);
                  this.fire('locationfound', ht);
                }
              },
              addHandler: function (r, c) {
                if (!c) return this;
                var d = (this[r] = new c(this));
                return this._handlers.push(d), this.options[r] && d.enable(), this;
              },
              remove: function () {
                if (
                  (this._initEvents(!0),
                  this.options.maxBounds && this.off('moveend', this._panInsideMaxBounds),
                  this._containerId !== this._container._leaflet_id)
                )
                  throw new Error('Map container is being reused by another instance');
                try {
                  delete this._container._leaflet_id, delete this._containerId;
                } catch {
                  (this._container._leaflet_id = void 0), (this._containerId = void 0);
                }
                this._locationWatchId !== void 0 && this.stopLocate(),
                  this._stop(),
                  Re(this._mapPane),
                  this._clearControlPos && this._clearControlPos(),
                  this._resizeRequest && (ft(this._resizeRequest), (this._resizeRequest = null)),
                  this._clearHandlers(),
                  this._loaded && this.fire('unload');
                var r;
                for (r in this._layers) this._layers[r].remove();
                for (r in this._panes) Re(this._panes[r]);
                return (
                  (this._layers = []),
                  (this._panes = []),
                  delete this._mapPane,
                  delete this._renderer,
                  this
                );
              },
              createPane: function (r, c) {
                var d = 'leaflet-pane' + (r ? ' leaflet-' + r.replace('Pane', '') + '-pane' : ''),
                  y = ue('div', d, c || this._mapPane);
                return r && (this._panes[r] = y), y;
              },
              getCenter: function () {
                return (
                  this._checkIfLoaded(),
                  this._lastCenter && !this._moved()
                    ? this._lastCenter.clone()
                    : this.layerPointToLatLng(this._getCenterLayerPoint())
                );
              },
              getZoom: function () {
                return this._zoom;
              },
              getBounds: function () {
                var r = this.getPixelBounds(),
                  c = this.unproject(r.getBottomLeft()),
                  d = this.unproject(r.getTopRight());
                return new At(c, d);
              },
              getMinZoom: function () {
                return this.options.minZoom === void 0
                  ? this._layersMinZoom || 0
                  : this.options.minZoom;
              },
              getMaxZoom: function () {
                return this.options.maxZoom === void 0
                  ? this._layersMaxZoom === void 0
                    ? 1 / 0
                    : this._layersMaxZoom
                  : this.options.maxZoom;
              },
              getBoundsZoom: function (r, c, d) {
                (r = tt(r)), (d = N(d || [0, 0]));
                var y = this.getZoom() || 0,
                  w = this.getMinZoom(),
                  U = this.getMaxZoom(),
                  q = r.getNorthWest(),
                  ht = r.getSouthEast(),
                  St = this.getSize().subtract(d),
                  Ft = gt(this.project(ht, y), this.project(q, y)).getSize(),
                  ie = me.any3d ? this.options.zoomSnap : 1,
                  he = St.x / Ft.x,
                  _e = St.y / Ft.y,
                  Le = c ? Math.max(he, _e) : Math.min(he, _e);
                return (
                  (y = this.getScaleZoom(Le, y)),
                  ie &&
                    ((y = Math.round(y / (ie / 100)) * (ie / 100)),
                    (y = c ? Math.ceil(y / ie) * ie : Math.floor(y / ie) * ie)),
                  Math.max(w, Math.min(U, y))
                );
              },
              getSize: function () {
                return (
                  (!this._size || this._sizeChanged) &&
                    ((this._size = new K(
                      this._container.clientWidth || 0,
                      this._container.clientHeight || 0,
                    )),
                    (this._sizeChanged = !1)),
                  this._size.clone()
                );
              },
              getPixelBounds: function (r, c) {
                var d = this._getTopLeftPoint(r, c);
                return new Q(d, d.add(this.getSize()));
              },
              getPixelOrigin: function () {
                return this._checkIfLoaded(), this._pixelOrigin;
              },
              getPixelWorldBounds: function (r) {
                return this.options.crs.getProjectedBounds(r === void 0 ? this.getZoom() : r);
              },
              getPane: function (r) {
                return typeof r == 'string' ? this._panes[r] : r;
              },
              getPanes: function () {
                return this._panes;
              },
              getContainer: function () {
                return this._container;
              },
              getZoomScale: function (r, c) {
                var d = this.options.crs;
                return (c = c === void 0 ? this._zoom : c), d.scale(r) / d.scale(c);
              },
              getScaleZoom: function (r, c) {
                var d = this.options.crs;
                c = c === void 0 ? this._zoom : c;
                var y = d.zoom(r * d.scale(c));
                return isNaN(y) ? 1 / 0 : y;
              },
              project: function (r, c) {
                return (
                  (c = c === void 0 ? this._zoom : c), this.options.crs.latLngToPoint(_t(r), c)
                );
              },
              unproject: function (r, c) {
                return (c = c === void 0 ? this._zoom : c), this.options.crs.pointToLatLng(N(r), c);
              },
              layerPointToLatLng: function (r) {
                var c = N(r).add(this.getPixelOrigin());
                return this.unproject(c);
              },
              latLngToLayerPoint: function (r) {
                var c = this.project(_t(r))._round();
                return c._subtract(this.getPixelOrigin());
              },
              wrapLatLng: function (r) {
                return this.options.crs.wrapLatLng(_t(r));
              },
              wrapLatLngBounds: function (r) {
                return this.options.crs.wrapLatLngBounds(tt(r));
              },
              distance: function (r, c) {
                return this.options.crs.distance(_t(r), _t(c));
              },
              containerPointToLayerPoint: function (r) {
                return N(r).subtract(this._getMapPanePos());
              },
              layerPointToContainerPoint: function (r) {
                return N(r).add(this._getMapPanePos());
              },
              containerPointToLatLng: function (r) {
                var c = this.containerPointToLayerPoint(N(r));
                return this.layerPointToLatLng(c);
              },
              latLngToContainerPoint: function (r) {
                return this.layerPointToContainerPoint(this.latLngToLayerPoint(_t(r)));
              },
              mouseEventToContainerPoint: function (r) {
                return ai(r, this._container);
              },
              mouseEventToLayerPoint: function (r) {
                return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(r));
              },
              mouseEventToLatLng: function (r) {
                return this.layerPointToLatLng(this.mouseEventToLayerPoint(r));
              },
              _initContainer: function (r) {
                var c = (this._container = ve(r));
                if (c) {
                  if (c._leaflet_id) throw new Error('Map container is already initialized.');
                } else throw new Error('Map container not found.');
                De(c, 'scroll', this._onScroll, this), (this._containerId = _(c));
              },
              _initLayout: function () {
                var r = this._container;
                (this._fadeAnimated = this.options.fadeAnimation && me.any3d),
                  ne(
                    r,
                    'leaflet-container' +
                      (me.touch ? ' leaflet-touch' : '') +
                      (me.retina ? ' leaflet-retina' : '') +
                      (me.ielt9 ? ' leaflet-oldie' : '') +
                      (me.safari ? ' leaflet-safari' : '') +
                      (this._fadeAnimated ? ' leaflet-fade-anim' : ''),
                  );
                var c = Ue(r, 'position');
                c !== 'absolute' &&
                  c !== 'relative' &&
                  c !== 'fixed' &&
                  c !== 'sticky' &&
                  (r.style.position = 'relative'),
                  this._initPanes(),
                  this._initControlPos && this._initControlPos();
              },
              _initPanes: function () {
                var r = (this._panes = {});
                (this._paneRenderers = {}),
                  (this._mapPane = this.createPane('mapPane', this._container)),
                  He(this._mapPane, new K(0, 0)),
                  this.createPane('tilePane'),
                  this.createPane('overlayPane'),
                  this.createPane('shadowPane'),
                  this.createPane('markerPane'),
                  this.createPane('tooltipPane'),
                  this.createPane('popupPane'),
                  this.options.markerZoomAnimation ||
                    (ne(r.markerPane, 'leaflet-zoom-hide'), ne(r.shadowPane, 'leaflet-zoom-hide'));
              },
              _resetView: function (r, c, d) {
                He(this._mapPane, new K(0, 0));
                var y = !this._loaded;
                (this._loaded = !0), (c = this._limitZoom(c)), this.fire('viewprereset');
                var w = this._zoom !== c;
                this._moveStart(w, d)._move(r, c)._moveEnd(w),
                  this.fire('viewreset'),
                  y && this.fire('load');
              },
              _moveStart: function (r, c) {
                return r && this.fire('zoomstart'), c || this.fire('movestart'), this;
              },
              _move: function (r, c, d, y) {
                c === void 0 && (c = this._zoom);
                var w = this._zoom !== c;
                return (
                  (this._zoom = c),
                  (this._lastCenter = r),
                  (this._pixelOrigin = this._getNewPixelOrigin(r)),
                  y
                    ? d && d.pinch && this.fire('zoom', d)
                    : ((w || (d && d.pinch)) && this.fire('zoom', d), this.fire('move', d)),
                  this
                );
              },
              _moveEnd: function (r) {
                return r && this.fire('zoomend'), this.fire('moveend');
              },
              _stop: function () {
                return ft(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
              },
              _rawPanBy: function (r) {
                He(this._mapPane, this._getMapPanePos().subtract(r));
              },
              _getZoomSpan: function () {
                return this.getMaxZoom() - this.getMinZoom();
              },
              _panInsideMaxBounds: function () {
                this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
              },
              _checkIfLoaded: function () {
                if (!this._loaded) throw new Error('Set map center and zoom first.');
              },
              _initEvents: function (r) {
                (this._targets = {}), (this._targets[_(this._container)] = this);
                var c = r ? $e : De;
                c(
                  this._container,
                  'click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup',
                  this._handleDOMEvent,
                  this,
                ),
                  this.options.trackResize && c(window, 'resize', this._onResize, this),
                  me.any3d &&
                    this.options.transform3DLimit &&
                    (r ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
              },
              _onResize: function () {
                ft(this._resizeRequest),
                  (this._resizeRequest = j(function () {
                    this.invalidateSize({ debounceMoveend: !0 });
                  }, this));
              },
              _onScroll: function () {
                (this._container.scrollTop = 0), (this._container.scrollLeft = 0);
              },
              _onMoveEnd: function () {
                var r = this._getMapPanePos();
                Math.max(Math.abs(r.x), Math.abs(r.y)) >= this.options.transform3DLimit &&
                  this._resetView(this.getCenter(), this.getZoom());
              },
              _findEventTargets: function (r, c) {
                for (
                  var d = [],
                    y,
                    w = c === 'mouseout' || c === 'mouseover',
                    U = r.target || r.srcElement,
                    q = !1;
                  U;

                ) {
                  if (
                    ((y = this._targets[_(U)]),
                    y && (c === 'click' || c === 'preclick') && this._draggableMoved(y))
                  ) {
                    q = !0;
                    break;
                  }
                  if (
                    (y && y.listens(c, !0) && ((w && !ar(U, r)) || (d.push(y), w))) ||
                    U === this._container
                  )
                    break;
                  U = U.parentNode;
                }
                return !d.length && !q && !w && this.listens(c, !0) && (d = [this]), d;
              },
              _isClickDisabled: function (r) {
                for (; r && r !== this._container; ) {
                  if (r._leaflet_disable_click) return !0;
                  r = r.parentNode;
                }
              },
              _handleDOMEvent: function (r) {
                var c = r.target || r.srcElement;
                if (
                  !(
                    !this._loaded ||
                    c._leaflet_disable_events ||
                    (r.type === 'click' && this._isClickDisabled(c))
                  )
                ) {
                  var d = r.type;
                  d === 'mousedown' && ks(c), this._fireDOMEvent(r, d);
                }
              },
              _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],
              _fireDOMEvent: function (r, c, d) {
                if (r.type === 'click') {
                  var y = l({}, r);
                  (y.type = 'preclick'), this._fireDOMEvent(y, y.type, d);
                }
                var w = this._findEventTargets(r, c);
                if (d) {
                  for (var U = [], q = 0; q < d.length; q++) d[q].listens(c, !0) && U.push(d[q]);
                  w = U.concat(w);
                }
                if (w.length) {
                  c === 'contextmenu' && Dn(r);
                  var ht = w[0],
                    St = { originalEvent: r };
                  if (r.type !== 'keypress' && r.type !== 'keydown' && r.type !== 'keyup') {
                    var Ft = ht.getLatLng && (!ht._radius || ht._radius <= 10);
                    (St.containerPoint = Ft
                      ? this.latLngToContainerPoint(ht.getLatLng())
                      : this.mouseEventToContainerPoint(r)),
                      (St.layerPoint = this.containerPointToLayerPoint(St.containerPoint)),
                      (St.latlng = Ft ? ht.getLatLng() : this.layerPointToLatLng(St.layerPoint));
                  }
                  for (q = 0; q < w.length; q++)
                    if (
                      (w[q].fire(c, St, !0),
                      St.originalEvent._stopped ||
                        (w[q].options.bubblingMouseEvents === !1 && D(this._mouseEvents, c) !== -1))
                    )
                      return;
                }
              },
              _draggableMoved: function (r) {
                return (
                  (r = r.dragging && r.dragging.enabled() ? r : this),
                  (r.dragging && r.dragging.moved()) || (this.boxZoom && this.boxZoom.moved())
                );
              },
              _clearHandlers: function () {
                for (var r = 0, c = this._handlers.length; r < c; r++) this._handlers[r].disable();
              },
              whenReady: function (r, c) {
                return (
                  this._loaded ? r.call(c || this, { target: this }) : this.on('load', r, c), this
                );
              },
              _getMapPanePos: function () {
                return xn(this._mapPane) || new K(0, 0);
              },
              _moved: function () {
                var r = this._getMapPanePos();
                return r && !r.equals([0, 0]);
              },
              _getTopLeftPoint: function (r, c) {
                var d = r && c !== void 0 ? this._getNewPixelOrigin(r, c) : this.getPixelOrigin();
                return d.subtract(this._getMapPanePos());
              },
              _getNewPixelOrigin: function (r, c) {
                var d = this.getSize()._divideBy(2);
                return this.project(r, c)._subtract(d)._add(this._getMapPanePos())._round();
              },
              _latLngToNewLayerPoint: function (r, c, d) {
                var y = this._getNewPixelOrigin(d, c);
                return this.project(r, c)._subtract(y);
              },
              _latLngBoundsToNewLayerBounds: function (r, c, d) {
                var y = this._getNewPixelOrigin(d, c);
                return gt([
                  this.project(r.getSouthWest(), c)._subtract(y),
                  this.project(r.getNorthWest(), c)._subtract(y),
                  this.project(r.getSouthEast(), c)._subtract(y),
                  this.project(r.getNorthEast(), c)._subtract(y),
                ]);
              },
              _getCenterLayerPoint: function () {
                return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
              },
              _getCenterOffset: function (r) {
                return this.latLngToLayerPoint(r).subtract(this._getCenterLayerPoint());
              },
              _limitCenter: function (r, c, d) {
                if (!d) return r;
                var y = this.project(r, c),
                  w = this.getSize().divideBy(2),
                  U = new Q(y.subtract(w), y.add(w)),
                  q = this._getBoundsOffset(U, d, c);
                return Math.abs(q.x) <= 1 && Math.abs(q.y) <= 1 ? r : this.unproject(y.add(q), c);
              },
              _limitOffset: function (r, c) {
                if (!c) return r;
                var d = this.getPixelBounds(),
                  y = new Q(d.min.add(r), d.max.add(r));
                return r.add(this._getBoundsOffset(y, c));
              },
              _getBoundsOffset: function (r, c, d) {
                var y = gt(this.project(c.getNorthEast(), d), this.project(c.getSouthWest(), d)),
                  w = y.min.subtract(r.min),
                  U = y.max.subtract(r.max),
                  q = this._rebound(w.x, -U.x),
                  ht = this._rebound(w.y, -U.y);
                return new K(q, ht);
              },
              _rebound: function (r, c) {
                return r + c > 0
                  ? Math.round(r - c) / 2
                  : Math.max(0, Math.ceil(r)) - Math.max(0, Math.floor(c));
              },
              _limitZoom: function (r) {
                var c = this.getMinZoom(),
                  d = this.getMaxZoom(),
                  y = me.any3d ? this.options.zoomSnap : 1;
                return y && (r = Math.round(r / y) * y), Math.max(c, Math.min(d, r));
              },
              _onPanTransitionStep: function () {
                this.fire('move');
              },
              _onPanTransitionEnd: function () {
                We(this._mapPane, 'leaflet-pan-anim'), this.fire('moveend');
              },
              _tryAnimatedPan: function (r, c) {
                var d = this._getCenterOffset(r)._trunc();
                return (c && c.animate) !== !0 && !this.getSize().contains(d)
                  ? !1
                  : (this.panBy(d, c), !0);
              },
              _createAnimProxy: function () {
                var r = (this._proxy = ue('div', 'leaflet-proxy leaflet-zoom-animated'));
                this._panes.mapPane.appendChild(r),
                  this.on(
                    'zoomanim',
                    function (c) {
                      var d = se,
                        y = this._proxy.style[d];
                      mn(this._proxy, this.project(c.center, c.zoom), this.getZoomScale(c.zoom, 1)),
                        y === this._proxy.style[d] &&
                          this._animatingZoom &&
                          this._onZoomTransitionEnd();
                    },
                    this,
                  ),
                  this.on('load moveend', this._animMoveEnd, this),
                  this._on('unload', this._destroyAnimProxy, this);
              },
              _destroyAnimProxy: function () {
                Re(this._proxy),
                  this.off('load moveend', this._animMoveEnd, this),
                  delete this._proxy;
              },
              _animMoveEnd: function () {
                var r = this.getCenter(),
                  c = this.getZoom();
                mn(this._proxy, this.project(r, c), this.getZoomScale(c, 1));
              },
              _catchTransitionEnd: function (r) {
                this._animatingZoom &&
                  r.propertyName.indexOf('transform') >= 0 &&
                  this._onZoomTransitionEnd();
              },
              _nothingToAnimate: function () {
                return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
              },
              _tryAnimatedZoom: function (r, c, d) {
                if (this._animatingZoom) return !0;
                if (
                  ((d = d || {}),
                  !this._zoomAnimated ||
                    d.animate === !1 ||
                    this._nothingToAnimate() ||
                    Math.abs(c - this._zoom) > this.options.zoomAnimationThreshold)
                )
                  return !1;
                var y = this.getZoomScale(c),
                  w = this._getCenterOffset(r)._divideBy(1 - 1 / y);
                return d.animate !== !0 && !this.getSize().contains(w)
                  ? !1
                  : (j(function () {
                      this._moveStart(!0, d.noMoveStart || !1)._animateZoom(r, c, !0);
                    }, this),
                    !0);
              },
              _animateZoom: function (r, c, d, y) {
                this._mapPane &&
                  (d &&
                    ((this._animatingZoom = !0),
                    (this._animateToCenter = r),
                    (this._animateToZoom = c),
                    ne(this._mapPane, 'leaflet-zoom-anim')),
                  this.fire('zoomanim', { center: r, zoom: c, noUpdate: y }),
                  this._tempFireZoomEvent ||
                    (this._tempFireZoomEvent = this._zoom !== this._animateToZoom),
                  this._move(this._animateToCenter, this._animateToZoom, void 0, !0),
                  setTimeout(f(this._onZoomTransitionEnd, this), 250));
              },
              _onZoomTransitionEnd: function () {
                this._animatingZoom &&
                  (this._mapPane && We(this._mapPane, 'leaflet-zoom-anim'),
                  (this._animatingZoom = !1),
                  this._move(this._animateToCenter, this._animateToZoom, void 0, !0),
                  this._tempFireZoomEvent && this.fire('zoom'),
                  delete this._tempFireZoomEvent,
                  this.fire('move'),
                  this._moveEnd(!0));
              },
            });
          function Gs(r, c) {
            return new Ze(r, c);
          }
          var fi = Mt.extend({
              options: { position: 'topright' },
              initialize: function (r) {
                R(this, r);
              },
              getPosition: function () {
                return this.options.position;
              },
              setPosition: function (r) {
                var c = this._map;
                return (
                  c && c.removeControl(this),
                  (this.options.position = r),
                  c && c.addControl(this),
                  this
                );
              },
              getContainer: function () {
                return this._container;
              },
              addTo: function (r) {
                this.remove(), (this._map = r);
                var c = (this._container = this.onAdd(r)),
                  d = this.getPosition(),
                  y = r._controlCorners[d];
                return (
                  ne(c, 'leaflet-control'),
                  d.indexOf('bottom') !== -1 ? y.insertBefore(c, y.firstChild) : y.appendChild(c),
                  this._map.on('unload', this.remove, this),
                  this
                );
              },
              remove: function () {
                return this._map
                  ? (Re(this._container),
                    this.onRemove && this.onRemove(this._map),
                    this._map.off('unload', this.remove, this),
                    (this._map = null),
                    this)
                  : this;
              },
              _refocusOnMap: function (r) {
                this._map &&
                  r &&
                  r.screenX > 0 &&
                  r.screenY > 0 &&
                  this._map.getContainer().focus();
              },
            }),
            Zr = function (r) {
              return new fi(r);
            };
          Ze.include({
            addControl: function (r) {
              return r.addTo(this), this;
            },
            removeControl: function (r) {
              return r.remove(), this;
            },
            _initControlPos: function () {
              var r = (this._controlCorners = {}),
                c = 'leaflet-',
                d = (this._controlContainer = ue('div', c + 'control-container', this._container));
              function y(w, U) {
                var q = c + w + ' ' + c + U;
                r[w + U] = ue('div', q, d);
              }
              y('top', 'left'), y('top', 'right'), y('bottom', 'left'), y('bottom', 'right');
            },
            _clearControlPos: function () {
              for (var r in this._controlCorners) Re(this._controlCorners[r]);
              Re(this._controlContainer),
                delete this._controlCorners,
                delete this._controlContainer;
            },
          });
          var Cu = fi.extend({
              options: {
                collapsed: !0,
                position: 'topright',
                autoZIndex: !0,
                hideSingleBase: !1,
                sortLayers: !1,
                sortFunction: function (r, c, d, y) {
                  return d < y ? -1 : y < d ? 1 : 0;
                },
              },
              initialize: function (r, c, d) {
                R(this, d),
                  (this._layerControlInputs = []),
                  (this._layers = []),
                  (this._lastZIndex = 0),
                  (this._handlingClick = !1),
                  (this._preventClick = !1);
                for (var y in r) this._addLayer(r[y], y);
                for (y in c) this._addLayer(c[y], y, !0);
              },
              onAdd: function (r) {
                this._initLayout(),
                  this._update(),
                  (this._map = r),
                  r.on('zoomend', this._checkDisabledLayers, this);
                for (var c = 0; c < this._layers.length; c++)
                  this._layers[c].layer.on('add remove', this._onLayerChange, this);
                return this._container;
              },
              addTo: function (r) {
                return fi.prototype.addTo.call(this, r), this._expandIfNotCollapsed();
              },
              onRemove: function () {
                this._map.off('zoomend', this._checkDisabledLayers, this);
                for (var r = 0; r < this._layers.length; r++)
                  this._layers[r].layer.off('add remove', this._onLayerChange, this);
              },
              addBaseLayer: function (r, c) {
                return this._addLayer(r, c), this._map ? this._update() : this;
              },
              addOverlay: function (r, c) {
                return this._addLayer(r, c, !0), this._map ? this._update() : this;
              },
              removeLayer: function (r) {
                r.off('add remove', this._onLayerChange, this);
                var c = this._getLayer(_(r));
                return (
                  c && this._layers.splice(this._layers.indexOf(c), 1),
                  this._map ? this._update() : this
                );
              },
              expand: function () {
                ne(this._container, 'leaflet-control-layers-expanded'),
                  (this._section.style.height = null);
                var r = this._map.getSize().y - (this._container.offsetTop + 50);
                return (
                  r < this._section.clientHeight
                    ? (ne(this._section, 'leaflet-control-layers-scrollbar'),
                      (this._section.style.height = r + 'px'))
                    : We(this._section, 'leaflet-control-layers-scrollbar'),
                  this._checkDisabledLayers(),
                  this
                );
              },
              collapse: function () {
                return We(this._container, 'leaflet-control-layers-expanded'), this;
              },
              _initLayout: function () {
                var r = 'leaflet-control-layers',
                  c = (this._container = ue('div', r)),
                  d = this.options.collapsed;
                c.setAttribute('aria-haspopup', !0), Wr(c), Vr(c);
                var y = (this._section = ue('section', r + '-list'));
                d &&
                  (this._map.on('click', this.collapse, this),
                  De(c, { mouseenter: this._expandSafely, mouseleave: this.collapse }, this));
                var w = (this._layersLink = ue('a', r + '-toggle', c));
                (w.href = '#'),
                  (w.title = 'Layers'),
                  w.setAttribute('role', 'button'),
                  De(
                    w,
                    {
                      keydown: function (U) {
                        U.keyCode === 13 && this._expandSafely();
                      },
                      click: function (U) {
                        Dn(U), this._expandSafely();
                      },
                    },
                    this,
                  ),
                  d || this.expand(),
                  (this._baseLayersList = ue('div', r + '-base', y)),
                  (this._separator = ue('div', r + '-separator', y)),
                  (this._overlaysList = ue('div', r + '-overlays', y)),
                  c.appendChild(y);
              },
              _getLayer: function (r) {
                for (var c = 0; c < this._layers.length; c++)
                  if (this._layers[c] && _(this._layers[c].layer) === r) return this._layers[c];
              },
              _addLayer: function (r, c, d) {
                this._map && r.on('add remove', this._onLayerChange, this),
                  this._layers.push({ layer: r, name: c, overlay: d }),
                  this.options.sortLayers &&
                    this._layers.sort(
                      f(function (y, w) {
                        return this.options.sortFunction(y.layer, w.layer, y.name, w.name);
                      }, this),
                    ),
                  this.options.autoZIndex &&
                    r.setZIndex &&
                    (this._lastZIndex++, r.setZIndex(this._lastZIndex)),
                  this._expandIfNotCollapsed();
              },
              _update: function () {
                if (!this._container) return this;
                ke(this._baseLayersList), ke(this._overlaysList), (this._layerControlInputs = []);
                var r,
                  c,
                  d,
                  y,
                  w = 0;
                for (d = 0; d < this._layers.length; d++)
                  (y = this._layers[d]),
                    this._addItem(y),
                    (c = c || y.overlay),
                    (r = r || !y.overlay),
                    (w += y.overlay ? 0 : 1);
                return (
                  this.options.hideSingleBase &&
                    ((r = r && w > 1), (this._baseLayersList.style.display = r ? '' : 'none')),
                  (this._separator.style.display = c && r ? '' : 'none'),
                  this
                );
              },
              _onLayerChange: function (r) {
                this._handlingClick || this._update();
                var c = this._getLayer(_(r.target)),
                  d = c.overlay
                    ? r.type === 'add'
                      ? 'overlayadd'
                      : 'overlayremove'
                    : r.type === 'add'
                      ? 'baselayerchange'
                      : null;
                d && this._map.fire(d, c);
              },
              _createRadioElement: function (r, c) {
                var d =
                    '<input type="radio" class="leaflet-control-layers-selector" name="' +
                    r +
                    '"' +
                    (c ? ' checked="checked"' : '') +
                    '/>',
                  y = document.createElement('div');
                return (y.innerHTML = d), y.firstChild;
              },
              _addItem: function (r) {
                var c = document.createElement('label'),
                  d = this._map.hasLayer(r.layer),
                  y;
                r.overlay
                  ? ((y = document.createElement('input')),
                    (y.type = 'checkbox'),
                    (y.className = 'leaflet-control-layers-selector'),
                    (y.defaultChecked = d))
                  : (y = this._createRadioElement('leaflet-base-layers_' + _(this), d)),
                  this._layerControlInputs.push(y),
                  (y.layerId = _(r.layer)),
                  De(y, 'click', this._onInputClick, this);
                var w = document.createElement('span');
                w.innerHTML = ' ' + r.name;
                var U = document.createElement('span');
                c.appendChild(U), U.appendChild(y), U.appendChild(w);
                var q = r.overlay ? this._overlaysList : this._baseLayersList;
                return q.appendChild(c), this._checkDisabledLayers(), c;
              },
              _onInputClick: function () {
                if (!this._preventClick) {
                  var r = this._layerControlInputs,
                    c,
                    d,
                    y = [],
                    w = [];
                  this._handlingClick = !0;
                  for (var U = r.length - 1; U >= 0; U--)
                    (c = r[U]),
                      (d = this._getLayer(c.layerId).layer),
                      c.checked ? y.push(d) : c.checked || w.push(d);
                  for (U = 0; U < w.length; U++)
                    this._map.hasLayer(w[U]) && this._map.removeLayer(w[U]);
                  for (U = 0; U < y.length; U++)
                    this._map.hasLayer(y[U]) || this._map.addLayer(y[U]);
                  (this._handlingClick = !1), this._refocusOnMap();
                }
              },
              _checkDisabledLayers: function () {
                for (
                  var r = this._layerControlInputs, c, d, y = this._map.getZoom(), w = r.length - 1;
                  w >= 0;
                  w--
                )
                  (c = r[w]),
                    (d = this._getLayer(c.layerId).layer),
                    (c.disabled =
                      (d.options.minZoom !== void 0 && y < d.options.minZoom) ||
                      (d.options.maxZoom !== void 0 && y > d.options.maxZoom));
              },
              _expandIfNotCollapsed: function () {
                return this._map && !this.options.collapsed && this.expand(), this;
              },
              _expandSafely: function () {
                var r = this._section;
                (this._preventClick = !0), De(r, 'click', Dn), this.expand();
                var c = this;
                setTimeout(function () {
                  $e(r, 'click', Dn), (c._preventClick = !1);
                });
              },
            }),
            Qf = function (r, c, d) {
              return new Cu(r, c, d);
            },
            tc = fi.extend({
              options: {
                position: 'topleft',
                zoomInText: '<span aria-hidden="true">+</span>',
                zoomInTitle: 'Zoom in',
                zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
                zoomOutTitle: 'Zoom out',
              },
              onAdd: function (r) {
                var c = 'leaflet-control-zoom',
                  d = ue('div', c + ' leaflet-bar'),
                  y = this.options;
                return (
                  (this._zoomInButton = this._createButton(
                    y.zoomInText,
                    y.zoomInTitle,
                    c + '-in',
                    d,
                    this._zoomIn,
                  )),
                  (this._zoomOutButton = this._createButton(
                    y.zoomOutText,
                    y.zoomOutTitle,
                    c + '-out',
                    d,
                    this._zoomOut,
                  )),
                  this._updateDisabled(),
                  r.on('zoomend zoomlevelschange', this._updateDisabled, this),
                  d
                );
              },
              onRemove: function (r) {
                r.off('zoomend zoomlevelschange', this._updateDisabled, this);
              },
              disable: function () {
                return (this._disabled = !0), this._updateDisabled(), this;
              },
              enable: function () {
                return (this._disabled = !1), this._updateDisabled(), this;
              },
              _zoomIn: function (r) {
                !this._disabled &&
                  this._map._zoom < this._map.getMaxZoom() &&
                  this._map.zoomIn(this._map.options.zoomDelta * (r.shiftKey ? 3 : 1));
              },
              _zoomOut: function (r) {
                !this._disabled &&
                  this._map._zoom > this._map.getMinZoom() &&
                  this._map.zoomOut(this._map.options.zoomDelta * (r.shiftKey ? 3 : 1));
              },
              _createButton: function (r, c, d, y, w) {
                var U = ue('a', d, y);
                return (
                  (U.innerHTML = r),
                  (U.href = '#'),
                  (U.title = c),
                  U.setAttribute('role', 'button'),
                  U.setAttribute('aria-label', c),
                  Wr(U),
                  De(U, 'click', aa),
                  De(U, 'click', w, this),
                  De(U, 'click', this._refocusOnMap, this),
                  U
                );
              },
              _updateDisabled: function () {
                var r = this._map,
                  c = 'leaflet-disabled';
                We(this._zoomInButton, c),
                  We(this._zoomOutButton, c),
                  this._zoomInButton.setAttribute('aria-disabled', 'false'),
                  this._zoomOutButton.setAttribute('aria-disabled', 'false'),
                  (this._disabled || r._zoom === r.getMinZoom()) &&
                    (ne(this._zoomOutButton, c),
                    this._zoomOutButton.setAttribute('aria-disabled', 'true')),
                  (this._disabled || r._zoom === r.getMaxZoom()) &&
                    (ne(this._zoomInButton, c),
                    this._zoomInButton.setAttribute('aria-disabled', 'true'));
              },
            });
          Ze.mergeOptions({ zoomControl: !0 }),
            Ze.addInitHook(function () {
              this.options.zoomControl &&
                ((this.zoomControl = new tc()), this.addControl(this.zoomControl));
            });
          var ec = function (r) {
              return new tc(r);
            },
            Ru = fi.extend({
              options: { position: 'bottomleft', maxWidth: 100, metric: !0, imperial: !0 },
              onAdd: function (r) {
                var c = 'leaflet-control-scale',
                  d = ue('div', c),
                  y = this.options;
                return (
                  this._addScales(y, c + '-line', d),
                  r.on(y.updateWhenIdle ? 'moveend' : 'move', this._update, this),
                  r.whenReady(this._update, this),
                  d
                );
              },
              onRemove: function (r) {
                r.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
              },
              _addScales: function (r, c, d) {
                r.metric && (this._mScale = ue('div', c, d)),
                  r.imperial && (this._iScale = ue('div', c, d));
              },
              _update: function () {
                var r = this._map,
                  c = r.getSize().y / 2,
                  d = r.distance(
                    r.containerPointToLatLng([0, c]),
                    r.containerPointToLatLng([this.options.maxWidth, c]),
                  );
                this._updateScales(d);
              },
              _updateScales: function (r) {
                this.options.metric && r && this._updateMetric(r),
                  this.options.imperial && r && this._updateImperial(r);
              },
              _updateMetric: function (r) {
                var c = this._getRoundNum(r),
                  d = c < 1e3 ? c + ' m' : c / 1e3 + ' km';
                this._updateScale(this._mScale, d, c / r);
              },
              _updateImperial: function (r) {
                var c = r * 3.2808399,
                  d,
                  y,
                  w;
                c > 5280
                  ? ((d = c / 5280),
                    (y = this._getRoundNum(d)),
                    this._updateScale(this._iScale, y + ' mi', y / d))
                  : ((w = this._getRoundNum(c)), this._updateScale(this._iScale, w + ' ft', w / c));
              },
              _updateScale: function (r, c, d) {
                (r.style.width = Math.round(this.options.maxWidth * d) + 'px'), (r.innerHTML = c);
              },
              _getRoundNum: function (r) {
                var c = Math.pow(10, (Math.floor(r) + '').length - 1),
                  d = r / c;
                return (d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1), c * d;
              },
            }),
            Jf = function (r) {
              return new Ru(r);
            },
            $f =
              '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>',
            nc = fi.extend({
              options: {
                position: 'bottomright',
                prefix:
                  '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' +
                  (me.inlineSvg ? $f + ' ' : '') +
                  'Leaflet</a>',
              },
              initialize: function (r) {
                R(this, r), (this._attributions = {});
              },
              onAdd: function (r) {
                (r.attributionControl = this),
                  (this._container = ue('div', 'leaflet-control-attribution')),
                  Wr(this._container);
                for (var c in r._layers)
                  r._layers[c].getAttribution && this.addAttribution(r._layers[c].getAttribution());
                return (
                  this._update(), r.on('layeradd', this._addAttribution, this), this._container
                );
              },
              onRemove: function (r) {
                r.off('layeradd', this._addAttribution, this);
              },
              _addAttribution: function (r) {
                r.layer.getAttribution &&
                  (this.addAttribution(r.layer.getAttribution()),
                  r.layer.once(
                    'remove',
                    function () {
                      this.removeAttribution(r.layer.getAttribution());
                    },
                    this,
                  ));
              },
              setPrefix: function (r) {
                return (this.options.prefix = r), this._update(), this;
              },
              addAttribution: function (r) {
                return r
                  ? (this._attributions[r] || (this._attributions[r] = 0),
                    this._attributions[r]++,
                    this._update(),
                    this)
                  : this;
              },
              removeAttribution: function (r) {
                return r
                  ? (this._attributions[r] && (this._attributions[r]--, this._update()), this)
                  : this;
              },
              _update: function () {
                if (this._map) {
                  var r = [];
                  for (var c in this._attributions) this._attributions[c] && r.push(c);
                  var d = [];
                  this.options.prefix && d.push(this.options.prefix),
                    r.length && d.push(r.join(', ')),
                    (this._container.innerHTML = d.join(' <span aria-hidden="true">|</span> '));
                }
              },
            });
          Ze.mergeOptions({ attributionControl: !0 }),
            Ze.addInitHook(function () {
              this.options.attributionControl && new nc().addTo(this);
            });
          var td = function (r) {
            return new nc(r);
          };
          (fi.Layers = Cu),
            (fi.Zoom = tc),
            (fi.Scale = Ru),
            (fi.Attribution = nc),
            (Zr.layers = Qf),
            (Zr.zoom = ec),
            (Zr.scale = Jf),
            (Zr.attribution = td);
          var ki = Mt.extend({
            initialize: function (r) {
              this._map = r;
            },
            enable: function () {
              return this._enabled ? this : ((this._enabled = !0), this.addHooks(), this);
            },
            disable: function () {
              return this._enabled ? ((this._enabled = !1), this.removeHooks(), this) : this;
            },
            enabled: function () {
              return !!this._enabled;
            },
          });
          ki.addTo = function (r, c) {
            return r.addHandler(c, this), this;
          };
          var ed = { Events: X },
            Lu = me.touch ? 'touchstart mousedown' : 'mousedown',
            Na = it.extend({
              options: { clickTolerance: 3 },
              initialize: function (r, c, d, y) {
                R(this, y),
                  (this._element = r),
                  (this._dragStartTarget = c || r),
                  (this._preventOutline = d);
              },
              enable: function () {
                this._enabled ||
                  (De(this._dragStartTarget, Lu, this._onDown, this), (this._enabled = !0));
              },
              disable: function () {
                this._enabled &&
                  (Na._dragging === this && this.finishDrag(!0),
                  $e(this._dragStartTarget, Lu, this._onDown, this),
                  (this._enabled = !1),
                  (this._moved = !1));
              },
              _onDown: function (r) {
                if (
                  this._enabled &&
                  ((this._moved = !1), !gn(this._element, 'leaflet-zoom-anim'))
                ) {
                  if (r.touches && r.touches.length !== 1) {
                    Na._dragging === this && this.finishDrag();
                    return;
                  }
                  if (
                    !(
                      Na._dragging ||
                      r.shiftKey ||
                      (r.which !== 1 && r.button !== 1 && !r.touches)
                    ) &&
                    ((Na._dragging = this),
                    this._preventOutline && ks(this._element),
                    Bs(),
                    hi(),
                    !this._moving)
                  ) {
                    this.fire('down');
                    var c = r.touches ? r.touches[0] : r,
                      d = er(this._element);
                    (this._startPoint = new K(c.clientX, c.clientY)),
                      (this._startPos = xn(this._element)),
                      (this._parentScale = Ua(d));
                    var y = r.type === 'mousedown';
                    De(document, y ? 'mousemove' : 'touchmove', this._onMove, this),
                      De(document, y ? 'mouseup' : 'touchend touchcancel', this._onUp, this);
                  }
                }
              },
              _onMove: function (r) {
                if (this._enabled) {
                  if (r.touches && r.touches.length > 1) {
                    this._moved = !0;
                    return;
                  }
                  var c = r.touches && r.touches.length === 1 ? r.touches[0] : r,
                    d = new K(c.clientX, c.clientY)._subtract(this._startPoint);
                  (!d.x && !d.y) ||
                    Math.abs(d.x) + Math.abs(d.y) < this.options.clickTolerance ||
                    ((d.x /= this._parentScale.x),
                    (d.y /= this._parentScale.y),
                    Dn(r),
                    this._moved ||
                      (this.fire('dragstart'),
                      (this._moved = !0),
                      ne(document.body, 'leaflet-dragging'),
                      (this._lastTarget = r.target || r.srcElement),
                      window.SVGElementInstance &&
                        this._lastTarget instanceof window.SVGElementInstance &&
                        (this._lastTarget = this._lastTarget.correspondingUseElement),
                      ne(this._lastTarget, 'leaflet-drag-target')),
                    (this._newPos = this._startPos.add(d)),
                    (this._moving = !0),
                    (this._lastEvent = r),
                    this._updatePosition());
                }
              },
              _updatePosition: function () {
                var r = { originalEvent: this._lastEvent };
                this.fire('predrag', r), He(this._element, this._newPos), this.fire('drag', r);
              },
              _onUp: function () {
                this._enabled && this.finishDrag();
              },
              finishDrag: function (r) {
                We(document.body, 'leaflet-dragging'),
                  this._lastTarget &&
                    (We(this._lastTarget, 'leaflet-drag-target'), (this._lastTarget = null)),
                  $e(document, 'mousemove touchmove', this._onMove, this),
                  $e(document, 'mouseup touchend touchcancel', this._onUp, this),
                  Jl(),
                  yi();
                var c = this._moved && this._moving;
                (this._moving = !1),
                  (Na._dragging = !1),
                  c &&
                    this.fire('dragend', {
                      noInertia: r,
                      distance: this._newPos.distanceTo(this._startPos),
                    });
              },
            });
          function Pu(r, c, d) {
            var y,
              w = [1, 4, 2, 8],
              U,
              q,
              ht,
              St,
              Ft,
              ie,
              he,
              _e;
            for (U = 0, ie = r.length; U < ie; U++) r[U]._code = rr(r[U], c);
            for (ht = 0; ht < 4; ht++) {
              for (he = w[ht], y = [], U = 0, ie = r.length, q = ie - 1; U < ie; q = U++)
                (St = r[U]),
                  (Ft = r[q]),
                  St._code & he
                    ? Ft._code & he ||
                      ((_e = No(Ft, St, he, c, d)), (_e._code = rr(_e, c)), y.push(_e))
                    : (Ft._code & he &&
                        ((_e = No(Ft, St, he, c, d)), (_e._code = rr(_e, c)), y.push(_e)),
                      y.push(St));
              r = y;
            }
            return r;
          }
          function Uo(r, c) {
            var d, y, w, U, q, ht, St, Ft, ie;
            if (!r || r.length === 0) throw new Error('latlngs not passed');
            Qn(r) ||
              (console.warn('latlngs are not flat! Only the first ring will be used'), (r = r[0]));
            var he = _t([0, 0]),
              _e = tt(r),
              Le =
                _e.getNorthWest().distanceTo(_e.getSouthWest()) *
                _e.getNorthEast().distanceTo(_e.getNorthWest());
            Le < 1700 && (he = ic(r));
            var vn = r.length,
              Tn = [];
            for (d = 0; d < vn; d++) {
              var Jn = _t(r[d]);
              Tn.push(c.project(_t([Jn.lat - he.lat, Jn.lng - he.lng])));
            }
            for (ht = St = Ft = 0, d = 0, y = vn - 1; d < vn; y = d++)
              (w = Tn[d]),
                (U = Tn[y]),
                (q = w.y * U.x - U.y * w.x),
                (St += (w.x + U.x) * q),
                (Ft += (w.y + U.y) * q),
                (ht += q * 3);
            ht === 0 ? (ie = Tn[0]) : (ie = [St / ht, Ft / ht]);
            var Ri = c.unproject(N(ie));
            return _t([Ri.lat + he.lat, Ri.lng + he.lng]);
          }
          function ic(r) {
            for (var c = 0, d = 0, y = 0, w = 0; w < r.length; w++) {
              var U = _t(r[w]);
              (c += U.lat), (d += U.lng), y++;
            }
            return _t([c / y, d / y]);
          }
          var nd = { __proto__: null, clipPolygon: Pu, polygonCenter: Uo, centroid: ic };
          function Du(r, c) {
            if (!c || !r.length) return r.slice();
            var d = c * c;
            return (r = rd(r, d)), (r = ad(r, d)), r;
          }
          function ac(r, c, d) {
            return Math.sqrt(sr(r, c, d, !0));
          }
          function id(r, c, d) {
            return sr(r, c, d);
          }
          function ad(r, c) {
            var d = r.length,
              y = typeof Uint8Array < 'u' ? Uint8Array : Array,
              w = new y(d);
            (w[0] = w[d - 1] = 1), rc(r, w, c, 0, d - 1);
            var U,
              q = [];
            for (U = 0; U < d; U++) w[U] && q.push(r[U]);
            return q;
          }
          function rc(r, c, d, y, w) {
            var U = 0,
              q,
              ht,
              St;
            for (ht = y + 1; ht <= w - 1; ht++)
              (St = sr(r[ht], r[y], r[w], !0)), St > U && ((q = ht), (U = St));
            U > d && ((c[q] = 1), rc(r, c, d, y, q), rc(r, c, d, q, w));
          }
          function rd(r, c) {
            for (var d = [r[0]], y = 1, w = 0, U = r.length; y < U; y++)
              sd(r[y], r[w]) > c && (d.push(r[y]), (w = y));
            return w < U - 1 && d.push(r[U - 1]), d;
          }
          var Ou;
          function Uu(r, c, d, y, w) {
            var U = y ? Ou : rr(r, d),
              q = rr(c, d),
              ht,
              St,
              Ft;
            for (Ou = q; ; ) {
              if (!(U | q)) return [r, c];
              if (U & q) return !1;
              (ht = U || q),
                (St = No(r, c, ht, d, w)),
                (Ft = rr(St, d)),
                ht === U ? ((r = St), (U = Ft)) : ((c = St), (q = Ft));
            }
          }
          function No(r, c, d, y, w) {
            var U = c.x - r.x,
              q = c.y - r.y,
              ht = y.min,
              St = y.max,
              Ft,
              ie;
            return (
              d & 8
                ? ((Ft = r.x + (U * (St.y - r.y)) / q), (ie = St.y))
                : d & 4
                  ? ((Ft = r.x + (U * (ht.y - r.y)) / q), (ie = ht.y))
                  : d & 2
                    ? ((Ft = St.x), (ie = r.y + (q * (St.x - r.x)) / U))
                    : d & 1 && ((Ft = ht.x), (ie = r.y + (q * (ht.x - r.x)) / U)),
              new K(Ft, ie, w)
            );
          }
          function rr(r, c) {
            var d = 0;
            return (
              r.x < c.min.x ? (d |= 1) : r.x > c.max.x && (d |= 2),
              r.y < c.min.y ? (d |= 4) : r.y > c.max.y && (d |= 8),
              d
            );
          }
          function sd(r, c) {
            var d = c.x - r.x,
              y = c.y - r.y;
            return d * d + y * y;
          }
          function sr(r, c, d, y) {
            var w = c.x,
              U = c.y,
              q = d.x - w,
              ht = d.y - U,
              St = q * q + ht * ht,
              Ft;
            return (
              St > 0 &&
                ((Ft = ((r.x - w) * q + (r.y - U) * ht) / St),
                Ft > 1 ? ((w = d.x), (U = d.y)) : Ft > 0 && ((w += q * Ft), (U += ht * Ft))),
              (q = r.x - w),
              (ht = r.y - U),
              y ? q * q + ht * ht : new K(w, U)
            );
          }
          function Qn(r) {
            return !P(r[0]) || (typeof r[0][0] != 'object' && typeof r[0][0] < 'u');
          }
          function Nu(r) {
            return (
              console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.'), Qn(r)
            );
          }
          function sc(r, c) {
            var d, y, w, U, q, ht, St, Ft;
            if (!r || r.length === 0) throw new Error('latlngs not passed');
            Qn(r) ||
              (console.warn('latlngs are not flat! Only the first ring will be used'), (r = r[0]));
            var ie = _t([0, 0]),
              he = tt(r),
              _e =
                he.getNorthWest().distanceTo(he.getSouthWest()) *
                he.getNorthEast().distanceTo(he.getNorthWest());
            _e < 1700 && (ie = ic(r));
            var Le = r.length,
              vn = [];
            for (d = 0; d < Le; d++) {
              var Tn = _t(r[d]);
              vn.push(c.project(_t([Tn.lat - ie.lat, Tn.lng - ie.lng])));
            }
            for (d = 0, y = 0; d < Le - 1; d++) y += vn[d].distanceTo(vn[d + 1]) / 2;
            if (y === 0) Ft = vn[0];
            else
              for (d = 0, U = 0; d < Le - 1; d++)
                if (((q = vn[d]), (ht = vn[d + 1]), (w = q.distanceTo(ht)), (U += w), U > y)) {
                  (St = (U - y) / w), (Ft = [ht.x - St * (ht.x - q.x), ht.y - St * (ht.y - q.y)]);
                  break;
                }
            var Jn = c.unproject(N(Ft));
            return _t([Jn.lat + ie.lat, Jn.lng + ie.lng]);
          }
          var zu = {
              __proto__: null,
              simplify: Du,
              pointToSegmentDistance: ac,
              closestPointOnSegment: id,
              clipSegment: Uu,
              _getEdgeIntersection: No,
              _getBitCode: rr,
              _sqClosestPointOnSegment: sr,
              isFlat: Qn,
              _flat: Nu,
              polylineCenter: sc,
            },
            zo = {
              project: function (r) {
                return new K(r.lng, r.lat);
              },
              unproject: function (r) {
                return new st(r.y, r.x);
              },
              bounds: new Q([-180, -90], [180, 90]),
            },
            Io = {
              R: 6378137,
              R_MINOR: 6356752314245179e-9,
              bounds: new Q(
                [-2003750834279e-5, -1549657073972e-5],
                [2003750834279e-5, 1876465623138e-5],
              ),
              project: function (r) {
                var c = Math.PI / 180,
                  d = this.R,
                  y = r.lat * c,
                  w = this.R_MINOR / d,
                  U = Math.sqrt(1 - w * w),
                  q = U * Math.sin(y),
                  ht = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - q) / (1 + q), U / 2);
                return (y = -d * Math.log(Math.max(ht, 1e-10))), new K(r.lng * c * d, y);
              },
              unproject: function (r) {
                for (
                  var c = 180 / Math.PI,
                    d = this.R,
                    y = this.R_MINOR / d,
                    w = Math.sqrt(1 - y * y),
                    U = Math.exp(-r.y / d),
                    q = Math.PI / 2 - 2 * Math.atan(U),
                    ht = 0,
                    St = 0.1,
                    Ft;
                  ht < 15 && Math.abs(St) > 1e-7;
                  ht++
                )
                  (Ft = w * Math.sin(q)),
                    (Ft = Math.pow((1 - Ft) / (1 + Ft), w / 2)),
                    (St = Math.PI / 2 - 2 * Math.atan(U * Ft) - q),
                    (q += St);
                return new st(q * c, (r.x * c) / d);
              },
            },
            Iu = { __proto__: null, LonLat: zo, Mercator: Io, SphericalMercator: oe },
            Xr = l({}, Gt, {
              code: 'EPSG:3395',
              projection: Io,
              transformation: (function () {
                var r = 0.5 / (Math.PI * Io.R);
                return Te(r, 0.5, -r, 0.5);
              })(),
            }),
            Bu = l({}, Gt, {
              code: 'EPSG:4326',
              projection: zo,
              transformation: Te(1 / 180, 1, -1 / 180, 0.5),
            }),
            od = l({}, It, {
              projection: zo,
              transformation: Te(1, 0, -1, 0),
              scale: function (r) {
                return Math.pow(2, r);
              },
              zoom: function (r) {
                return Math.log(r) / Math.LN2;
              },
              distance: function (r, c) {
                var d = c.lng - r.lng,
                  y = c.lat - r.lat;
                return Math.sqrt(d * d + y * y);
              },
              infinite: !0,
            });
          (It.Earth = Gt),
            (It.EPSG3395 = Xr),
            (It.EPSG3857 = ye),
            (It.EPSG900913 = G),
            (It.EPSG4326 = Bu),
            (It.Simple = od);
          var Fi = it.extend({
            options: { pane: 'overlayPane', attribution: null, bubblingMouseEvents: !0 },
            addTo: function (r) {
              return r.addLayer(this), this;
            },
            remove: function () {
              return this.removeFrom(this._map || this._mapToAdd);
            },
            removeFrom: function (r) {
              return r && r.removeLayer(this), this;
            },
            getPane: function (r) {
              return this._map.getPane(r ? this.options[r] || r : this.options.pane);
            },
            addInteractiveTarget: function (r) {
              return (this._map._targets[_(r)] = this), this;
            },
            removeInteractiveTarget: function (r) {
              return delete this._map._targets[_(r)], this;
            },
            getAttribution: function () {
              return this.options.attribution;
            },
            _layerAdd: function (r) {
              var c = r.target;
              if (c.hasLayer(this)) {
                if (((this._map = c), (this._zoomAnimated = c._zoomAnimated), this.getEvents)) {
                  var d = this.getEvents();
                  c.on(d, this),
                    this.once(
                      'remove',
                      function () {
                        c.off(d, this);
                      },
                      this,
                    );
                }
                this.onAdd(c), this.fire('add'), c.fire('layeradd', { layer: this });
              }
            },
          });
          Ze.include({
            addLayer: function (r) {
              if (!r._layerAdd) throw new Error('The provided object is not a Layer.');
              var c = _(r);
              return this._layers[c]
                ? this
                : ((this._layers[c] = r),
                  (r._mapToAdd = this),
                  r.beforeAdd && r.beforeAdd(this),
                  this.whenReady(r._layerAdd, r),
                  this);
            },
            removeLayer: function (r) {
              var c = _(r);
              return this._layers[c]
                ? (this._loaded && r.onRemove(this),
                  delete this._layers[c],
                  this._loaded && (this.fire('layerremove', { layer: r }), r.fire('remove')),
                  (r._map = r._mapToAdd = null),
                  this)
                : this;
            },
            hasLayer: function (r) {
              return _(r) in this._layers;
            },
            eachLayer: function (r, c) {
              for (var d in this._layers) r.call(c, this._layers[d]);
              return this;
            },
            _addLayers: function (r) {
              r = r ? (P(r) ? r : [r]) : [];
              for (var c = 0, d = r.length; c < d; c++) this.addLayer(r[c]);
            },
            _addZoomLimit: function (r) {
              (!isNaN(r.options.maxZoom) || !isNaN(r.options.minZoom)) &&
                ((this._zoomBoundLayers[_(r)] = r), this._updateZoomLevels());
            },
            _removeZoomLimit: function (r) {
              var c = _(r);
              this._zoomBoundLayers[c] &&
                (delete this._zoomBoundLayers[c], this._updateZoomLevels());
            },
            _updateZoomLevels: function () {
              var r = 1 / 0,
                c = -1 / 0,
                d = this._getZoomSpan();
              for (var y in this._zoomBoundLayers) {
                var w = this._zoomBoundLayers[y].options;
                (r = w.minZoom === void 0 ? r : Math.min(r, w.minZoom)),
                  (c = w.maxZoom === void 0 ? c : Math.max(c, w.maxZoom));
              }
              (this._layersMaxZoom = c === -1 / 0 ? void 0 : c),
                (this._layersMinZoom = r === 1 / 0 ? void 0 : r),
                d !== this._getZoomSpan() && this.fire('zoomlevelschange'),
                this.options.maxZoom === void 0 &&
                  this._layersMaxZoom &&
                  this.getZoom() > this._layersMaxZoom &&
                  this.setZoom(this._layersMaxZoom),
                this.options.minZoom === void 0 &&
                  this._layersMinZoom &&
                  this.getZoom() < this._layersMinZoom &&
                  this.setZoom(this._layersMinZoom);
            },
          });
          var or = Fi.extend({
              initialize: function (r, c) {
                R(this, c), (this._layers = {});
                var d, y;
                if (r) for (d = 0, y = r.length; d < y; d++) this.addLayer(r[d]);
              },
              addLayer: function (r) {
                var c = this.getLayerId(r);
                return (this._layers[c] = r), this._map && this._map.addLayer(r), this;
              },
              removeLayer: function (r) {
                var c = r in this._layers ? r : this.getLayerId(r);
                return (
                  this._map && this._layers[c] && this._map.removeLayer(this._layers[c]),
                  delete this._layers[c],
                  this
                );
              },
              hasLayer: function (r) {
                var c = typeof r == 'number' ? r : this.getLayerId(r);
                return c in this._layers;
              },
              clearLayers: function () {
                return this.eachLayer(this.removeLayer, this);
              },
              invoke: function (r) {
                var c = Array.prototype.slice.call(arguments, 1),
                  d,
                  y;
                for (d in this._layers) (y = this._layers[d]), y[r] && y[r].apply(y, c);
                return this;
              },
              onAdd: function (r) {
                this.eachLayer(r.addLayer, r);
              },
              onRemove: function (r) {
                this.eachLayer(r.removeLayer, r);
              },
              eachLayer: function (r, c) {
                for (var d in this._layers) r.call(c, this._layers[d]);
                return this;
              },
              getLayer: function (r) {
                return this._layers[r];
              },
              getLayers: function () {
                var r = [];
                return this.eachLayer(r.push, r), r;
              },
              setZIndex: function (r) {
                return this.invoke('setZIndex', r);
              },
              getLayerId: function (r) {
                return _(r);
              },
            }),
            ku = function (r, c) {
              return new or(r, c);
            },
            xi = or.extend({
              addLayer: function (r) {
                return this.hasLayer(r)
                  ? this
                  : (r.addEventParent(this),
                    or.prototype.addLayer.call(this, r),
                    this.fire('layeradd', { layer: r }));
              },
              removeLayer: function (r) {
                return this.hasLayer(r)
                  ? (r in this._layers && (r = this._layers[r]),
                    r.removeEventParent(this),
                    or.prototype.removeLayer.call(this, r),
                    this.fire('layerremove', { layer: r }))
                  : this;
              },
              setStyle: function (r) {
                return this.invoke('setStyle', r);
              },
              bringToFront: function () {
                return this.invoke('bringToFront');
              },
              bringToBack: function () {
                return this.invoke('bringToBack');
              },
              getBounds: function () {
                var r = new At();
                for (var c in this._layers) {
                  var d = this._layers[c];
                  r.extend(d.getBounds ? d.getBounds() : d.getLatLng());
                }
                return r;
              },
            }),
            Vs = function (r, c) {
              return new xi(r, c);
            },
            jr = Mt.extend({
              options: { popupAnchor: [0, 0], tooltipAnchor: [0, 0], crossOrigin: !1 },
              initialize: function (r) {
                R(this, r);
              },
              createIcon: function (r) {
                return this._createIcon('icon', r);
              },
              createShadow: function (r) {
                return this._createIcon('shadow', r);
              },
              _createIcon: function (r, c) {
                var d = this._getIconUrl(r);
                if (!d) {
                  if (r === 'icon')
                    throw new Error('iconUrl not set in Icon options (see the docs).');
                  return null;
                }
                var y = this._createImg(d, c && c.tagName === 'IMG' ? c : null);
                return (
                  this._setIconStyles(y, r),
                  (this.options.crossOrigin || this.options.crossOrigin === '') &&
                    (y.crossOrigin =
                      this.options.crossOrigin === !0 ? '' : this.options.crossOrigin),
                  y
                );
              },
              _setIconStyles: function (r, c) {
                var d = this.options,
                  y = d[c + 'Size'];
                typeof y == 'number' && (y = [y, y]);
                var w = N(y),
                  U = N(
                    (c === 'shadow' && d.shadowAnchor) || d.iconAnchor || (w && w.divideBy(2, !0)),
                  );
                (r.className = 'leaflet-marker-' + c + ' ' + (d.className || '')),
                  U && ((r.style.marginLeft = -U.x + 'px'), (r.style.marginTop = -U.y + 'px')),
                  w && ((r.style.width = w.x + 'px'), (r.style.height = w.y + 'px'));
              },
              _createImg: function (r, c) {
                return (c = c || document.createElement('img')), (c.src = r), c;
              },
              _getIconUrl: function (r) {
                return (me.retina && this.options[r + 'RetinaUrl']) || this.options[r + 'Url'];
              },
            });
          function Bo(r) {
            return new jr(r);
          }
          var qr = jr.extend({
              options: {
                iconUrl: 'marker-icon.png',
                iconRetinaUrl: 'marker-icon-2x.png',
                shadowUrl: 'marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                tooltipAnchor: [16, -28],
                shadowSize: [41, 41],
              },
              _getIconUrl: function (r) {
                return (
                  typeof qr.imagePath != 'string' && (qr.imagePath = this._detectIconPath()),
                  (this.options.imagePath || qr.imagePath) + jr.prototype._getIconUrl.call(this, r)
                );
              },
              _stripUrl: function (r) {
                var c = function (d, y, w) {
                  var U = y.exec(d);
                  return U && U[w];
                };
                return (
                  (r = c(r, /^url\((['"])?(.+)\1\)$/, 2)), r && c(r, /^(.*)marker-icon\.png$/, 1)
                );
              },
              _detectIconPath: function () {
                var r = ue('div', 'leaflet-default-icon-path', document.body),
                  c = Ue(r, 'background-image') || Ue(r, 'backgroundImage');
                if ((document.body.removeChild(r), (c = this._stripUrl(c)), c)) return c;
                var d = document.querySelector('link[href$="leaflet.css"]');
                return d ? d.href.substring(0, d.href.length - 11 - 1) : '';
              },
            }),
            oc = ki.extend({
              initialize: function (r) {
                this._marker = r;
              },
              addHooks: function () {
                var r = this._marker._icon;
                this._draggable || (this._draggable = new Na(r, r, !0)),
                  this._draggable
                    .on(
                      {
                        dragstart: this._onDragStart,
                        predrag: this._onPreDrag,
                        drag: this._onDrag,
                        dragend: this._onDragEnd,
                      },
                      this,
                    )
                    .enable(),
                  ne(r, 'leaflet-marker-draggable');
              },
              removeHooks: function () {
                this._draggable
                  .off(
                    {
                      dragstart: this._onDragStart,
                      predrag: this._onPreDrag,
                      drag: this._onDrag,
                      dragend: this._onDragEnd,
                    },
                    this,
                  )
                  .disable(),
                  this._marker._icon && We(this._marker._icon, 'leaflet-marker-draggable');
              },
              moved: function () {
                return this._draggable && this._draggable._moved;
              },
              _adjustPan: function (r) {
                var c = this._marker,
                  d = c._map,
                  y = this._marker.options.autoPanSpeed,
                  w = this._marker.options.autoPanPadding,
                  U = xn(c._icon),
                  q = d.getPixelBounds(),
                  ht = d.getPixelOrigin(),
                  St = gt(q.min._subtract(ht).add(w), q.max._subtract(ht).subtract(w));
                if (!St.contains(U)) {
                  var Ft = N(
                    (Math.max(St.max.x, U.x) - St.max.x) / (q.max.x - St.max.x) -
                      (Math.min(St.min.x, U.x) - St.min.x) / (q.min.x - St.min.x),
                    (Math.max(St.max.y, U.y) - St.max.y) / (q.max.y - St.max.y) -
                      (Math.min(St.min.y, U.y) - St.min.y) / (q.min.y - St.min.y),
                  ).multiplyBy(y);
                  d.panBy(Ft, { animate: !1 }),
                    this._draggable._newPos._add(Ft),
                    this._draggable._startPos._add(Ft),
                    He(c._icon, this._draggable._newPos),
                    this._onDrag(r),
                    (this._panRequest = j(this._adjustPan.bind(this, r)));
                }
              },
              _onDragStart: function () {
                (this._oldLatLng = this._marker.getLatLng()),
                  this._marker.closePopup && this._marker.closePopup(),
                  this._marker.fire('movestart').fire('dragstart');
              },
              _onPreDrag: function (r) {
                this._marker.options.autoPan &&
                  (ft(this._panRequest), (this._panRequest = j(this._adjustPan.bind(this, r))));
              },
              _onDrag: function (r) {
                var c = this._marker,
                  d = c._shadow,
                  y = xn(c._icon),
                  w = c._map.layerPointToLatLng(y);
                d && He(d, y),
                  (c._latlng = w),
                  (r.latlng = w),
                  (r.oldLatLng = this._oldLatLng),
                  c.fire('move', r).fire('drag', r);
              },
              _onDragEnd: function (r) {
                ft(this._panRequest),
                  delete this._oldLatLng,
                  this._marker.fire('moveend').fire('dragend', r);
              },
            }),
            Yr = Fi.extend({
              options: {
                icon: new qr(),
                interactive: !0,
                keyboard: !0,
                title: '',
                alt: 'Marker',
                zIndexOffset: 0,
                opacity: 1,
                riseOnHover: !1,
                riseOffset: 250,
                pane: 'markerPane',
                shadowPane: 'shadowPane',
                bubblingMouseEvents: !1,
                autoPanOnFocus: !0,
                draggable: !1,
                autoPan: !1,
                autoPanPadding: [50, 50],
                autoPanSpeed: 10,
              },
              initialize: function (r, c) {
                R(this, c), (this._latlng = _t(r));
              },
              onAdd: function (r) {
                (this._zoomAnimated = this._zoomAnimated && r.options.markerZoomAnimation),
                  this._zoomAnimated && r.on('zoomanim', this._animateZoom, this),
                  this._initIcon(),
                  this.update();
              },
              onRemove: function (r) {
                this.dragging &&
                  this.dragging.enabled() &&
                  ((this.options.draggable = !0), this.dragging.removeHooks()),
                  delete this.dragging,
                  this._zoomAnimated && r.off('zoomanim', this._animateZoom, this),
                  this._removeIcon(),
                  this._removeShadow();
              },
              getEvents: function () {
                return { zoom: this.update, viewreset: this.update };
              },
              getLatLng: function () {
                return this._latlng;
              },
              setLatLng: function (r) {
                var c = this._latlng;
                return (
                  (this._latlng = _t(r)),
                  this.update(),
                  this.fire('move', { oldLatLng: c, latlng: this._latlng })
                );
              },
              setZIndexOffset: function (r) {
                return (this.options.zIndexOffset = r), this.update();
              },
              getIcon: function () {
                return this.options.icon;
              },
              setIcon: function (r) {
                return (
                  (this.options.icon = r),
                  this._map && (this._initIcon(), this.update()),
                  this._popup && this.bindPopup(this._popup, this._popup.options),
                  this
                );
              },
              getElement: function () {
                return this._icon;
              },
              update: function () {
                if (this._icon && this._map) {
                  var r = this._map.latLngToLayerPoint(this._latlng).round();
                  this._setPos(r);
                }
                return this;
              },
              _initIcon: function () {
                var r = this.options,
                  c = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide'),
                  d = r.icon.createIcon(this._icon),
                  y = !1;
                d !== this._icon &&
                  (this._icon && this._removeIcon(),
                  (y = !0),
                  r.title && (d.title = r.title),
                  d.tagName === 'IMG' && (d.alt = r.alt || '')),
                  ne(d, c),
                  r.keyboard && ((d.tabIndex = '0'), d.setAttribute('role', 'button')),
                  (this._icon = d),
                  r.riseOnHover &&
                    this.on({ mouseover: this._bringToFront, mouseout: this._resetZIndex }),
                  this.options.autoPanOnFocus && De(d, 'focus', this._panOnFocus, this);
                var w = r.icon.createShadow(this._shadow),
                  U = !1;
                w !== this._shadow && (this._removeShadow(), (U = !0)),
                  w && (ne(w, c), (w.alt = '')),
                  (this._shadow = w),
                  r.opacity < 1 && this._updateOpacity(),
                  y && this.getPane().appendChild(this._icon),
                  this._initInteraction(),
                  w && U && this.getPane(r.shadowPane).appendChild(this._shadow);
              },
              _removeIcon: function () {
                this.options.riseOnHover &&
                  this.off({ mouseover: this._bringToFront, mouseout: this._resetZIndex }),
                  this.options.autoPanOnFocus && $e(this._icon, 'focus', this._panOnFocus, this),
                  Re(this._icon),
                  this.removeInteractiveTarget(this._icon),
                  (this._icon = null);
              },
              _removeShadow: function () {
                this._shadow && Re(this._shadow), (this._shadow = null);
              },
              _setPos: function (r) {
                this._icon && He(this._icon, r),
                  this._shadow && He(this._shadow, r),
                  (this._zIndex = r.y + this.options.zIndexOffset),
                  this._resetZIndex();
              },
              _updateZIndex: function (r) {
                this._icon && (this._icon.style.zIndex = this._zIndex + r);
              },
              _animateZoom: function (r) {
                var c = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center).round();
                this._setPos(c);
              },
              _initInteraction: function () {
                if (
                  this.options.interactive &&
                  (ne(this._icon, 'leaflet-interactive'), this.addInteractiveTarget(this._icon), oc)
                ) {
                  var r = this.options.draggable;
                  this.dragging && ((r = this.dragging.enabled()), this.dragging.disable()),
                    (this.dragging = new oc(this)),
                    r && this.dragging.enable();
                }
              },
              setOpacity: function (r) {
                return (this.options.opacity = r), this._map && this._updateOpacity(), this;
              },
              _updateOpacity: function () {
                var r = this.options.opacity;
                this._icon && Pn(this._icon, r), this._shadow && Pn(this._shadow, r);
              },
              _bringToFront: function () {
                this._updateZIndex(this.options.riseOffset);
              },
              _resetZIndex: function () {
                this._updateZIndex(0);
              },
              _panOnFocus: function () {
                var r = this._map;
                if (r) {
                  var c = this.options.icon.options,
                    d = c.iconSize ? N(c.iconSize) : N(0, 0),
                    y = c.iconAnchor ? N(c.iconAnchor) : N(0, 0);
                  r.panInside(this._latlng, {
                    paddingTopLeft: y,
                    paddingBottomRight: d.subtract(y),
                  });
                }
              },
              _getPopupAnchor: function () {
                return this.options.icon.options.popupAnchor;
              },
              _getTooltipAnchor: function () {
                return this.options.icon.options.tooltipAnchor;
              },
            });
          function lc(r, c) {
            return new Yr(r, c);
          }
          var Sa = Fi.extend({
              options: {
                stroke: !0,
                color: '#3388ff',
                weight: 3,
                opacity: 1,
                lineCap: 'round',
                lineJoin: 'round',
                dashArray: null,
                dashOffset: null,
                fill: !1,
                fillColor: null,
                fillOpacity: 0.2,
                fillRule: 'evenodd',
                interactive: !0,
                bubblingMouseEvents: !0,
              },
              beforeAdd: function (r) {
                this._renderer = r.getRenderer(this);
              },
              onAdd: function () {
                this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
              },
              onRemove: function () {
                this._renderer._removePath(this);
              },
              redraw: function () {
                return this._map && this._renderer._updatePath(this), this;
              },
              setStyle: function (r) {
                return (
                  R(this, r),
                  this._renderer &&
                    (this._renderer._updateStyle(this),
                    this.options.stroke &&
                      r &&
                      Object.prototype.hasOwnProperty.call(r, 'weight') &&
                      this._updateBounds()),
                  this
                );
              },
              bringToFront: function () {
                return this._renderer && this._renderer._bringToFront(this), this;
              },
              bringToBack: function () {
                return this._renderer && this._renderer._bringToBack(this), this;
              },
              getElement: function () {
                return this._path;
              },
              _reset: function () {
                this._project(), this._update();
              },
              _clickTolerance: function () {
                return (
                  (this.options.stroke ? this.options.weight / 2 : 0) +
                  (this._renderer.options.tolerance || 0)
                );
              },
            }),
            Ws = Sa.extend({
              options: { fill: !0, radius: 10 },
              initialize: function (r, c) {
                R(this, c), (this._latlng = _t(r)), (this._radius = this.options.radius);
              },
              setLatLng: function (r) {
                var c = this._latlng;
                return (
                  (this._latlng = _t(r)),
                  this.redraw(),
                  this.fire('move', { oldLatLng: c, latlng: this._latlng })
                );
              },
              getLatLng: function () {
                return this._latlng;
              },
              setRadius: function (r) {
                return (this.options.radius = this._radius = r), this.redraw();
              },
              getRadius: function () {
                return this._radius;
              },
              setStyle: function (r) {
                var c = (r && r.radius) || this._radius;
                return Sa.prototype.setStyle.call(this, r), this.setRadius(c), this;
              },
              _project: function () {
                (this._point = this._map.latLngToLayerPoint(this._latlng)), this._updateBounds();
              },
              _updateBounds: function () {
                var r = this._radius,
                  c = this._radiusY || r,
                  d = this._clickTolerance(),
                  y = [r + d, c + d];
                this._pxBounds = new Q(this._point.subtract(y), this._point.add(y));
              },
              _update: function () {
                this._map && this._updatePath();
              },
              _updatePath: function () {
                this._renderer._updateCircle(this);
              },
              _empty: function () {
                return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
              },
              _containsPoint: function (r) {
                return r.distanceTo(this._point) <= this._radius + this._clickTolerance();
              },
            });
          function Fu(r, c) {
            return new Ws(r, c);
          }
          var cc = Ws.extend({
            initialize: function (r, c, d) {
              if (
                (typeof c == 'number' && (c = l({}, d, { radius: c })),
                R(this, c),
                (this._latlng = _t(r)),
                isNaN(this.options.radius))
              )
                throw new Error('Circle radius cannot be NaN');
              this._mRadius = this.options.radius;
            },
            setRadius: function (r) {
              return (this._mRadius = r), this.redraw();
            },
            getRadius: function () {
              return this._mRadius;
            },
            getBounds: function () {
              var r = [this._radius, this._radiusY || this._radius];
              return new At(
                this._map.layerPointToLatLng(this._point.subtract(r)),
                this._map.layerPointToLatLng(this._point.add(r)),
              );
            },
            setStyle: Sa.prototype.setStyle,
            _project: function () {
              var r = this._latlng.lng,
                c = this._latlng.lat,
                d = this._map,
                y = d.options.crs;
              if (y.distance === Gt.distance) {
                var w = Math.PI / 180,
                  U = this._mRadius / Gt.R / w,
                  q = d.project([c + U, r]),
                  ht = d.project([c - U, r]),
                  St = q.add(ht).divideBy(2),
                  Ft = d.unproject(St).lat,
                  ie =
                    Math.acos(
                      (Math.cos(U * w) - Math.sin(c * w) * Math.sin(Ft * w)) /
                        (Math.cos(c * w) * Math.cos(Ft * w)),
                    ) / w;
                (isNaN(ie) || ie === 0) && (ie = U / Math.cos((Math.PI / 180) * c)),
                  (this._point = St.subtract(d.getPixelOrigin())),
                  (this._radius = isNaN(ie) ? 0 : St.x - d.project([Ft, r - ie]).x),
                  (this._radiusY = St.y - q.y);
              } else {
                var he = y.unproject(y.project(this._latlng).subtract([this._mRadius, 0]));
                (this._point = d.latLngToLayerPoint(this._latlng)),
                  (this._radius = this._point.x - d.latLngToLayerPoint(he).x);
              }
              this._updateBounds();
            },
          });
          function ld(r, c, d) {
            return new cc(r, c, d);
          }
          var Ma = Sa.extend({
            options: { smoothFactor: 1, noClip: !1 },
            initialize: function (r, c) {
              R(this, c), this._setLatLngs(r);
            },
            getLatLngs: function () {
              return this._latlngs;
            },
            setLatLngs: function (r) {
              return this._setLatLngs(r), this.redraw();
            },
            isEmpty: function () {
              return !this._latlngs.length;
            },
            closestLayerPoint: function (r) {
              for (
                var c = 1 / 0, d = null, y = sr, w, U, q = 0, ht = this._parts.length;
                q < ht;
                q++
              )
                for (var St = this._parts[q], Ft = 1, ie = St.length; Ft < ie; Ft++) {
                  (w = St[Ft - 1]), (U = St[Ft]);
                  var he = y(r, w, U, !0);
                  he < c && ((c = he), (d = y(r, w, U)));
                }
              return d && (d.distance = Math.sqrt(c)), d;
            },
            getCenter: function () {
              if (!this._map) throw new Error('Must add layer to map before using getCenter()');
              return sc(this._defaultShape(), this._map.options.crs);
            },
            getBounds: function () {
              return this._bounds;
            },
            addLatLng: function (r, c) {
              return (
                (c = c || this._defaultShape()),
                (r = _t(r)),
                c.push(r),
                this._bounds.extend(r),
                this.redraw()
              );
            },
            _setLatLngs: function (r) {
              (this._bounds = new At()), (this._latlngs = this._convertLatLngs(r));
            },
            _defaultShape: function () {
              return Qn(this._latlngs) ? this._latlngs : this._latlngs[0];
            },
            _convertLatLngs: function (r) {
              for (var c = [], d = Qn(r), y = 0, w = r.length; y < w; y++)
                d
                  ? ((c[y] = _t(r[y])), this._bounds.extend(c[y]))
                  : (c[y] = this._convertLatLngs(r[y]));
              return c;
            },
            _project: function () {
              var r = new Q();
              (this._rings = []),
                this._projectLatlngs(this._latlngs, this._rings, r),
                this._bounds.isValid() &&
                  r.isValid() &&
                  ((this._rawPxBounds = r), this._updateBounds());
            },
            _updateBounds: function () {
              var r = this._clickTolerance(),
                c = new K(r, r);
              this._rawPxBounds &&
                (this._pxBounds = new Q([
                  this._rawPxBounds.min.subtract(c),
                  this._rawPxBounds.max.add(c),
                ]));
            },
            _projectLatlngs: function (r, c, d) {
              var y = r[0] instanceof st,
                w = r.length,
                U,
                q;
              if (y) {
                for (q = [], U = 0; U < w; U++)
                  (q[U] = this._map.latLngToLayerPoint(r[U])), d.extend(q[U]);
                c.push(q);
              } else for (U = 0; U < w; U++) this._projectLatlngs(r[U], c, d);
            },
            _clipPoints: function () {
              var r = this._renderer._bounds;
              if (((this._parts = []), !(!this._pxBounds || !this._pxBounds.intersects(r)))) {
                if (this.options.noClip) {
                  this._parts = this._rings;
                  return;
                }
                var c = this._parts,
                  d,
                  y,
                  w,
                  U,
                  q,
                  ht,
                  St;
                for (d = 0, w = 0, U = this._rings.length; d < U; d++)
                  for (St = this._rings[d], y = 0, q = St.length; y < q - 1; y++)
                    (ht = Uu(St[y], St[y + 1], r, y, !0)),
                      ht &&
                        ((c[w] = c[w] || []),
                        c[w].push(ht[0]),
                        (ht[1] !== St[y + 1] || y === q - 2) && (c[w].push(ht[1]), w++));
              }
            },
            _simplifyPoints: function () {
              for (
                var r = this._parts, c = this.options.smoothFactor, d = 0, y = r.length;
                d < y;
                d++
              )
                r[d] = Du(r[d], c);
            },
            _update: function () {
              this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
            },
            _updatePath: function () {
              this._renderer._updatePoly(this);
            },
            _containsPoint: function (r, c) {
              var d,
                y,
                w,
                U,
                q,
                ht,
                St = this._clickTolerance();
              if (!this._pxBounds || !this._pxBounds.contains(r)) return !1;
              for (d = 0, U = this._parts.length; d < U; d++)
                for (ht = this._parts[d], y = 0, q = ht.length, w = q - 1; y < q; w = y++)
                  if (!(!c && y === 0) && ac(r, ht[w], ht[y]) <= St) return !0;
              return !1;
            },
          });
          function cd(r, c) {
            return new Ma(r, c);
          }
          Ma._flat = Nu;
          var Kr = Ma.extend({
            options: { fill: !0 },
            isEmpty: function () {
              return !this._latlngs.length || !this._latlngs[0].length;
            },
            getCenter: function () {
              if (!this._map) throw new Error('Must add layer to map before using getCenter()');
              return Uo(this._defaultShape(), this._map.options.crs);
            },
            _convertLatLngs: function (r) {
              var c = Ma.prototype._convertLatLngs.call(this, r),
                d = c.length;
              return d >= 2 && c[0] instanceof st && c[0].equals(c[d - 1]) && c.pop(), c;
            },
            _setLatLngs: function (r) {
              Ma.prototype._setLatLngs.call(this, r),
                Qn(this._latlngs) && (this._latlngs = [this._latlngs]);
            },
            _defaultShape: function () {
              return Qn(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
            },
            _clipPoints: function () {
              var r = this._renderer._bounds,
                c = this.options.weight,
                d = new K(c, c);
              if (
                ((r = new Q(r.min.subtract(d), r.max.add(d))),
                (this._parts = []),
                !(!this._pxBounds || !this._pxBounds.intersects(r)))
              ) {
                if (this.options.noClip) {
                  this._parts = this._rings;
                  return;
                }
                for (var y = 0, w = this._rings.length, U; y < w; y++)
                  (U = Pu(this._rings[y], r, !0)), U.length && this._parts.push(U);
              }
            },
            _updatePath: function () {
              this._renderer._updatePoly(this, !0);
            },
            _containsPoint: function (r) {
              var c = !1,
                d,
                y,
                w,
                U,
                q,
                ht,
                St,
                Ft;
              if (!this._pxBounds || !this._pxBounds.contains(r)) return !1;
              for (U = 0, St = this._parts.length; U < St; U++)
                for (d = this._parts[U], q = 0, Ft = d.length, ht = Ft - 1; q < Ft; ht = q++)
                  (y = d[q]),
                    (w = d[ht]),
                    y.y > r.y != w.y > r.y &&
                      r.x < ((w.x - y.x) * (r.y - y.y)) / (w.y - y.y) + y.x &&
                      (c = !c);
              return c || Ma.prototype._containsPoint.call(this, r, !0);
            },
          });
          function Si(r, c) {
            return new Kr(r, c);
          }
          var Mi = xi.extend({
            initialize: function (r, c) {
              R(this, c), (this._layers = {}), r && this.addData(r);
            },
            addData: function (r) {
              var c = P(r) ? r : r.features,
                d,
                y,
                w;
              if (c) {
                for (d = 0, y = c.length; d < y; d++)
                  (w = c[d]),
                    (w.geometries || w.geometry || w.features || w.coordinates) && this.addData(w);
                return this;
              }
              var U = this.options;
              if (U.filter && !U.filter(r)) return this;
              var q = Zs(r, U);
              return q
                ? ((q.feature = Qr(r)),
                  (q.defaultOptions = q.options),
                  this.resetStyle(q),
                  U.onEachFeature && U.onEachFeature(r, q),
                  this.addLayer(q))
                : this;
            },
            resetStyle: function (r) {
              return r === void 0
                ? this.eachLayer(this.resetStyle, this)
                : ((r.options = l({}, r.defaultOptions)),
                  this._setLayerStyle(r, this.options.style),
                  this);
            },
            setStyle: function (r) {
              return this.eachLayer(function (c) {
                this._setLayerStyle(c, r);
              }, this);
            },
            _setLayerStyle: function (r, c) {
              r.setStyle && (typeof c == 'function' && (c = c(r.feature)), r.setStyle(c));
            },
          });
          function Zs(r, c) {
            var d = r.type === 'Feature' ? r.geometry : r,
              y = d ? d.coordinates : null,
              w = [],
              U = c && c.pointToLayer,
              q = (c && c.coordsToLatLng) || ko,
              ht,
              St,
              Ft,
              ie;
            if (!y && !d) return null;
            switch (d.type) {
              case 'Point':
                return (ht = q(y)), uc(U, r, ht, c);
              case 'MultiPoint':
                for (Ft = 0, ie = y.length; Ft < ie; Ft++) (ht = q(y[Ft])), w.push(uc(U, r, ht, c));
                return new xi(w);
              case 'LineString':
              case 'MultiLineString':
                return (St = Xs(y, d.type === 'LineString' ? 0 : 1, q)), new Ma(St, c);
              case 'Polygon':
              case 'MultiPolygon':
                return (St = Xs(y, d.type === 'Polygon' ? 1 : 2, q)), new Kr(St, c);
              case 'GeometryCollection':
                for (Ft = 0, ie = d.geometries.length; Ft < ie; Ft++) {
                  var he = Zs(
                    { geometry: d.geometries[Ft], type: 'Feature', properties: r.properties },
                    c,
                  );
                  he && w.push(he);
                }
                return new xi(w);
              case 'FeatureCollection':
                for (Ft = 0, ie = d.features.length; Ft < ie; Ft++) {
                  var _e = Zs(d.features[Ft], c);
                  _e && w.push(_e);
                }
                return new xi(w);
              default:
                throw new Error('Invalid GeoJSON object.');
            }
          }
          function uc(r, c, d, y) {
            return r ? r(c, d) : new Yr(d, y && y.markersInheritOptions && y);
          }
          function ko(r) {
            return new st(r[1], r[0], r[2]);
          }
          function Xs(r, c, d) {
            for (var y = [], w = 0, U = r.length, q; w < U; w++)
              (q = c ? Xs(r[w], c - 1, d) : (d || ko)(r[w])), y.push(q);
            return y;
          }
          function js(r, c) {
            return (
              (r = _t(r)),
              r.alt !== void 0
                ? [b(r.lng, c), b(r.lat, c), b(r.alt, c)]
                : [b(r.lng, c), b(r.lat, c)]
            );
          }
          function Fo(r, c, d, y) {
            for (var w = [], U = 0, q = r.length; U < q; U++)
              w.push(c ? Fo(r[U], Qn(r[U]) ? 0 : c - 1, d, y) : js(r[U], y));
            return !c && d && w.length > 0 && w.push(w[0].slice()), w;
          }
          function Hi(r, c) {
            return r.feature ? l({}, r.feature, { geometry: c }) : Qr(c);
          }
          function Qr(r) {
            return r.type === 'Feature' || r.type === 'FeatureCollection'
              ? r
              : { type: 'Feature', properties: {}, geometry: r };
          }
          var lr = {
            toGeoJSON: function (r) {
              return Hi(this, { type: 'Point', coordinates: js(this.getLatLng(), r) });
            },
          };
          Yr.include(lr),
            cc.include(lr),
            Ws.include(lr),
            Ma.include({
              toGeoJSON: function (r) {
                var c = !Qn(this._latlngs),
                  d = Fo(this._latlngs, c ? 1 : 0, !1, r);
                return Hi(this, { type: (c ? 'Multi' : '') + 'LineString', coordinates: d });
              },
            }),
            Kr.include({
              toGeoJSON: function (r) {
                var c = !Qn(this._latlngs),
                  d = c && !Qn(this._latlngs[0]),
                  y = Fo(this._latlngs, d ? 2 : c ? 1 : 0, !0, r);
                return (
                  c || (y = [y]), Hi(this, { type: (d ? 'Multi' : '') + 'Polygon', coordinates: y })
                );
              },
            }),
            or.include({
              toMultiPoint: function (r) {
                var c = [];
                return (
                  this.eachLayer(function (d) {
                    c.push(d.toGeoJSON(r).geometry.coordinates);
                  }),
                  Hi(this, { type: 'MultiPoint', coordinates: c })
                );
              },
              toGeoJSON: function (r) {
                var c = this.feature && this.feature.geometry && this.feature.geometry.type;
                if (c === 'MultiPoint') return this.toMultiPoint(r);
                var d = c === 'GeometryCollection',
                  y = [];
                return (
                  this.eachLayer(function (w) {
                    if (w.toGeoJSON) {
                      var U = w.toGeoJSON(r);
                      if (d) y.push(U.geometry);
                      else {
                        var q = Qr(U);
                        q.type === 'FeatureCollection' ? y.push.apply(y, q.features) : y.push(q);
                      }
                    }
                  }),
                  d
                    ? Hi(this, { geometries: y, type: 'GeometryCollection' })
                    : { type: 'FeatureCollection', features: y }
                );
              },
            });
          function Ho(r, c) {
            return new Mi(r, c);
          }
          var Hu = Ho,
            ra = Fi.extend({
              options: {
                opacity: 1,
                alt: '',
                interactive: !1,
                crossOrigin: !1,
                errorOverlayUrl: '',
                zIndex: 1,
                className: '',
              },
              initialize: function (r, c, d) {
                (this._url = r), (this._bounds = tt(c)), R(this, d);
              },
              onAdd: function () {
                this._image ||
                  (this._initImage(), this.options.opacity < 1 && this._updateOpacity()),
                  this.options.interactive &&
                    (ne(this._image, 'leaflet-interactive'),
                    this.addInteractiveTarget(this._image)),
                  this.getPane().appendChild(this._image),
                  this._reset();
              },
              onRemove: function () {
                Re(this._image),
                  this.options.interactive && this.removeInteractiveTarget(this._image);
              },
              setOpacity: function (r) {
                return (this.options.opacity = r), this._image && this._updateOpacity(), this;
              },
              setStyle: function (r) {
                return r.opacity && this.setOpacity(r.opacity), this;
              },
              bringToFront: function () {
                return this._map && ze(this._image), this;
              },
              bringToBack: function () {
                return this._map && ge(this._image), this;
              },
              setUrl: function (r) {
                return (this._url = r), this._image && (this._image.src = r), this;
              },
              setBounds: function (r) {
                return (this._bounds = tt(r)), this._map && this._reset(), this;
              },
              getEvents: function () {
                var r = { zoom: this._reset, viewreset: this._reset };
                return this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
              },
              setZIndex: function (r) {
                return (this.options.zIndex = r), this._updateZIndex(), this;
              },
              getBounds: function () {
                return this._bounds;
              },
              getElement: function () {
                return this._image;
              },
              _initImage: function () {
                var r = this._url.tagName === 'IMG',
                  c = (this._image = r ? this._url : ue('img'));
                if (
                  (ne(c, 'leaflet-image-layer'),
                  this._zoomAnimated && ne(c, 'leaflet-zoom-animated'),
                  this.options.className && ne(c, this.options.className),
                  (c.onselectstart = S),
                  (c.onmousemove = S),
                  (c.onload = f(this.fire, this, 'load')),
                  (c.onerror = f(this._overlayOnError, this, 'error')),
                  (this.options.crossOrigin || this.options.crossOrigin === '') &&
                    (c.crossOrigin =
                      this.options.crossOrigin === !0 ? '' : this.options.crossOrigin),
                  this.options.zIndex && this._updateZIndex(),
                  r)
                ) {
                  this._url = c.src;
                  return;
                }
                (c.src = this._url), (c.alt = this.options.alt);
              },
              _animateZoom: function (r) {
                var c = this._map.getZoomScale(r.zoom),
                  d = this._map._latLngBoundsToNewLayerBounds(this._bounds, r.zoom, r.center).min;
                mn(this._image, d, c);
              },
              _reset: function () {
                var r = this._image,
                  c = new Q(
                    this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                    this._map.latLngToLayerPoint(this._bounds.getSouthEast()),
                  ),
                  d = c.getSize();
                He(r, c.min), (r.style.width = d.x + 'px'), (r.style.height = d.y + 'px');
              },
              _updateOpacity: function () {
                Pn(this._image, this.options.opacity);
              },
              _updateZIndex: function () {
                this._image &&
                  this.options.zIndex !== void 0 &&
                  this.options.zIndex !== null &&
                  (this._image.style.zIndex = this.options.zIndex);
              },
              _overlayOnError: function () {
                this.fire('error');
                var r = this.options.errorOverlayUrl;
                r && this._url !== r && ((this._url = r), (this._image.src = r));
              },
              getCenter: function () {
                return this._bounds.getCenter();
              },
            }),
            Jr = function (r, c, d) {
              return new ra(r, c, d);
            },
            Go = ra.extend({
              options: { autoplay: !0, loop: !0, keepAspectRatio: !0, muted: !1, playsInline: !0 },
              _initImage: function () {
                var r = this._url.tagName === 'VIDEO',
                  c = (this._image = r ? this._url : ue('video'));
                if (
                  (ne(c, 'leaflet-image-layer'),
                  this._zoomAnimated && ne(c, 'leaflet-zoom-animated'),
                  this.options.className && ne(c, this.options.className),
                  (c.onselectstart = S),
                  (c.onmousemove = S),
                  (c.onloadeddata = f(this.fire, this, 'load')),
                  r)
                ) {
                  for (var d = c.getElementsByTagName('source'), y = [], w = 0; w < d.length; w++)
                    y.push(d[w].src);
                  this._url = d.length > 0 ? y : [c.src];
                  return;
                }
                P(this._url) || (this._url = [this._url]),
                  !this.options.keepAspectRatio &&
                    Object.prototype.hasOwnProperty.call(c.style, 'objectFit') &&
                    (c.style.objectFit = 'fill'),
                  (c.autoplay = !!this.options.autoplay),
                  (c.loop = !!this.options.loop),
                  (c.muted = !!this.options.muted),
                  (c.playsInline = !!this.options.playsInline);
                for (var U = 0; U < this._url.length; U++) {
                  var q = ue('source');
                  (q.src = this._url[U]), c.appendChild(q);
                }
              },
            });
          function Gu(r, c, d) {
            return new Go(r, c, d);
          }
          var za = ra.extend({
            _initImage: function () {
              var r = (this._image = this._url);
              ne(r, 'leaflet-image-layer'),
                this._zoomAnimated && ne(r, 'leaflet-zoom-animated'),
                this.options.className && ne(r, this.options.className),
                (r.onselectstart = S),
                (r.onmousemove = S);
            },
          });
          function Vu(r, c, d) {
            return new za(r, c, d);
          }
          var Gi = Fi.extend({
            options: { interactive: !1, offset: [0, 0], className: '', pane: void 0, content: '' },
            initialize: function (r, c) {
              r && (r instanceof st || P(r))
                ? ((this._latlng = _t(r)), R(this, c))
                : (R(this, r), (this._source = c)),
                this.options.content && (this._content = this.options.content);
            },
            openOn: function (r) {
              return (
                (r = arguments.length ? r : this._source._map),
                r.hasLayer(this) || r.addLayer(this),
                this
              );
            },
            close: function () {
              return this._map && this._map.removeLayer(this), this;
            },
            toggle: function (r) {
              return (
                this._map
                  ? this.close()
                  : (arguments.length ? (this._source = r) : (r = this._source),
                    this._prepareOpen(),
                    this.openOn(r._map)),
                this
              );
            },
            onAdd: function (r) {
              (this._zoomAnimated = r._zoomAnimated),
                this._container || this._initLayout(),
                r._fadeAnimated && Pn(this._container, 0),
                clearTimeout(this._removeTimeout),
                this.getPane().appendChild(this._container),
                this.update(),
                r._fadeAnimated && Pn(this._container, 1),
                this.bringToFront(),
                this.options.interactive &&
                  (ne(this._container, 'leaflet-interactive'),
                  this.addInteractiveTarget(this._container));
            },
            onRemove: function (r) {
              r._fadeAnimated
                ? (Pn(this._container, 0),
                  (this._removeTimeout = setTimeout(f(Re, void 0, this._container), 200)))
                : Re(this._container),
                this.options.interactive &&
                  (We(this._container, 'leaflet-interactive'),
                  this.removeInteractiveTarget(this._container));
            },
            getLatLng: function () {
              return this._latlng;
            },
            setLatLng: function (r) {
              return (
                (this._latlng = _t(r)),
                this._map && (this._updatePosition(), this._adjustPan()),
                this
              );
            },
            getContent: function () {
              return this._content;
            },
            setContent: function (r) {
              return (this._content = r), this.update(), this;
            },
            getElement: function () {
              return this._container;
            },
            update: function () {
              this._map &&
                ((this._container.style.visibility = 'hidden'),
                this._updateContent(),
                this._updateLayout(),
                this._updatePosition(),
                (this._container.style.visibility = ''),
                this._adjustPan());
            },
            getEvents: function () {
              var r = { zoom: this._updatePosition, viewreset: this._updatePosition };
              return this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
            },
            isOpen: function () {
              return !!this._map && this._map.hasLayer(this);
            },
            bringToFront: function () {
              return this._map && ze(this._container), this;
            },
            bringToBack: function () {
              return this._map && ge(this._container), this;
            },
            _prepareOpen: function (r) {
              var c = this._source;
              if (!c._map) return !1;
              if (c instanceof xi) {
                c = null;
                var d = this._source._layers;
                for (var y in d)
                  if (d[y]._map) {
                    c = d[y];
                    break;
                  }
                if (!c) return !1;
                this._source = c;
              }
              if (!r)
                if (c.getCenter) r = c.getCenter();
                else if (c.getLatLng) r = c.getLatLng();
                else if (c.getBounds) r = c.getBounds().getCenter();
                else throw new Error('Unable to get source layer LatLng.');
              return this.setLatLng(r), this._map && this.update(), !0;
            },
            _updateContent: function () {
              if (this._content) {
                var r = this._contentNode,
                  c =
                    typeof this._content == 'function'
                      ? this._content(this._source || this)
                      : this._content;
                if (typeof c == 'string') r.innerHTML = c;
                else {
                  for (; r.hasChildNodes(); ) r.removeChild(r.firstChild);
                  r.appendChild(c);
                }
                this.fire('contentupdate');
              }
            },
            _updatePosition: function () {
              if (this._map) {
                var r = this._map.latLngToLayerPoint(this._latlng),
                  c = N(this.options.offset),
                  d = this._getAnchor();
                this._zoomAnimated ? He(this._container, r.add(d)) : (c = c.add(r).add(d));
                var y = (this._containerBottom = -c.y),
                  w = (this._containerLeft = -Math.round(this._containerWidth / 2) + c.x);
                (this._container.style.bottom = y + 'px'), (this._container.style.left = w + 'px');
              }
            },
            _getAnchor: function () {
              return [0, 0];
            },
          });
          Ze.include({
            _initOverlay: function (r, c, d, y) {
              var w = c;
              return w instanceof r || (w = new r(y).setContent(c)), d && w.setLatLng(d), w;
            },
          }),
            Fi.include({
              _initOverlay: function (r, c, d, y) {
                var w = d;
                return (
                  w instanceof r
                    ? (R(w, y), (w._source = this))
                    : ((w = c && !y ? c : new r(y, this)), w.setContent(d)),
                  w
                );
              },
            });
          var qs = Gi.extend({
              options: {
                pane: 'popupPane',
                offset: [0, 7],
                maxWidth: 300,
                minWidth: 50,
                maxHeight: null,
                autoPan: !0,
                autoPanPaddingTopLeft: null,
                autoPanPaddingBottomRight: null,
                autoPanPadding: [5, 5],
                keepInView: !1,
                closeButton: !0,
                autoClose: !0,
                closeOnEscapeKey: !0,
                className: '',
              },
              openOn: function (r) {
                return (
                  (r = arguments.length ? r : this._source._map),
                  !r.hasLayer(this) &&
                    r._popup &&
                    r._popup.options.autoClose &&
                    r.removeLayer(r._popup),
                  (r._popup = this),
                  Gi.prototype.openOn.call(this, r)
                );
              },
              onAdd: function (r) {
                Gi.prototype.onAdd.call(this, r),
                  r.fire('popupopen', { popup: this }),
                  this._source &&
                    (this._source.fire('popupopen', { popup: this }, !0),
                    this._source instanceof Sa || this._source.on('preclick', xa));
              },
              onRemove: function (r) {
                Gi.prototype.onRemove.call(this, r),
                  r.fire('popupclose', { popup: this }),
                  this._source &&
                    (this._source.fire('popupclose', { popup: this }, !0),
                    this._source instanceof Sa || this._source.off('preclick', xa));
              },
              getEvents: function () {
                var r = Gi.prototype.getEvents.call(this);
                return (
                  (this.options.closeOnClick !== void 0
                    ? this.options.closeOnClick
                    : this._map.options.closePopupOnClick) && (r.preclick = this.close),
                  this.options.keepInView && (r.moveend = this._adjustPan),
                  r
                );
              },
              _initLayout: function () {
                var r = 'leaflet-popup',
                  c = (this._container = ue(
                    'div',
                    r + ' ' + (this.options.className || '') + ' leaflet-zoom-animated',
                  )),
                  d = (this._wrapper = ue('div', r + '-content-wrapper', c));
                if (
                  ((this._contentNode = ue('div', r + '-content', d)),
                  Wr(c),
                  Vr(this._contentNode),
                  De(c, 'contextmenu', xa),
                  (this._tipContainer = ue('div', r + '-tip-container', c)),
                  (this._tip = ue('div', r + '-tip', this._tipContainer)),
                  this.options.closeButton)
                ) {
                  var y = (this._closeButton = ue('a', r + '-close-button', c));
                  y.setAttribute('role', 'button'),
                    y.setAttribute('aria-label', 'Close popup'),
                    (y.href = '#close'),
                    (y.innerHTML = '<span aria-hidden="true">&#215;</span>'),
                    De(
                      y,
                      'click',
                      function (w) {
                        Dn(w), this.close();
                      },
                      this,
                    );
                }
              },
              _updateLayout: function () {
                var r = this._contentNode,
                  c = r.style;
                (c.width = ''), (c.whiteSpace = 'nowrap');
                var d = r.offsetWidth;
                (d = Math.min(d, this.options.maxWidth)),
                  (d = Math.max(d, this.options.minWidth)),
                  (c.width = d + 1 + 'px'),
                  (c.whiteSpace = ''),
                  (c.height = '');
                var y = r.offsetHeight,
                  w = this.options.maxHeight,
                  U = 'leaflet-popup-scrolled';
                w && y > w ? ((c.height = w + 'px'), ne(r, U)) : We(r, U),
                  (this._containerWidth = this._container.offsetWidth);
              },
              _animateZoom: function (r) {
                var c = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center),
                  d = this._getAnchor();
                He(this._container, c.add(d));
              },
              _adjustPan: function () {
                if (this.options.autoPan) {
                  if ((this._map._panAnim && this._map._panAnim.stop(), this._autopanning)) {
                    this._autopanning = !1;
                    return;
                  }
                  var r = this._map,
                    c = parseInt(Ue(this._container, 'marginBottom'), 10) || 0,
                    d = this._container.offsetHeight + c,
                    y = this._containerWidth,
                    w = new K(this._containerLeft, -d - this._containerBottom);
                  w._add(xn(this._container));
                  var U = r.layerPointToContainerPoint(w),
                    q = N(this.options.autoPanPadding),
                    ht = N(this.options.autoPanPaddingTopLeft || q),
                    St = N(this.options.autoPanPaddingBottomRight || q),
                    Ft = r.getSize(),
                    ie = 0,
                    he = 0;
                  U.x + y + St.x > Ft.x && (ie = U.x + y - Ft.x + St.x),
                    U.x - ie - ht.x < 0 && (ie = U.x - ht.x),
                    U.y + d + St.y > Ft.y && (he = U.y + d - Ft.y + St.y),
                    U.y - he - ht.y < 0 && (he = U.y - ht.y),
                    (ie || he) &&
                      (this.options.keepInView && (this._autopanning = !0),
                      r.fire('autopanstart').panBy([ie, he]));
                }
              },
              _getAnchor: function () {
                return N(
                  this._source && this._source._getPopupAnchor
                    ? this._source._getPopupAnchor()
                    : [0, 0],
                );
              },
            }),
            ud = function (r, c) {
              return new qs(r, c);
            };
          Ze.mergeOptions({ closePopupOnClick: !0 }),
            Ze.include({
              openPopup: function (r, c, d) {
                return this._initOverlay(qs, r, c, d).openOn(this), this;
              },
              closePopup: function (r) {
                return (r = arguments.length ? r : this._popup), r && r.close(), this;
              },
            }),
            Fi.include({
              bindPopup: function (r, c) {
                return (
                  (this._popup = this._initOverlay(qs, this._popup, r, c)),
                  this._popupHandlersAdded ||
                    (this.on({
                      click: this._openPopup,
                      keypress: this._onKeyPress,
                      remove: this.closePopup,
                      move: this._movePopup,
                    }),
                    (this._popupHandlersAdded = !0)),
                  this
                );
              },
              unbindPopup: function () {
                return (
                  this._popup &&
                    (this.off({
                      click: this._openPopup,
                      keypress: this._onKeyPress,
                      remove: this.closePopup,
                      move: this._movePopup,
                    }),
                    (this._popupHandlersAdded = !1),
                    (this._popup = null)),
                  this
                );
              },
              openPopup: function (r) {
                return (
                  this._popup &&
                    (this instanceof xi || (this._popup._source = this),
                    this._popup._prepareOpen(r || this._latlng) && this._popup.openOn(this._map)),
                  this
                );
              },
              closePopup: function () {
                return this._popup && this._popup.close(), this;
              },
              togglePopup: function () {
                return this._popup && this._popup.toggle(this), this;
              },
              isPopupOpen: function () {
                return this._popup ? this._popup.isOpen() : !1;
              },
              setPopupContent: function (r) {
                return this._popup && this._popup.setContent(r), this;
              },
              getPopup: function () {
                return this._popup;
              },
              _openPopup: function (r) {
                if (!(!this._popup || !this._map)) {
                  aa(r);
                  var c = r.layer || r.target;
                  if (this._popup._source === c && !(c instanceof Sa)) {
                    this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(r.latlng);
                    return;
                  }
                  (this._popup._source = c), this.openPopup(r.latlng);
                }
              },
              _movePopup: function (r) {
                this._popup.setLatLng(r.latlng);
              },
              _onKeyPress: function (r) {
                r.originalEvent.keyCode === 13 && this._openPopup(r);
              },
            });
          var Vo = Gi.extend({
              options: {
                pane: 'tooltipPane',
                offset: [0, 0],
                direction: 'auto',
                permanent: !1,
                sticky: !1,
                opacity: 0.9,
              },
              onAdd: function (r) {
                Gi.prototype.onAdd.call(this, r),
                  this.setOpacity(this.options.opacity),
                  r.fire('tooltipopen', { tooltip: this }),
                  this._source &&
                    (this.addEventParent(this._source),
                    this._source.fire('tooltipopen', { tooltip: this }, !0));
              },
              onRemove: function (r) {
                Gi.prototype.onRemove.call(this, r),
                  r.fire('tooltipclose', { tooltip: this }),
                  this._source &&
                    (this.removeEventParent(this._source),
                    this._source.fire('tooltipclose', { tooltip: this }, !0));
              },
              getEvents: function () {
                var r = Gi.prototype.getEvents.call(this);
                return this.options.permanent || (r.preclick = this.close), r;
              },
              _initLayout: function () {
                var r = 'leaflet-tooltip',
                  c =
                    r +
                    ' ' +
                    (this.options.className || '') +
                    ' leaflet-zoom-' +
                    (this._zoomAnimated ? 'animated' : 'hide');
                (this._contentNode = this._container = ue('div', c)),
                  this._container.setAttribute('role', 'tooltip'),
                  this._container.setAttribute('id', 'leaflet-tooltip-' + _(this));
              },
              _updateLayout: function () {},
              _adjustPan: function () {},
              _setPosition: function (r) {
                var c,
                  d,
                  y = this._map,
                  w = this._container,
                  U = y.latLngToContainerPoint(y.getCenter()),
                  q = y.layerPointToContainerPoint(r),
                  ht = this.options.direction,
                  St = w.offsetWidth,
                  Ft = w.offsetHeight,
                  ie = N(this.options.offset),
                  he = this._getAnchor();
                ht === 'top'
                  ? ((c = St / 2), (d = Ft))
                  : ht === 'bottom'
                    ? ((c = St / 2), (d = 0))
                    : ht === 'center'
                      ? ((c = St / 2), (d = Ft / 2))
                      : ht === 'right'
                        ? ((c = 0), (d = Ft / 2))
                        : ht === 'left'
                          ? ((c = St), (d = Ft / 2))
                          : q.x < U.x
                            ? ((ht = 'right'), (c = 0), (d = Ft / 2))
                            : ((ht = 'left'), (c = St + (ie.x + he.x) * 2), (d = Ft / 2)),
                  (r = r
                    .subtract(N(c, d, !0))
                    .add(ie)
                    .add(he)),
                  We(w, 'leaflet-tooltip-right'),
                  We(w, 'leaflet-tooltip-left'),
                  We(w, 'leaflet-tooltip-top'),
                  We(w, 'leaflet-tooltip-bottom'),
                  ne(w, 'leaflet-tooltip-' + ht),
                  He(w, r);
              },
              _updatePosition: function () {
                var r = this._map.latLngToLayerPoint(this._latlng);
                this._setPosition(r);
              },
              setOpacity: function (r) {
                (this.options.opacity = r), this._container && Pn(this._container, r);
              },
              _animateZoom: function (r) {
                var c = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center);
                this._setPosition(c);
              },
              _getAnchor: function () {
                return N(
                  this._source && this._source._getTooltipAnchor && !this.options.sticky
                    ? this._source._getTooltipAnchor()
                    : [0, 0],
                );
              },
            }),
            hd = function (r, c) {
              return new Vo(r, c);
            };
          Ze.include({
            openTooltip: function (r, c, d) {
              return this._initOverlay(Vo, r, c, d).openOn(this), this;
            },
            closeTooltip: function (r) {
              return r.close(), this;
            },
          }),
            Fi.include({
              bindTooltip: function (r, c) {
                return (
                  this._tooltip && this.isTooltipOpen() && this.unbindTooltip(),
                  (this._tooltip = this._initOverlay(Vo, this._tooltip, r, c)),
                  this._initTooltipInteractions(),
                  this._tooltip.options.permanent &&
                    this._map &&
                    this._map.hasLayer(this) &&
                    this.openTooltip(),
                  this
                );
              },
              unbindTooltip: function () {
                return (
                  this._tooltip &&
                    (this._initTooltipInteractions(!0),
                    this.closeTooltip(),
                    (this._tooltip = null)),
                  this
                );
              },
              _initTooltipInteractions: function (r) {
                if (!(!r && this._tooltipHandlersAdded)) {
                  var c = r ? 'off' : 'on',
                    d = { remove: this.closeTooltip, move: this._moveTooltip };
                  this._tooltip.options.permanent
                    ? (d.add = this._openTooltip)
                    : ((d.mouseover = this._openTooltip),
                      (d.mouseout = this.closeTooltip),
                      (d.click = this._openTooltip),
                      this._map ? this._addFocusListeners() : (d.add = this._addFocusListeners)),
                    this._tooltip.options.sticky && (d.mousemove = this._moveTooltip),
                    this[c](d),
                    (this._tooltipHandlersAdded = !r);
                }
              },
              openTooltip: function (r) {
                return (
                  this._tooltip &&
                    (this instanceof xi || (this._tooltip._source = this),
                    this._tooltip._prepareOpen(r) &&
                      (this._tooltip.openOn(this._map),
                      this.getElement
                        ? this._setAriaDescribedByOnLayer(this)
                        : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))),
                  this
                );
              },
              closeTooltip: function () {
                if (this._tooltip) return this._tooltip.close();
              },
              toggleTooltip: function () {
                return this._tooltip && this._tooltip.toggle(this), this;
              },
              isTooltipOpen: function () {
                return this._tooltip.isOpen();
              },
              setTooltipContent: function (r) {
                return this._tooltip && this._tooltip.setContent(r), this;
              },
              getTooltip: function () {
                return this._tooltip;
              },
              _addFocusListeners: function () {
                this.getElement
                  ? this._addFocusListenersOnLayer(this)
                  : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
              },
              _addFocusListenersOnLayer: function (r) {
                var c = typeof r.getElement == 'function' && r.getElement();
                c &&
                  (De(
                    c,
                    'focus',
                    function () {
                      (this._tooltip._source = r), this.openTooltip();
                    },
                    this,
                  ),
                  De(c, 'blur', this.closeTooltip, this));
              },
              _setAriaDescribedByOnLayer: function (r) {
                var c = typeof r.getElement == 'function' && r.getElement();
                c && c.setAttribute('aria-describedby', this._tooltip._container.id);
              },
              _openTooltip: function (r) {
                if (!(!this._tooltip || !this._map)) {
                  if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
                    this._openOnceFlag = !0;
                    var c = this;
                    this._map.once('moveend', function () {
                      (c._openOnceFlag = !1), c._openTooltip(r);
                    });
                    return;
                  }
                  (this._tooltip._source = r.layer || r.target),
                    this.openTooltip(this._tooltip.options.sticky ? r.latlng : void 0);
                }
              },
              _moveTooltip: function (r) {
                var c = r.latlng,
                  d,
                  y;
                this._tooltip.options.sticky &&
                  r.originalEvent &&
                  ((d = this._map.mouseEventToContainerPoint(r.originalEvent)),
                  (y = this._map.containerPointToLayerPoint(d)),
                  (c = this._map.layerPointToLatLng(y))),
                  this._tooltip.setLatLng(c);
              },
            });
          var hc = jr.extend({
            options: { iconSize: [12, 12], html: !1, bgPos: null, className: 'leaflet-div-icon' },
            createIcon: function (r) {
              var c = r && r.tagName === 'DIV' ? r : document.createElement('div'),
                d = this.options;
              if (
                (d.html instanceof Element
                  ? (ke(c), c.appendChild(d.html))
                  : (c.innerHTML = d.html !== !1 ? d.html : ''),
                d.bgPos)
              ) {
                var y = N(d.bgPos);
                c.style.backgroundPosition = -y.x + 'px ' + -y.y + 'px';
              }
              return this._setIconStyles(c, 'icon'), c;
            },
            createShadow: function () {
              return null;
            },
          });
          function Wu(r) {
            return new hc(r);
          }
          jr.Default = qr;
          var cr = Fi.extend({
            options: {
              tileSize: 256,
              opacity: 1,
              updateWhenIdle: me.mobile,
              updateWhenZooming: !0,
              updateInterval: 200,
              zIndex: 1,
              bounds: null,
              minZoom: 0,
              maxZoom: void 0,
              maxNativeZoom: void 0,
              minNativeZoom: void 0,
              noWrap: !1,
              pane: 'tilePane',
              className: '',
              keepBuffer: 2,
            },
            initialize: function (r) {
              R(this, r);
            },
            onAdd: function () {
              this._initContainer(), (this._levels = {}), (this._tiles = {}), this._resetView();
            },
            beforeAdd: function (r) {
              r._addZoomLimit(this);
            },
            onRemove: function (r) {
              this._removeAllTiles(),
                Re(this._container),
                r._removeZoomLimit(this),
                (this._container = null),
                (this._tileZoom = void 0);
            },
            bringToFront: function () {
              return this._map && (ze(this._container), this._setAutoZIndex(Math.max)), this;
            },
            bringToBack: function () {
              return this._map && (ge(this._container), this._setAutoZIndex(Math.min)), this;
            },
            getContainer: function () {
              return this._container;
            },
            setOpacity: function (r) {
              return (this.options.opacity = r), this._updateOpacity(), this;
            },
            setZIndex: function (r) {
              return (this.options.zIndex = r), this._updateZIndex(), this;
            },
            isLoading: function () {
              return this._loading;
            },
            redraw: function () {
              if (this._map) {
                this._removeAllTiles();
                var r = this._clampZoom(this._map.getZoom());
                r !== this._tileZoom && ((this._tileZoom = r), this._updateLevels()),
                  this._update();
              }
              return this;
            },
            getEvents: function () {
              var r = {
                viewprereset: this._invalidateAll,
                viewreset: this._resetView,
                zoom: this._resetView,
                moveend: this._onMoveEnd,
              };
              return (
                this.options.updateWhenIdle ||
                  (this._onMove ||
                    (this._onMove = g(this._onMoveEnd, this.options.updateInterval, this)),
                  (r.move = this._onMove)),
                this._zoomAnimated && (r.zoomanim = this._animateZoom),
                r
              );
            },
            createTile: function () {
              return document.createElement('div');
            },
            getTileSize: function () {
              var r = this.options.tileSize;
              return r instanceof K ? r : new K(r, r);
            },
            _updateZIndex: function () {
              this._container &&
                this.options.zIndex !== void 0 &&
                this.options.zIndex !== null &&
                (this._container.style.zIndex = this.options.zIndex);
            },
            _setAutoZIndex: function (r) {
              for (
                var c = this.getPane().children, d = -r(-1 / 0, 1 / 0), y = 0, w = c.length, U;
                y < w;
                y++
              )
                (U = c[y].style.zIndex), c[y] !== this._container && U && (d = r(d, +U));
              isFinite(d) && ((this.options.zIndex = d + r(-1, 1)), this._updateZIndex());
            },
            _updateOpacity: function () {
              if (this._map && !me.ielt9) {
                Pn(this._container, this.options.opacity);
                var r = +new Date(),
                  c = !1,
                  d = !1;
                for (var y in this._tiles) {
                  var w = this._tiles[y];
                  if (!(!w.current || !w.loaded)) {
                    var U = Math.min(1, (r - w.loaded) / 200);
                    Pn(w.el, U),
                      U < 1
                        ? (c = !0)
                        : (w.active ? (d = !0) : this._onOpaqueTile(w), (w.active = !0));
                  }
                }
                d && !this._noPrune && this._pruneTiles(),
                  c && (ft(this._fadeFrame), (this._fadeFrame = j(this._updateOpacity, this)));
              }
            },
            _onOpaqueTile: S,
            _initContainer: function () {
              this._container ||
                ((this._container = ue('div', 'leaflet-layer ' + (this.options.className || ''))),
                this._updateZIndex(),
                this.options.opacity < 1 && this._updateOpacity(),
                this.getPane().appendChild(this._container));
            },
            _updateLevels: function () {
              var r = this._tileZoom,
                c = this.options.maxZoom;
              if (r !== void 0) {
                for (var d in this._levels)
                  (d = Number(d)),
                    this._levels[d].el.children.length || d === r
                      ? ((this._levels[d].el.style.zIndex = c - Math.abs(r - d)),
                        this._onUpdateLevel(d))
                      : (Re(this._levels[d].el),
                        this._removeTilesAtZoom(d),
                        this._onRemoveLevel(d),
                        delete this._levels[d]);
                var y = this._levels[r],
                  w = this._map;
                return (
                  y ||
                    ((y = this._levels[r] = {}),
                    (y.el = ue(
                      'div',
                      'leaflet-tile-container leaflet-zoom-animated',
                      this._container,
                    )),
                    (y.el.style.zIndex = c),
                    (y.origin = w.project(w.unproject(w.getPixelOrigin()), r).round()),
                    (y.zoom = r),
                    this._setZoomTransform(y, w.getCenter(), w.getZoom()),
                    S(y.el.offsetWidth),
                    this._onCreateLevel(y)),
                  (this._level = y),
                  y
                );
              }
            },
            _onUpdateLevel: S,
            _onRemoveLevel: S,
            _onCreateLevel: S,
            _pruneTiles: function () {
              if (this._map) {
                var r,
                  c,
                  d = this._map.getZoom();
                if (d > this.options.maxZoom || d < this.options.minZoom) {
                  this._removeAllTiles();
                  return;
                }
                for (r in this._tiles) (c = this._tiles[r]), (c.retain = c.current);
                for (r in this._tiles)
                  if (((c = this._tiles[r]), c.current && !c.active)) {
                    var y = c.coords;
                    this._retainParent(y.x, y.y, y.z, y.z - 5) ||
                      this._retainChildren(y.x, y.y, y.z, y.z + 2);
                  }
                for (r in this._tiles) this._tiles[r].retain || this._removeTile(r);
              }
            },
            _removeTilesAtZoom: function (r) {
              for (var c in this._tiles) this._tiles[c].coords.z === r && this._removeTile(c);
            },
            _removeAllTiles: function () {
              for (var r in this._tiles) this._removeTile(r);
            },
            _invalidateAll: function () {
              for (var r in this._levels)
                Re(this._levels[r].el), this._onRemoveLevel(Number(r)), delete this._levels[r];
              this._removeAllTiles(), (this._tileZoom = void 0);
            },
            _retainParent: function (r, c, d, y) {
              var w = Math.floor(r / 2),
                U = Math.floor(c / 2),
                q = d - 1,
                ht = new K(+w, +U);
              ht.z = +q;
              var St = this._tileCoordsToKey(ht),
                Ft = this._tiles[St];
              return Ft && Ft.active
                ? ((Ft.retain = !0), !0)
                : (Ft && Ft.loaded && (Ft.retain = !0),
                  q > y ? this._retainParent(w, U, q, y) : !1);
            },
            _retainChildren: function (r, c, d, y) {
              for (var w = 2 * r; w < 2 * r + 2; w++)
                for (var U = 2 * c; U < 2 * c + 2; U++) {
                  var q = new K(w, U);
                  q.z = d + 1;
                  var ht = this._tileCoordsToKey(q),
                    St = this._tiles[ht];
                  if (St && St.active) {
                    St.retain = !0;
                    continue;
                  } else St && St.loaded && (St.retain = !0);
                  d + 1 < y && this._retainChildren(w, U, d + 1, y);
                }
            },
            _resetView: function (r) {
              var c = r && (r.pinch || r.flyTo);
              this._setView(this._map.getCenter(), this._map.getZoom(), c, c);
            },
            _animateZoom: function (r) {
              this._setView(r.center, r.zoom, !0, r.noUpdate);
            },
            _clampZoom: function (r) {
              var c = this.options;
              return c.minNativeZoom !== void 0 && r < c.minNativeZoom
                ? c.minNativeZoom
                : c.maxNativeZoom !== void 0 && c.maxNativeZoom < r
                  ? c.maxNativeZoom
                  : r;
            },
            _setView: function (r, c, d, y) {
              var w = Math.round(c);
              (this.options.maxZoom !== void 0 && w > this.options.maxZoom) ||
              (this.options.minZoom !== void 0 && w < this.options.minZoom)
                ? (w = void 0)
                : (w = this._clampZoom(w));
              var U = this.options.updateWhenZooming && w !== this._tileZoom;
              (!y || U) &&
                ((this._tileZoom = w),
                this._abortLoading && this._abortLoading(),
                this._updateLevels(),
                this._resetGrid(),
                w !== void 0 && this._update(r),
                d || this._pruneTiles(),
                (this._noPrune = !!d)),
                this._setZoomTransforms(r, c);
            },
            _setZoomTransforms: function (r, c) {
              for (var d in this._levels) this._setZoomTransform(this._levels[d], r, c);
            },
            _setZoomTransform: function (r, c, d) {
              var y = this._map.getZoomScale(d, r.zoom),
                w = r.origin.multiplyBy(y).subtract(this._map._getNewPixelOrigin(c, d)).round();
              me.any3d ? mn(r.el, w, y) : He(r.el, w);
            },
            _resetGrid: function () {
              var r = this._map,
                c = r.options.crs,
                d = (this._tileSize = this.getTileSize()),
                y = this._tileZoom,
                w = this._map.getPixelWorldBounds(this._tileZoom);
              w && (this._globalTileRange = this._pxBoundsToTileRange(w)),
                (this._wrapX = c.wrapLng &&
                  !this.options.noWrap && [
                    Math.floor(r.project([0, c.wrapLng[0]], y).x / d.x),
                    Math.ceil(r.project([0, c.wrapLng[1]], y).x / d.y),
                  ]),
                (this._wrapY = c.wrapLat &&
                  !this.options.noWrap && [
                    Math.floor(r.project([c.wrapLat[0], 0], y).y / d.x),
                    Math.ceil(r.project([c.wrapLat[1], 0], y).y / d.y),
                  ]);
            },
            _onMoveEnd: function () {
              !this._map || this._map._animatingZoom || this._update();
            },
            _getTiledPixelBounds: function (r) {
              var c = this._map,
                d = c._animatingZoom ? Math.max(c._animateToZoom, c.getZoom()) : c.getZoom(),
                y = c.getZoomScale(d, this._tileZoom),
                w = c.project(r, this._tileZoom).floor(),
                U = c.getSize().divideBy(y * 2);
              return new Q(w.subtract(U), w.add(U));
            },
            _update: function (r) {
              var c = this._map;
              if (c) {
                var d = this._clampZoom(c.getZoom());
                if ((r === void 0 && (r = c.getCenter()), this._tileZoom !== void 0)) {
                  var y = this._getTiledPixelBounds(r),
                    w = this._pxBoundsToTileRange(y),
                    U = w.getCenter(),
                    q = [],
                    ht = this.options.keepBuffer,
                    St = new Q(
                      w.getBottomLeft().subtract([ht, -ht]),
                      w.getTopRight().add([ht, -ht]),
                    );
                  if (
                    !(
                      isFinite(w.min.x) &&
                      isFinite(w.min.y) &&
                      isFinite(w.max.x) &&
                      isFinite(w.max.y)
                    )
                  )
                    throw new Error('Attempted to load an infinite number of tiles');
                  for (var Ft in this._tiles) {
                    var ie = this._tiles[Ft].coords;
                    (ie.z !== this._tileZoom || !St.contains(new K(ie.x, ie.y))) &&
                      (this._tiles[Ft].current = !1);
                  }
                  if (Math.abs(d - this._tileZoom) > 1) {
                    this._setView(r, d);
                    return;
                  }
                  for (var he = w.min.y; he <= w.max.y; he++)
                    for (var _e = w.min.x; _e <= w.max.x; _e++) {
                      var Le = new K(_e, he);
                      if (((Le.z = this._tileZoom), !!this._isValidTile(Le))) {
                        var vn = this._tiles[this._tileCoordsToKey(Le)];
                        vn ? (vn.current = !0) : q.push(Le);
                      }
                    }
                  if (
                    (q.sort(function (Jn, Ri) {
                      return Jn.distanceTo(U) - Ri.distanceTo(U);
                    }),
                    q.length !== 0)
                  ) {
                    this._loading || ((this._loading = !0), this.fire('loading'));
                    var Tn = document.createDocumentFragment();
                    for (_e = 0; _e < q.length; _e++) this._addTile(q[_e], Tn);
                    this._level.el.appendChild(Tn);
                  }
                }
              }
            },
            _isValidTile: function (r) {
              var c = this._map.options.crs;
              if (!c.infinite) {
                var d = this._globalTileRange;
                if (
                  (!c.wrapLng && (r.x < d.min.x || r.x > d.max.x)) ||
                  (!c.wrapLat && (r.y < d.min.y || r.y > d.max.y))
                )
                  return !1;
              }
              if (!this.options.bounds) return !0;
              var y = this._tileCoordsToBounds(r);
              return tt(this.options.bounds).overlaps(y);
            },
            _keyToBounds: function (r) {
              return this._tileCoordsToBounds(this._keyToTileCoords(r));
            },
            _tileCoordsToNwSe: function (r) {
              var c = this._map,
                d = this.getTileSize(),
                y = r.scaleBy(d),
                w = y.add(d),
                U = c.unproject(y, r.z),
                q = c.unproject(w, r.z);
              return [U, q];
            },
            _tileCoordsToBounds: function (r) {
              var c = this._tileCoordsToNwSe(r),
                d = new At(c[0], c[1]);
              return this.options.noWrap || (d = this._map.wrapLatLngBounds(d)), d;
            },
            _tileCoordsToKey: function (r) {
              return r.x + ':' + r.y + ':' + r.z;
            },
            _keyToTileCoords: function (r) {
              var c = r.split(':'),
                d = new K(+c[0], +c[1]);
              return (d.z = +c[2]), d;
            },
            _removeTile: function (r) {
              var c = this._tiles[r];
              c &&
                (Re(c.el),
                delete this._tiles[r],
                this.fire('tileunload', { tile: c.el, coords: this._keyToTileCoords(r) }));
            },
            _initTile: function (r) {
              ne(r, 'leaflet-tile');
              var c = this.getTileSize();
              (r.style.width = c.x + 'px'),
                (r.style.height = c.y + 'px'),
                (r.onselectstart = S),
                (r.onmousemove = S),
                me.ielt9 && this.options.opacity < 1 && Pn(r, this.options.opacity);
            },
            _addTile: function (r, c) {
              var d = this._getTilePos(r),
                y = this._tileCoordsToKey(r),
                w = this.createTile(this._wrapCoords(r), f(this._tileReady, this, r));
              this._initTile(w),
                this.createTile.length < 2 && j(f(this._tileReady, this, r, null, w)),
                He(w, d),
                (this._tiles[y] = { el: w, coords: r, current: !0 }),
                c.appendChild(w),
                this.fire('tileloadstart', { tile: w, coords: r });
            },
            _tileReady: function (r, c, d) {
              c && this.fire('tileerror', { error: c, tile: d, coords: r });
              var y = this._tileCoordsToKey(r);
              (d = this._tiles[y]),
                d &&
                  ((d.loaded = +new Date()),
                  this._map._fadeAnimated
                    ? (Pn(d.el, 0),
                      ft(this._fadeFrame),
                      (this._fadeFrame = j(this._updateOpacity, this)))
                    : ((d.active = !0), this._pruneTiles()),
                  c ||
                    (ne(d.el, 'leaflet-tile-loaded'),
                    this.fire('tileload', { tile: d.el, coords: r })),
                  this._noTilesToLoad() &&
                    ((this._loading = !1),
                    this.fire('load'),
                    me.ielt9 || !this._map._fadeAnimated
                      ? j(this._pruneTiles, this)
                      : setTimeout(f(this._pruneTiles, this), 250)));
            },
            _getTilePos: function (r) {
              return r.scaleBy(this.getTileSize()).subtract(this._level.origin);
            },
            _wrapCoords: function (r) {
              var c = new K(
                this._wrapX ? x(r.x, this._wrapX) : r.x,
                this._wrapY ? x(r.y, this._wrapY) : r.y,
              );
              return (c.z = r.z), c;
            },
            _pxBoundsToTileRange: function (r) {
              var c = this.getTileSize();
              return new Q(r.min.unscaleBy(c).floor(), r.max.unscaleBy(c).ceil().subtract([1, 1]));
            },
            _noTilesToLoad: function () {
              for (var r in this._tiles) if (!this._tiles[r].loaded) return !1;
              return !0;
            },
          });
          function Vi(r) {
            return new cr(r);
          }
          var ur = cr.extend({
            options: {
              minZoom: 0,
              maxZoom: 18,
              subdomains: 'abc',
              errorTileUrl: '',
              zoomOffset: 0,
              tms: !1,
              zoomReverse: !1,
              detectRetina: !1,
              crossOrigin: !1,
              referrerPolicy: !1,
            },
            initialize: function (r, c) {
              (this._url = r),
                (c = R(this, c)),
                c.detectRetina && me.retina && c.maxZoom > 0
                  ? ((c.tileSize = Math.floor(c.tileSize / 2)),
                    c.zoomReverse
                      ? (c.zoomOffset--, (c.minZoom = Math.min(c.maxZoom, c.minZoom + 1)))
                      : (c.zoomOffset++, (c.maxZoom = Math.max(c.minZoom, c.maxZoom - 1))),
                    (c.minZoom = Math.max(0, c.minZoom)))
                  : c.zoomReverse
                    ? (c.minZoom = Math.min(c.maxZoom, c.minZoom))
                    : (c.maxZoom = Math.max(c.minZoom, c.maxZoom)),
                typeof c.subdomains == 'string' && (c.subdomains = c.subdomains.split('')),
                this.on('tileunload', this._onTileRemove);
            },
            setUrl: function (r, c) {
              return (
                this._url === r && c === void 0 && (c = !0),
                (this._url = r),
                c || this.redraw(),
                this
              );
            },
            createTile: function (r, c) {
              var d = document.createElement('img');
              return (
                De(d, 'load', f(this._tileOnLoad, this, c, d)),
                De(d, 'error', f(this._tileOnError, this, c, d)),
                (this.options.crossOrigin || this.options.crossOrigin === '') &&
                  (d.crossOrigin = this.options.crossOrigin === !0 ? '' : this.options.crossOrigin),
                typeof this.options.referrerPolicy == 'string' &&
                  (d.referrerPolicy = this.options.referrerPolicy),
                (d.alt = ''),
                (d.src = this.getTileUrl(r)),
                d
              );
            },
            getTileUrl: function (r) {
              var c = {
                r: me.retina ? '@2x' : '',
                s: this._getSubdomain(r),
                x: r.x,
                y: r.y,
                z: this._getZoomForUrl(),
              };
              if (this._map && !this._map.options.crs.infinite) {
                var d = this._globalTileRange.max.y - r.y;
                this.options.tms && (c.y = d), (c['-y'] = d);
              }
              return z(this._url, l(c, this.options));
            },
            _tileOnLoad: function (r, c) {
              me.ielt9 ? setTimeout(f(r, this, null, c), 0) : r(null, c);
            },
            _tileOnError: function (r, c, d) {
              var y = this.options.errorTileUrl;
              y && c.getAttribute('src') !== y && (c.src = y), r(d, c);
            },
            _onTileRemove: function (r) {
              r.tile.onload = null;
            },
            _getZoomForUrl: function () {
              var r = this._tileZoom,
                c = this.options.maxZoom,
                d = this.options.zoomReverse,
                y = this.options.zoomOffset;
              return d && (r = c - r), r + y;
            },
            _getSubdomain: function (r) {
              var c = Math.abs(r.x + r.y) % this.options.subdomains.length;
              return this.options.subdomains[c];
            },
            _abortLoading: function () {
              var r, c;
              for (r in this._tiles)
                if (
                  this._tiles[r].coords.z !== this._tileZoom &&
                  ((c = this._tiles[r].el), (c.onload = S), (c.onerror = S), !c.complete)
                ) {
                  c.src = W;
                  var d = this._tiles[r].coords;
                  Re(c), delete this._tiles[r], this.fire('tileabort', { tile: c, coords: d });
                }
            },
            _removeTile: function (r) {
              var c = this._tiles[r];
              if (c) return c.el.setAttribute('src', W), cr.prototype._removeTile.call(this, r);
            },
            _tileReady: function (r, c, d) {
              if (!(!this._map || (d && d.getAttribute('src') === W)))
                return cr.prototype._tileReady.call(this, r, c, d);
            },
          });
          function bi(r, c) {
            return new ur(r, c);
          }
          var Ei = ur.extend({
            defaultWmsParams: {
              service: 'WMS',
              request: 'GetMap',
              layers: '',
              styles: '',
              format: 'image/jpeg',
              transparent: !1,
              version: '1.1.1',
            },
            options: { crs: null, uppercase: !1 },
            initialize: function (r, c) {
              this._url = r;
              var d = l({}, this.defaultWmsParams);
              for (var y in c) y in this.options || (d[y] = c[y]);
              c = R(this, c);
              var w = c.detectRetina && me.retina ? 2 : 1,
                U = this.getTileSize();
              (d.width = U.x * w), (d.height = U.y * w), (this.wmsParams = d);
            },
            onAdd: function (r) {
              (this._crs = this.options.crs || r.options.crs),
                (this._wmsVersion = parseFloat(this.wmsParams.version));
              var c = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
              (this.wmsParams[c] = this._crs.code), ur.prototype.onAdd.call(this, r);
            },
            getTileUrl: function (r) {
              var c = this._tileCoordsToNwSe(r),
                d = this._crs,
                y = gt(d.project(c[0]), d.project(c[1])),
                w = y.min,
                U = y.max,
                q = (
                  this._wmsVersion >= 1.3 && this._crs === Bu
                    ? [w.y, w.x, U.y, U.x]
                    : [w.x, w.y, U.x, U.y]
                ).join(','),
                ht = ur.prototype.getTileUrl.call(this, r);
              return (
                ht +
                T(this.wmsParams, ht, this.options.uppercase) +
                (this.options.uppercase ? '&BBOX=' : '&bbox=') +
                q
              );
            },
            setParams: function (r, c) {
              return l(this.wmsParams, r), c || this.redraw(), this;
            },
          });
          function $r(r, c) {
            return new Ei(r, c);
          }
          (ur.WMS = Ei), (bi.wms = $r);
          var Wi = Fi.extend({
              options: { padding: 0.1 },
              initialize: function (r) {
                R(this, r), _(this), (this._layers = this._layers || {});
              },
              onAdd: function () {
                this._container ||
                  (this._initContainer(), ne(this._container, 'leaflet-zoom-animated')),
                  this.getPane().appendChild(this._container),
                  this._update(),
                  this.on('update', this._updatePaths, this);
              },
              onRemove: function () {
                this.off('update', this._updatePaths, this), this._destroyContainer();
              },
              getEvents: function () {
                var r = {
                  viewreset: this._reset,
                  zoom: this._onZoom,
                  moveend: this._update,
                  zoomend: this._onZoomEnd,
                };
                return this._zoomAnimated && (r.zoomanim = this._onAnimZoom), r;
              },
              _onAnimZoom: function (r) {
                this._updateTransform(r.center, r.zoom);
              },
              _onZoom: function () {
                this._updateTransform(this._map.getCenter(), this._map.getZoom());
              },
              _updateTransform: function (r, c) {
                var d = this._map.getZoomScale(c, this._zoom),
                  y = this._map.getSize().multiplyBy(0.5 + this.options.padding),
                  w = this._map.project(this._center, c),
                  U = y.multiplyBy(-d).add(w).subtract(this._map._getNewPixelOrigin(r, c));
                me.any3d ? mn(this._container, U, d) : He(this._container, U);
              },
              _reset: function () {
                this._update(), this._updateTransform(this._center, this._zoom);
                for (var r in this._layers) this._layers[r]._reset();
              },
              _onZoomEnd: function () {
                for (var r in this._layers) this._layers[r]._project();
              },
              _updatePaths: function () {
                for (var r in this._layers) this._layers[r]._update();
              },
              _update: function () {
                var r = this.options.padding,
                  c = this._map.getSize(),
                  d = this._map.containerPointToLayerPoint(c.multiplyBy(-r)).round();
                (this._bounds = new Q(d, d.add(c.multiplyBy(1 + r * 2)).round())),
                  (this._center = this._map.getCenter()),
                  (this._zoom = this._map.getZoom());
              },
            }),
            Ys = Wi.extend({
              options: { tolerance: 0 },
              getEvents: function () {
                var r = Wi.prototype.getEvents.call(this);
                return (r.viewprereset = this._onViewPreReset), r;
              },
              _onViewPreReset: function () {
                this._postponeUpdatePaths = !0;
              },
              onAdd: function () {
                Wi.prototype.onAdd.call(this), this._draw();
              },
              _initContainer: function () {
                var r = (this._container = document.createElement('canvas'));
                De(r, 'mousemove', this._onMouseMove, this),
                  De(r, 'click dblclick mousedown mouseup contextmenu', this._onClick, this),
                  De(r, 'mouseout', this._handleMouseOut, this),
                  (r._leaflet_disable_events = !0),
                  (this._ctx = r.getContext('2d'));
              },
              _destroyContainer: function () {
                ft(this._redrawRequest),
                  delete this._ctx,
                  Re(this._container),
                  $e(this._container),
                  delete this._container;
              },
              _updatePaths: function () {
                if (!this._postponeUpdatePaths) {
                  var r;
                  this._redrawBounds = null;
                  for (var c in this._layers) (r = this._layers[c]), r._update();
                  this._redraw();
                }
              },
              _update: function () {
                if (!(this._map._animatingZoom && this._bounds)) {
                  Wi.prototype._update.call(this);
                  var r = this._bounds,
                    c = this._container,
                    d = r.getSize(),
                    y = me.retina ? 2 : 1;
                  He(c, r.min),
                    (c.width = y * d.x),
                    (c.height = y * d.y),
                    (c.style.width = d.x + 'px'),
                    (c.style.height = d.y + 'px'),
                    me.retina && this._ctx.scale(2, 2),
                    this._ctx.translate(-r.min.x, -r.min.y),
                    this.fire('update');
                }
              },
              _reset: function () {
                Wi.prototype._reset.call(this),
                  this._postponeUpdatePaths &&
                    ((this._postponeUpdatePaths = !1), this._updatePaths());
              },
              _initPath: function (r) {
                this._updateDashArray(r), (this._layers[_(r)] = r);
                var c = (r._order = { layer: r, prev: this._drawLast, next: null });
                this._drawLast && (this._drawLast.next = c),
                  (this._drawLast = c),
                  (this._drawFirst = this._drawFirst || this._drawLast);
              },
              _addPath: function (r) {
                this._requestRedraw(r);
              },
              _removePath: function (r) {
                var c = r._order,
                  d = c.next,
                  y = c.prev;
                d ? (d.prev = y) : (this._drawLast = y),
                  y ? (y.next = d) : (this._drawFirst = d),
                  delete r._order,
                  delete this._layers[_(r)],
                  this._requestRedraw(r);
              },
              _updatePath: function (r) {
                this._extendRedrawBounds(r), r._project(), r._update(), this._requestRedraw(r);
              },
              _updateStyle: function (r) {
                this._updateDashArray(r), this._requestRedraw(r);
              },
              _updateDashArray: function (r) {
                if (typeof r.options.dashArray == 'string') {
                  var c = r.options.dashArray.split(/[, ]+/),
                    d = [],
                    y,
                    w;
                  for (w = 0; w < c.length; w++) {
                    if (((y = Number(c[w])), isNaN(y))) return;
                    d.push(y);
                  }
                  r.options._dashArray = d;
                } else r.options._dashArray = r.options.dashArray;
              },
              _requestRedraw: function (r) {
                this._map &&
                  (this._extendRedrawBounds(r),
                  (this._redrawRequest = this._redrawRequest || j(this._redraw, this)));
              },
              _extendRedrawBounds: function (r) {
                if (r._pxBounds) {
                  var c = (r.options.weight || 0) + 1;
                  (this._redrawBounds = this._redrawBounds || new Q()),
                    this._redrawBounds.extend(r._pxBounds.min.subtract([c, c])),
                    this._redrawBounds.extend(r._pxBounds.max.add([c, c]));
                }
              },
              _redraw: function () {
                (this._redrawRequest = null),
                  this._redrawBounds &&
                    (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()),
                  this._clear(),
                  this._draw(),
                  (this._redrawBounds = null);
              },
              _clear: function () {
                var r = this._redrawBounds;
                if (r) {
                  var c = r.getSize();
                  this._ctx.clearRect(r.min.x, r.min.y, c.x, c.y);
                } else
                  this._ctx.save(),
                    this._ctx.setTransform(1, 0, 0, 1, 0, 0),
                    this._ctx.clearRect(0, 0, this._container.width, this._container.height),
                    this._ctx.restore();
              },
              _draw: function () {
                var r,
                  c = this._redrawBounds;
                if ((this._ctx.save(), c)) {
                  var d = c.getSize();
                  this._ctx.beginPath(),
                    this._ctx.rect(c.min.x, c.min.y, d.x, d.y),
                    this._ctx.clip();
                }
                this._drawing = !0;
                for (var y = this._drawFirst; y; y = y.next)
                  (r = y.layer),
                    (!c || (r._pxBounds && r._pxBounds.intersects(c))) && r._updatePath();
                (this._drawing = !1), this._ctx.restore();
              },
              _updatePoly: function (r, c) {
                if (this._drawing) {
                  var d,
                    y,
                    w,
                    U,
                    q = r._parts,
                    ht = q.length,
                    St = this._ctx;
                  if (ht) {
                    for (St.beginPath(), d = 0; d < ht; d++) {
                      for (y = 0, w = q[d].length; y < w; y++)
                        (U = q[d][y]), St[y ? 'lineTo' : 'moveTo'](U.x, U.y);
                      c && St.closePath();
                    }
                    this._fillStroke(St, r);
                  }
                }
              },
              _updateCircle: function (r) {
                if (!(!this._drawing || r._empty())) {
                  var c = r._point,
                    d = this._ctx,
                    y = Math.max(Math.round(r._radius), 1),
                    w = (Math.max(Math.round(r._radiusY), 1) || y) / y;
                  w !== 1 && (d.save(), d.scale(1, w)),
                    d.beginPath(),
                    d.arc(c.x, c.y / w, y, 0, Math.PI * 2, !1),
                    w !== 1 && d.restore(),
                    this._fillStroke(d, r);
                }
              },
              _fillStroke: function (r, c) {
                var d = c.options;
                d.fill &&
                  ((r.globalAlpha = d.fillOpacity),
                  (r.fillStyle = d.fillColor || d.color),
                  r.fill(d.fillRule || 'evenodd')),
                  d.stroke &&
                    d.weight !== 0 &&
                    (r.setLineDash && r.setLineDash((c.options && c.options._dashArray) || []),
                    (r.globalAlpha = d.opacity),
                    (r.lineWidth = d.weight),
                    (r.strokeStyle = d.color),
                    (r.lineCap = d.lineCap),
                    (r.lineJoin = d.lineJoin),
                    r.stroke());
              },
              _onClick: function (r) {
                for (
                  var c = this._map.mouseEventToLayerPoint(r), d, y, w = this._drawFirst;
                  w;
                  w = w.next
                )
                  (d = w.layer),
                    d.options.interactive &&
                      d._containsPoint(c) &&
                      (!(r.type === 'click' || r.type === 'preclick') ||
                        !this._map._draggableMoved(d)) &&
                      (y = d);
                this._fireEvent(y ? [y] : !1, r);
              },
              _onMouseMove: function (r) {
                if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
                  var c = this._map.mouseEventToLayerPoint(r);
                  this._handleMouseHover(r, c);
                }
              },
              _handleMouseOut: function (r) {
                var c = this._hoveredLayer;
                c &&
                  (We(this._container, 'leaflet-interactive'),
                  this._fireEvent([c], r, 'mouseout'),
                  (this._hoveredLayer = null),
                  (this._mouseHoverThrottled = !1));
              },
              _handleMouseHover: function (r, c) {
                if (!this._mouseHoverThrottled) {
                  for (var d, y, w = this._drawFirst; w; w = w.next)
                    (d = w.layer), d.options.interactive && d._containsPoint(c) && (y = d);
                  y !== this._hoveredLayer &&
                    (this._handleMouseOut(r),
                    y &&
                      (ne(this._container, 'leaflet-interactive'),
                      this._fireEvent([y], r, 'mouseover'),
                      (this._hoveredLayer = y))),
                    this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, r),
                    (this._mouseHoverThrottled = !0),
                    setTimeout(
                      f(function () {
                        this._mouseHoverThrottled = !1;
                      }, this),
                      32,
                    );
                }
              },
              _fireEvent: function (r, c, d) {
                this._map._fireDOMEvent(c, d || c.type, r);
              },
              _bringToFront: function (r) {
                var c = r._order;
                if (c) {
                  var d = c.next,
                    y = c.prev;
                  if (d) d.prev = y;
                  else return;
                  y ? (y.next = d) : d && (this._drawFirst = d),
                    (c.prev = this._drawLast),
                    (this._drawLast.next = c),
                    (c.next = null),
                    (this._drawLast = c),
                    this._requestRedraw(r);
                }
              },
              _bringToBack: function (r) {
                var c = r._order;
                if (c) {
                  var d = c.next,
                    y = c.prev;
                  if (y) y.next = d;
                  else return;
                  d ? (d.prev = y) : y && (this._drawLast = y),
                    (c.prev = null),
                    (c.next = this._drawFirst),
                    (this._drawFirst.prev = c),
                    (this._drawFirst = c),
                    this._requestRedraw(r);
                }
              },
            });
          function Ks(r) {
            return me.canvas ? new Ys(r) : null;
          }
          var hr = (function () {
              try {
                return (
                  document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml'),
                  function (r) {
                    return document.createElement('<lvml:' + r + ' class="lvml">');
                  }
                );
              } catch {}
              return function (r) {
                return document.createElement(
                  '<' + r + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">',
                );
              };
            })(),
            ts = {
              _initContainer: function () {
                this._container = ue('div', 'leaflet-vml-container');
              },
              _update: function () {
                this._map._animatingZoom || (Wi.prototype._update.call(this), this.fire('update'));
              },
              _initPath: function (r) {
                var c = (r._container = hr('shape'));
                ne(c, 'leaflet-vml-shape ' + (this.options.className || '')),
                  (c.coordsize = '1 1'),
                  (r._path = hr('path')),
                  c.appendChild(r._path),
                  this._updateStyle(r),
                  (this._layers[_(r)] = r);
              },
              _addPath: function (r) {
                var c = r._container;
                this._container.appendChild(c), r.options.interactive && r.addInteractiveTarget(c);
              },
              _removePath: function (r) {
                var c = r._container;
                Re(c), r.removeInteractiveTarget(c), delete this._layers[_(r)];
              },
              _updateStyle: function (r) {
                var c = r._stroke,
                  d = r._fill,
                  y = r.options,
                  w = r._container;
                (w.stroked = !!y.stroke),
                  (w.filled = !!y.fill),
                  y.stroke
                    ? (c || (c = r._stroke = hr('stroke')),
                      w.appendChild(c),
                      (c.weight = y.weight + 'px'),
                      (c.color = y.color),
                      (c.opacity = y.opacity),
                      y.dashArray
                        ? (c.dashStyle = P(y.dashArray)
                            ? y.dashArray.join(' ')
                            : y.dashArray.replace(/( *, *)/g, ' '))
                        : (c.dashStyle = ''),
                      (c.endcap = y.lineCap.replace('butt', 'flat')),
                      (c.joinstyle = y.lineJoin))
                    : c && (w.removeChild(c), (r._stroke = null)),
                  y.fill
                    ? (d || (d = r._fill = hr('fill')),
                      w.appendChild(d),
                      (d.color = y.fillColor || y.color),
                      (d.opacity = y.fillOpacity))
                    : d && (w.removeChild(d), (r._fill = null));
              },
              _updateCircle: function (r) {
                var c = r._point.round(),
                  d = Math.round(r._radius),
                  y = Math.round(r._radiusY || d);
                this._setPath(
                  r,
                  r._empty()
                    ? 'M0 0'
                    : 'AL ' + c.x + ',' + c.y + ' ' + d + ',' + y + ' 0,' + 65535 * 360,
                );
              },
              _setPath: function (r, c) {
                r._path.v = c;
              },
              _bringToFront: function (r) {
                ze(r._container);
              },
              _bringToBack: function (r) {
                ge(r._container);
              },
            },
            Qs = me.vml ? hr : Zt,
            Ia = Wi.extend({
              _initContainer: function () {
                (this._container = Qs('svg')),
                  this._container.setAttribute('pointer-events', 'none'),
                  (this._rootGroup = Qs('g')),
                  this._container.appendChild(this._rootGroup);
              },
              _destroyContainer: function () {
                Re(this._container),
                  $e(this._container),
                  delete this._container,
                  delete this._rootGroup,
                  delete this._svgSize;
              },
              _update: function () {
                if (!(this._map._animatingZoom && this._bounds)) {
                  Wi.prototype._update.call(this);
                  var r = this._bounds,
                    c = r.getSize(),
                    d = this._container;
                  (!this._svgSize || !this._svgSize.equals(c)) &&
                    ((this._svgSize = c),
                    d.setAttribute('width', c.x),
                    d.setAttribute('height', c.y)),
                    He(d, r.min),
                    d.setAttribute('viewBox', [r.min.x, r.min.y, c.x, c.y].join(' ')),
                    this.fire('update');
                }
              },
              _initPath: function (r) {
                var c = (r._path = Qs('path'));
                r.options.className && ne(c, r.options.className),
                  r.options.interactive && ne(c, 'leaflet-interactive'),
                  this._updateStyle(r),
                  (this._layers[_(r)] = r);
              },
              _addPath: function (r) {
                this._rootGroup || this._initContainer(),
                  this._rootGroup.appendChild(r._path),
                  r.addInteractiveTarget(r._path);
              },
              _removePath: function (r) {
                Re(r._path), r.removeInteractiveTarget(r._path), delete this._layers[_(r)];
              },
              _updatePath: function (r) {
                r._project(), r._update();
              },
              _updateStyle: function (r) {
                var c = r._path,
                  d = r.options;
                c &&
                  (d.stroke
                    ? (c.setAttribute('stroke', d.color),
                      c.setAttribute('stroke-opacity', d.opacity),
                      c.setAttribute('stroke-width', d.weight),
                      c.setAttribute('stroke-linecap', d.lineCap),
                      c.setAttribute('stroke-linejoin', d.lineJoin),
                      d.dashArray
                        ? c.setAttribute('stroke-dasharray', d.dashArray)
                        : c.removeAttribute('stroke-dasharray'),
                      d.dashOffset
                        ? c.setAttribute('stroke-dashoffset', d.dashOffset)
                        : c.removeAttribute('stroke-dashoffset'))
                    : c.setAttribute('stroke', 'none'),
                  d.fill
                    ? (c.setAttribute('fill', d.fillColor || d.color),
                      c.setAttribute('fill-opacity', d.fillOpacity),
                      c.setAttribute('fill-rule', d.fillRule || 'evenodd'))
                    : c.setAttribute('fill', 'none'));
              },
              _updatePoly: function (r, c) {
                this._setPath(r, Bt(r._parts, c));
              },
              _updateCircle: function (r) {
                var c = r._point,
                  d = Math.max(Math.round(r._radius), 1),
                  y = Math.max(Math.round(r._radiusY), 1) || d,
                  w = 'a' + d + ',' + y + ' 0 1,0 ',
                  U = r._empty()
                    ? 'M0 0'
                    : 'M' + (c.x - d) + ',' + c.y + w + d * 2 + ',0 ' + w + -d * 2 + ',0 ';
                this._setPath(r, U);
              },
              _setPath: function (r, c) {
                r._path.setAttribute('d', c);
              },
              _bringToFront: function (r) {
                ze(r._path);
              },
              _bringToBack: function (r) {
                ge(r._path);
              },
            });
          me.vml && Ia.include(ts);
          function fr(r) {
            return me.svg || me.vml ? new Ia(r) : null;
          }
          Ze.include({
            getRenderer: function (r) {
              var c =
                r.options.renderer ||
                this._getPaneRenderer(r.options.pane) ||
                this.options.renderer ||
                this._renderer;
              return (
                c || (c = this._renderer = this._createRenderer()),
                this.hasLayer(c) || this.addLayer(c),
                c
              );
            },
            _getPaneRenderer: function (r) {
              if (r === 'overlayPane' || r === void 0) return !1;
              var c = this._paneRenderers[r];
              return (
                c === void 0 &&
                  ((c = this._createRenderer({ pane: r })), (this._paneRenderers[r] = c)),
                c
              );
            },
            _createRenderer: function (r) {
              return (this.options.preferCanvas && Ks(r)) || fr(r);
            },
          });
          var Zu = Kr.extend({
            initialize: function (r, c) {
              Kr.prototype.initialize.call(this, this._boundsToLatLngs(r), c);
            },
            setBounds: function (r) {
              return this.setLatLngs(this._boundsToLatLngs(r));
            },
            _boundsToLatLngs: function (r) {
              return (
                (r = tt(r)),
                [r.getSouthWest(), r.getNorthWest(), r.getNorthEast(), r.getSouthEast()]
              );
            },
          });
          function Ti(r, c) {
            return new Zu(r, c);
          }
          (Ia.create = Qs),
            (Ia.pointsToPath = Bt),
            (Mi.geometryToLayer = Zs),
            (Mi.coordsToLatLng = ko),
            (Mi.coordsToLatLngs = Xs),
            (Mi.latLngToCoords = js),
            (Mi.latLngsToCoords = Fo),
            (Mi.getFeature = Hi),
            (Mi.asFeature = Qr),
            Ze.mergeOptions({ boxZoom: !0 });
          var Wo = ki.extend({
            initialize: function (r) {
              (this._map = r),
                (this._container = r._container),
                (this._pane = r._panes.overlayPane),
                (this._resetStateTimeout = 0),
                r.on('unload', this._destroy, this);
            },
            addHooks: function () {
              De(this._container, 'mousedown', this._onMouseDown, this);
            },
            removeHooks: function () {
              $e(this._container, 'mousedown', this._onMouseDown, this);
            },
            moved: function () {
              return this._moved;
            },
            _destroy: function () {
              Re(this._pane), delete this._pane;
            },
            _resetState: function () {
              (this._resetStateTimeout = 0), (this._moved = !1);
            },
            _clearDeferredResetState: function () {
              this._resetStateTimeout !== 0 &&
                (clearTimeout(this._resetStateTimeout), (this._resetStateTimeout = 0));
            },
            _onMouseDown: function (r) {
              if (!r.shiftKey || (r.which !== 1 && r.button !== 1)) return !1;
              this._clearDeferredResetState(),
                this._resetState(),
                hi(),
                Bs(),
                (this._startPoint = this._map.mouseEventToContainerPoint(r)),
                De(
                  document,
                  {
                    contextmenu: aa,
                    mousemove: this._onMouseMove,
                    mouseup: this._onMouseUp,
                    keydown: this._onKeyDown,
                  },
                  this,
                );
            },
            _onMouseMove: function (r) {
              this._moved ||
                ((this._moved = !0),
                (this._box = ue('div', 'leaflet-zoom-box', this._container)),
                ne(this._container, 'leaflet-crosshair'),
                this._map.fire('boxzoomstart')),
                (this._point = this._map.mouseEventToContainerPoint(r));
              var c = new Q(this._point, this._startPoint),
                d = c.getSize();
              He(this._box, c.min),
                (this._box.style.width = d.x + 'px'),
                (this._box.style.height = d.y + 'px');
            },
            _finish: function () {
              this._moved && (Re(this._box), We(this._container, 'leaflet-crosshair')),
                yi(),
                Jl(),
                $e(
                  document,
                  {
                    contextmenu: aa,
                    mousemove: this._onMouseMove,
                    mouseup: this._onMouseUp,
                    keydown: this._onKeyDown,
                  },
                  this,
                );
            },
            _onMouseUp: function (r) {
              if (!(r.which !== 1 && r.button !== 1) && (this._finish(), !!this._moved)) {
                this._clearDeferredResetState(),
                  (this._resetStateTimeout = setTimeout(f(this._resetState, this), 0));
                var c = new At(
                  this._map.containerPointToLatLng(this._startPoint),
                  this._map.containerPointToLatLng(this._point),
                );
                this._map.fitBounds(c).fire('boxzoomend', { boxZoomBounds: c });
              }
            },
            _onKeyDown: function (r) {
              r.keyCode === 27 &&
                (this._finish(), this._clearDeferredResetState(), this._resetState());
            },
          });
          Ze.addInitHook('addHandler', 'boxZoom', Wo), Ze.mergeOptions({ doubleClickZoom: !0 });
          var sa = ki.extend({
            addHooks: function () {
              this._map.on('dblclick', this._onDoubleClick, this);
            },
            removeHooks: function () {
              this._map.off('dblclick', this._onDoubleClick, this);
            },
            _onDoubleClick: function (r) {
              var c = this._map,
                d = c.getZoom(),
                y = c.options.zoomDelta,
                w = r.originalEvent.shiftKey ? d - y : d + y;
              c.options.doubleClickZoom === 'center'
                ? c.setZoom(w)
                : c.setZoomAround(r.containerPoint, w);
            },
          });
          Ze.addInitHook('addHandler', 'doubleClickZoom', sa),
            Ze.mergeOptions({
              dragging: !0,
              inertia: !0,
              inertiaDeceleration: 3400,
              inertiaMaxSpeed: 1 / 0,
              easeLinearity: 0.2,
              worldCopyJump: !1,
              maxBoundsViscosity: 0,
            });
          var fc = ki.extend({
            addHooks: function () {
              if (!this._draggable) {
                var r = this._map;
                (this._draggable = new Na(r._mapPane, r._container)),
                  this._draggable.on(
                    { dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd },
                    this,
                  ),
                  this._draggable.on('predrag', this._onPreDragLimit, this),
                  r.options.worldCopyJump &&
                    (this._draggable.on('predrag', this._onPreDragWrap, this),
                    r.on('zoomend', this._onZoomEnd, this),
                    r.whenReady(this._onZoomEnd, this));
              }
              ne(this._map._container, 'leaflet-grab leaflet-touch-drag'),
                this._draggable.enable(),
                (this._positions = []),
                (this._times = []);
            },
            removeHooks: function () {
              We(this._map._container, 'leaflet-grab'),
                We(this._map._container, 'leaflet-touch-drag'),
                this._draggable.disable();
            },
            moved: function () {
              return this._draggable && this._draggable._moved;
            },
            moving: function () {
              return this._draggable && this._draggable._moving;
            },
            _onDragStart: function () {
              var r = this._map;
              if (
                (r._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity)
              ) {
                var c = tt(this._map.options.maxBounds);
                (this._offsetLimit = gt(
                  this._map.latLngToContainerPoint(c.getNorthWest()).multiplyBy(-1),
                  this._map
                    .latLngToContainerPoint(c.getSouthEast())
                    .multiplyBy(-1)
                    .add(this._map.getSize()),
                )),
                  (this._viscosity = Math.min(
                    1,
                    Math.max(0, this._map.options.maxBoundsViscosity),
                  ));
              } else this._offsetLimit = null;
              r.fire('movestart').fire('dragstart'),
                r.options.inertia && ((this._positions = []), (this._times = []));
            },
            _onDrag: function (r) {
              if (this._map.options.inertia) {
                var c = (this._lastTime = +new Date()),
                  d = (this._lastPos = this._draggable._absPos || this._draggable._newPos);
                this._positions.push(d), this._times.push(c), this._prunePositions(c);
              }
              this._map.fire('move', r).fire('drag', r);
            },
            _prunePositions: function (r) {
              for (; this._positions.length > 1 && r - this._times[0] > 50; )
                this._positions.shift(), this._times.shift();
            },
            _onZoomEnd: function () {
              var r = this._map.getSize().divideBy(2),
                c = this._map.latLngToLayerPoint([0, 0]);
              (this._initialWorldOffset = c.subtract(r).x),
                (this._worldWidth = this._map.getPixelWorldBounds().getSize().x);
            },
            _viscousLimit: function (r, c) {
              return r - (r - c) * this._viscosity;
            },
            _onPreDragLimit: function () {
              if (!(!this._viscosity || !this._offsetLimit)) {
                var r = this._draggable._newPos.subtract(this._draggable._startPos),
                  c = this._offsetLimit;
                r.x < c.min.x && (r.x = this._viscousLimit(r.x, c.min.x)),
                  r.y < c.min.y && (r.y = this._viscousLimit(r.y, c.min.y)),
                  r.x > c.max.x && (r.x = this._viscousLimit(r.x, c.max.x)),
                  r.y > c.max.y && (r.y = this._viscousLimit(r.y, c.max.y)),
                  (this._draggable._newPos = this._draggable._startPos.add(r));
              }
            },
            _onPreDragWrap: function () {
              var r = this._worldWidth,
                c = Math.round(r / 2),
                d = this._initialWorldOffset,
                y = this._draggable._newPos.x,
                w = ((y - c + d) % r) + c - d,
                U = ((y + c + d) % r) - c - d,
                q = Math.abs(w + d) < Math.abs(U + d) ? w : U;
              (this._draggable._absPos = this._draggable._newPos.clone()),
                (this._draggable._newPos.x = q);
            },
            _onDragEnd: function (r) {
              var c = this._map,
                d = c.options,
                y = !d.inertia || r.noInertia || this._times.length < 2;
              if ((c.fire('dragend', r), y)) c.fire('moveend');
              else {
                this._prunePositions(+new Date());
                var w = this._lastPos.subtract(this._positions[0]),
                  U = (this._lastTime - this._times[0]) / 1e3,
                  q = d.easeLinearity,
                  ht = w.multiplyBy(q / U),
                  St = ht.distanceTo([0, 0]),
                  Ft = Math.min(d.inertiaMaxSpeed, St),
                  ie = ht.multiplyBy(Ft / St),
                  he = Ft / (d.inertiaDeceleration * q),
                  _e = ie.multiplyBy(-he / 2).round();
                !_e.x && !_e.y
                  ? c.fire('moveend')
                  : ((_e = c._limitOffset(_e, c.options.maxBounds)),
                    j(function () {
                      c.panBy(_e, { duration: he, easeLinearity: q, noMoveStart: !0, animate: !0 });
                    }));
              }
            },
          });
          Ze.addInitHook('addHandler', 'dragging', fc),
            Ze.mergeOptions({ keyboard: !0, keyboardPanDelta: 80 });
          var Js = ki.extend({
            keyCodes: {
              left: [37],
              right: [39],
              down: [40],
              up: [38],
              zoomIn: [187, 107, 61, 171],
              zoomOut: [189, 109, 54, 173],
            },
            initialize: function (r) {
              (this._map = r),
                this._setPanDelta(r.options.keyboardPanDelta),
                this._setZoomDelta(r.options.zoomDelta);
            },
            addHooks: function () {
              var r = this._map._container;
              r.tabIndex <= 0 && (r.tabIndex = '0'),
                De(
                  r,
                  { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown },
                  this,
                ),
                this._map.on({ focus: this._addHooks, blur: this._removeHooks }, this);
            },
            removeHooks: function () {
              this._removeHooks(),
                $e(
                  this._map._container,
                  { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown },
                  this,
                ),
                this._map.off({ focus: this._addHooks, blur: this._removeHooks }, this);
            },
            _onMouseDown: function () {
              if (!this._focused) {
                var r = document.body,
                  c = document.documentElement,
                  d = r.scrollTop || c.scrollTop,
                  y = r.scrollLeft || c.scrollLeft;
                this._map._container.focus(), window.scrollTo(y, d);
              }
            },
            _onFocus: function () {
              (this._focused = !0), this._map.fire('focus');
            },
            _onBlur: function () {
              (this._focused = !1), this._map.fire('blur');
            },
            _setPanDelta: function (r) {
              var c = (this._panKeys = {}),
                d = this.keyCodes,
                y,
                w;
              for (y = 0, w = d.left.length; y < w; y++) c[d.left[y]] = [-1 * r, 0];
              for (y = 0, w = d.right.length; y < w; y++) c[d.right[y]] = [r, 0];
              for (y = 0, w = d.down.length; y < w; y++) c[d.down[y]] = [0, r];
              for (y = 0, w = d.up.length; y < w; y++) c[d.up[y]] = [0, -1 * r];
            },
            _setZoomDelta: function (r) {
              var c = (this._zoomKeys = {}),
                d = this.keyCodes,
                y,
                w;
              for (y = 0, w = d.zoomIn.length; y < w; y++) c[d.zoomIn[y]] = r;
              for (y = 0, w = d.zoomOut.length; y < w; y++) c[d.zoomOut[y]] = -r;
            },
            _addHooks: function () {
              De(document, 'keydown', this._onKeyDown, this);
            },
            _removeHooks: function () {
              $e(document, 'keydown', this._onKeyDown, this);
            },
            _onKeyDown: function (r) {
              if (!(r.altKey || r.ctrlKey || r.metaKey)) {
                var c = r.keyCode,
                  d = this._map,
                  y;
                if (c in this._panKeys) {
                  if (!d._panAnim || !d._panAnim._inProgress)
                    if (
                      ((y = this._panKeys[c]),
                      r.shiftKey && (y = N(y).multiplyBy(3)),
                      d.options.maxBounds && (y = d._limitOffset(N(y), d.options.maxBounds)),
                      d.options.worldCopyJump)
                    ) {
                      var w = d.wrapLatLng(d.unproject(d.project(d.getCenter()).add(y)));
                      d.panTo(w);
                    } else d.panBy(y);
                } else if (c in this._zoomKeys)
                  d.setZoom(d.getZoom() + (r.shiftKey ? 3 : 1) * this._zoomKeys[c]);
                else if (c === 27 && d._popup && d._popup.options.closeOnEscapeKey) d.closePopup();
                else return;
                aa(r);
              }
            },
          });
          Ze.addInitHook('addHandler', 'keyboard', Js),
            Ze.mergeOptions({
              scrollWheelZoom: !0,
              wheelDebounceTime: 40,
              wheelPxPerZoomLevel: 60,
            });
          var Ba = ki.extend({
            addHooks: function () {
              De(this._map._container, 'wheel', this._onWheelScroll, this), (this._delta = 0);
            },
            removeHooks: function () {
              $e(this._map._container, 'wheel', this._onWheelScroll, this);
            },
            _onWheelScroll: function (r) {
              var c = Hs(r),
                d = this._map.options.wheelDebounceTime;
              (this._delta += c),
                (this._lastMousePos = this._map.mouseEventToContainerPoint(r)),
                this._startTime || (this._startTime = +new Date());
              var y = Math.max(d - (+new Date() - this._startTime), 0);
              clearTimeout(this._timer),
                (this._timer = setTimeout(f(this._performZoom, this), y)),
                aa(r);
            },
            _performZoom: function () {
              var r = this._map,
                c = r.getZoom(),
                d = this._map.options.zoomSnap || 0;
              r._stop();
              var y = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
                w = (4 * Math.log(2 / (1 + Math.exp(-Math.abs(y))))) / Math.LN2,
                U = d ? Math.ceil(w / d) * d : w,
                q = r._limitZoom(c + (this._delta > 0 ? U : -U)) - c;
              (this._delta = 0),
                (this._startTime = null),
                q &&
                  (r.options.scrollWheelZoom === 'center'
                    ? r.setZoom(c + q)
                    : r.setZoomAround(this._lastMousePos, c + q));
            },
          });
          Ze.addInitHook('addHandler', 'scrollWheelZoom', Ba);
          var dc = 600;
          Ze.mergeOptions({ tapHold: me.touchNative && me.safari && me.mobile, tapTolerance: 15 });
          var Zo = ki.extend({
            addHooks: function () {
              De(this._map._container, 'touchstart', this._onDown, this);
            },
            removeHooks: function () {
              $e(this._map._container, 'touchstart', this._onDown, this);
            },
            _onDown: function (r) {
              if ((clearTimeout(this._holdTimeout), r.touches.length === 1)) {
                var c = r.touches[0];
                (this._startPos = this._newPos = new K(c.clientX, c.clientY)),
                  (this._holdTimeout = setTimeout(
                    f(function () {
                      this._cancel(),
                        this._isTapValid() &&
                          (De(document, 'touchend', Dn),
                          De(document, 'touchend touchcancel', this._cancelClickPrevent),
                          this._simulateEvent('contextmenu', c));
                    }, this),
                    dc,
                  )),
                  De(document, 'touchend touchcancel contextmenu', this._cancel, this),
                  De(document, 'touchmove', this._onMove, this);
              }
            },
            _cancelClickPrevent: function r() {
              $e(document, 'touchend', Dn), $e(document, 'touchend touchcancel', r);
            },
            _cancel: function () {
              clearTimeout(this._holdTimeout),
                $e(document, 'touchend touchcancel contextmenu', this._cancel, this),
                $e(document, 'touchmove', this._onMove, this);
            },
            _onMove: function (r) {
              var c = r.touches[0];
              this._newPos = new K(c.clientX, c.clientY);
            },
            _isTapValid: function () {
              return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
            },
            _simulateEvent: function (r, c) {
              var d = new MouseEvent(r, {
                bubbles: !0,
                cancelable: !0,
                view: window,
                screenX: c.screenX,
                screenY: c.screenY,
                clientX: c.clientX,
                clientY: c.clientY,
              });
              (d._simulated = !0), c.target.dispatchEvent(d);
            },
          });
          Ze.addInitHook('addHandler', 'tapHold', Zo),
            Ze.mergeOptions({ touchZoom: me.touch, bounceAtZoomLimits: !0 });
          var dr = ki.extend({
            addHooks: function () {
              ne(this._map._container, 'leaflet-touch-zoom'),
                De(this._map._container, 'touchstart', this._onTouchStart, this);
            },
            removeHooks: function () {
              We(this._map._container, 'leaflet-touch-zoom'),
                $e(this._map._container, 'touchstart', this._onTouchStart, this);
            },
            _onTouchStart: function (r) {
              var c = this._map;
              if (!(!r.touches || r.touches.length !== 2 || c._animatingZoom || this._zooming)) {
                var d = c.mouseEventToContainerPoint(r.touches[0]),
                  y = c.mouseEventToContainerPoint(r.touches[1]);
                (this._centerPoint = c.getSize()._divideBy(2)),
                  (this._startLatLng = c.containerPointToLatLng(this._centerPoint)),
                  c.options.touchZoom !== 'center' &&
                    (this._pinchStartLatLng = c.containerPointToLatLng(d.add(y)._divideBy(2))),
                  (this._startDist = d.distanceTo(y)),
                  (this._startZoom = c.getZoom()),
                  (this._moved = !1),
                  (this._zooming = !0),
                  c._stop(),
                  De(document, 'touchmove', this._onTouchMove, this),
                  De(document, 'touchend touchcancel', this._onTouchEnd, this),
                  Dn(r);
              }
            },
            _onTouchMove: function (r) {
              if (!(!r.touches || r.touches.length !== 2 || !this._zooming)) {
                var c = this._map,
                  d = c.mouseEventToContainerPoint(r.touches[0]),
                  y = c.mouseEventToContainerPoint(r.touches[1]),
                  w = d.distanceTo(y) / this._startDist;
                if (
                  ((this._zoom = c.getScaleZoom(w, this._startZoom)),
                  !c.options.bounceAtZoomLimits &&
                    ((this._zoom < c.getMinZoom() && w < 1) ||
                      (this._zoom > c.getMaxZoom() && w > 1)) &&
                    (this._zoom = c._limitZoom(this._zoom)),
                  c.options.touchZoom === 'center')
                ) {
                  if (((this._center = this._startLatLng), w === 1)) return;
                } else {
                  var U = d._add(y)._divideBy(2)._subtract(this._centerPoint);
                  if (w === 1 && U.x === 0 && U.y === 0) return;
                  this._center = c.unproject(
                    c.project(this._pinchStartLatLng, this._zoom).subtract(U),
                    this._zoom,
                  );
                }
                this._moved || (c._moveStart(!0, !1), (this._moved = !0)), ft(this._animRequest);
                var q = f(c._move, c, this._center, this._zoom, { pinch: !0, round: !1 }, void 0);
                (this._animRequest = j(q, this, !0)), Dn(r);
              }
            },
            _onTouchEnd: function () {
              if (!this._moved || !this._zooming) {
                this._zooming = !1;
                return;
              }
              (this._zooming = !1),
                ft(this._animRequest),
                $e(document, 'touchmove', this._onTouchMove, this),
                $e(document, 'touchend touchcancel', this._onTouchEnd, this),
                this._map.options.zoomAnimation
                  ? this._map._animateZoom(
                      this._center,
                      this._map._limitZoom(this._zoom),
                      !0,
                      this._map.options.zoomSnap,
                    )
                  : this._map._resetView(this._center, this._map._limitZoom(this._zoom));
            },
          });
          Ze.addInitHook('addHandler', 'touchZoom', dr),
            (Ze.BoxZoom = Wo),
            (Ze.DoubleClickZoom = sa),
            (Ze.Drag = fc),
            (Ze.Keyboard = Js),
            (Ze.ScrollWheelZoom = Ba),
            (Ze.TapHold = Zo),
            (Ze.TouchZoom = dr),
            (e.Bounds = Q),
            (e.Browser = me),
            (e.CRS = It),
            (e.Canvas = Ys),
            (e.Circle = cc),
            (e.CircleMarker = Ws),
            (e.Class = Mt),
            (e.Control = fi),
            (e.DivIcon = hc),
            (e.DivOverlay = Gi),
            (e.DomEvent = Kf),
            (e.DomUtil = Au),
            (e.Draggable = Na),
            (e.Evented = it),
            (e.FeatureGroup = xi),
            (e.GeoJSON = Mi),
            (e.GridLayer = cr),
            (e.Handler = ki),
            (e.Icon = jr),
            (e.ImageOverlay = ra),
            (e.LatLng = st),
            (e.LatLngBounds = At),
            (e.Layer = Fi),
            (e.LayerGroup = or),
            (e.LineUtil = zu),
            (e.Map = Ze),
            (e.Marker = Yr),
            (e.Mixin = ed),
            (e.Path = Sa),
            (e.Point = K),
            (e.PolyUtil = nd),
            (e.Polygon = Kr),
            (e.Polyline = Ma),
            (e.Popup = qs),
            (e.PosAnimation = Oo),
            (e.Projection = Iu),
            (e.Rectangle = Zu),
            (e.Renderer = Wi),
            (e.SVG = Ia),
            (e.SVGOverlay = za),
            (e.TileLayer = ur),
            (e.Tooltip = Vo),
            (e.Transformation = Ne),
            (e.Util = pt),
            (e.VideoOverlay = Go),
            (e.bind = f),
            (e.bounds = gt),
            (e.canvas = Ks),
            (e.circle = ld),
            (e.circleMarker = Fu),
            (e.control = Zr),
            (e.divIcon = Wu),
            (e.extend = l),
            (e.featureGroup = Vs),
            (e.geoJSON = Ho),
            (e.geoJson = Hu),
            (e.gridLayer = Vi),
            (e.icon = Bo),
            (e.imageOverlay = Jr),
            (e.latLng = _t),
            (e.latLngBounds = tt),
            (e.layerGroup = ku),
            (e.map = Gs),
            (e.marker = lc),
            (e.point = N),
            (e.polygon = Si),
            (e.polyline = cd),
            (e.popup = ud),
            (e.rectangle = Ti),
            (e.setOptions = R),
            (e.stamp = _),
            (e.svg = fr),
            (e.svgOverlay = Vu),
            (e.tileLayer = bi),
            (e.tooltip = hd),
            (e.transformation = Te),
            (e.version = s),
            (e.videoOverlay = Gu);
          var es = window.L;
          (e.noConflict = function () {
            return (window.L = es), this;
          }),
            (window.L = e);
        });
      })(au, au.exports)),
    au.exports
  );
}
var ql = LT();
const V_ = jx(ql);
function W_(a, t, e) {
  return Object.freeze({ instance: a, context: t, container: e });
}
function Z_(a, t) {
  return t == null
    ? function (s, l) {
        const h = ot.useRef(void 0);
        return h.current || (h.current = a(s, l)), h;
      }
    : function (s, l) {
        const h = ot.useRef(void 0);
        h.current || (h.current = a(s, l));
        const f = ot.useRef(s),
          { instance: m } = h.current;
        return (
          ot.useEffect(
            function () {
              f.current !== s && (t(m, s, f.current), (f.current = s));
            },
            [m, s, t],
          ),
          h
        );
      };
}
function PT(a, t) {
  ot.useEffect(
    function () {
      return (
        (t.layerContainer ?? t.map).addLayer(a.instance),
        function () {
          var h;
          (h = t.layerContainer) == null || h.removeLayer(a.instance),
            t.map.removeLayer(a.instance);
        }
      );
    },
    [t, a],
  );
}
function AS(a) {
  return function (e) {
    const s = TS(),
      l = a(G_(e, s), s);
    return ES(s.map, e.attribution), wS(l.current, e.eventHandlers), PT(l.current, s), l;
  };
}
function DT(a, t) {
  const e = Z_(a, t),
    s = AS(e);
  return TT(s);
}
function OT(a, t) {
  const e = Z_(a),
    s = CT(e, t);
  return wT(s);
}
function UT(a, t) {
  const e = Z_(a, t),
    s = AS(e);
  return AT(s);
}
function NT(a, t, e) {
  const { opacity: s, zIndex: l } = t;
  s != null && s !== e.opacity && a.setOpacity(s), l != null && l !== e.zIndex && a.setZIndex(l);
}
function zT(
  {
    bounds: a,
    boundsOptions: t,
    center: e,
    children: s,
    className: l,
    id: h,
    placeholder: f,
    style: m,
    whenReady: _,
    zoom: g,
    ...x
  },
  S,
) {
  const [b] = ot.useState({ className: l, id: h, style: m }),
    [E, A] = ot.useState(null),
    R = ot.useRef(void 0);
  ot.useImperativeHandle(S, () => (E == null ? void 0 : E.map) ?? null, [E]);
  const T = ot.useCallback((z) => {
    if (z !== null && !R.current) {
      const P = new ql.Map(z, x);
      (R.current = P),
        e != null && g != null ? P.setView(e, g) : a != null && P.fitBounds(a, t),
        _ != null && P.whenReady(_),
        A(bT(P));
    }
  }, []);
  ot.useEffect(
    () => () => {
      E == null || E.map.remove();
    },
    [E],
  );
  const M = E ? pa.createElement(H_, { value: E }, s) : (f ?? null);
  return pa.createElement('div', { ...b, ref: T }, M);
}
const CS = ot.forwardRef(zT),
  RS = DT(
    function ({ position: t, ...e }, s) {
      const l = new ql.Marker(t, e);
      return W_(l, ET(s, { overlayContainer: l }));
    },
    function (t, e, s) {
      e.position !== s.position && t.setLatLng(e.position),
        e.icon != null && e.icon !== s.icon && t.setIcon(e.icon),
        e.zIndexOffset != null &&
          e.zIndexOffset !== s.zIndexOffset &&
          t.setZIndexOffset(e.zIndexOffset),
        e.opacity != null && e.opacity !== s.opacity && t.setOpacity(e.opacity),
        t.dragging != null &&
          e.draggable !== s.draggable &&
          (e.draggable === !0 ? t.dragging.enable() : t.dragging.disable());
    },
  ),
  IT = OT(
    function (t, e) {
      const s = new ql.Popup(t, e.overlayContainer);
      return W_(s, e);
    },
    function (t, e, { position: s }, l) {
      ot.useEffect(
        function () {
          const { instance: f } = t;
          function m(g) {
            g.popup === f && (f.update(), l(!0));
          }
          function _(g) {
            g.popup === f && l(!1);
          }
          return (
            e.map.on({ popupopen: m, popupclose: _ }),
            e.overlayContainer == null
              ? (s != null && f.setLatLng(s), f.openOn(e.map))
              : e.overlayContainer.bindPopup(f),
            function () {
              var x;
              e.map.off({ popupopen: m, popupclose: _ }),
                (x = e.overlayContainer) == null || x.unbindPopup(),
                e.map.removeLayer(f);
            }
          );
        },
        [t, e, l, s],
      );
    },
  ),
  LS = UT(
    function ({ url: t, ...e }, s) {
      const l = new ql.TileLayer(t, G_(e, s));
      return W_(l, s);
    },
    function (t, e, s) {
      NT(t, e, s);
      const { url: l } = e;
      l != null && l !== s.url && t.setUrl(l);
    },
  );
class PS extends Error {
  constructor(t, e) {
    super(t), (this.code = e), (this.name = 'GameError');
  }
}
class Ul extends PS {
  constructor(t) {
    super(t, 'STORAGE_ERROR'), (this.name = 'StorageError');
  }
}
const Yp = (a) => {
    a instanceof Ul
      ? console.error('Storage Error:', a.message)
      : console.error('Unexpected Storage Error:', a);
  },
  BT = (a) => (a instanceof PS ? a.code === 'STORAGE_ERROR' : !1),
  kT = 3,
  FT = 1e3,
  X_ = async (a, t = kT) => {
    let e;
    for (let s = 1; s <= t; s++)
      try {
        return await a();
      } catch (l) {
        if (((e = l), !BT(l) || s === t)) throw l;
        await new Promise((h) => setTimeout(h, FT * s));
      }
    throw e;
  },
  j_ = (a) => `topografie_game_state_${a}`,
  HT = async (a) => {
    const t = async () => {
      try {
        const e = j_(a.selectedPackage),
          s = { ...a, lastUpdated: Date.now() };
        localStorage.setItem(e, JSON.stringify(s));
      } catch (e) {
        throw new Ul(
          `Failed to save game state: ${e instanceof Error ? e.message : 'Unknown error'}`,
        );
      }
    };
    try {
      await X_(t);
    } catch (e) {
      throw (console.error('Failed to save game state after retries:', e), e);
    }
  },
  GT = async (a) => {
    const t = async () => {
      try {
        const e = j_(a),
          s = localStorage.getItem(e);
        if (s) {
          const l = JSON.parse(s);
          if (!VT(l)) throw new Ul('Invalid game state structure');
          return l;
        }
        return null;
      } catch (e) {
        throw e instanceof Ul
          ? e
          : new Ul(
              `Failed to load game state: ${e instanceof Error ? e.message : 'Unknown error'}`,
            );
      }
    };
    try {
      return await X_(t);
    } catch (e) {
      return console.error('Failed to load game state after retries:', e), await DS(a), null;
    }
  },
  DS = async (a) => {
    const t = async () => {
      try {
        const e = j_(a);
        localStorage.removeItem(e);
      } catch (e) {
        throw new Ul(
          `Failed to clear game state: ${e instanceof Error ? e.message : 'Unknown error'}`,
        );
      }
    };
    try {
      await X_(t);
    } catch (e) {
      throw (console.error('Failed to clear game state after retries:', e), e);
    }
  },
  VT = (a) => {
    if (typeof a != 'object' || a === null) return !1;
    const t = a;
    return (
      'cityStatus' in t &&
      'cityMistakes' in t &&
      'score' in t &&
      'currentAttempts' in t &&
      'hintUsed' in t &&
      'selectedPackage' in t &&
      'currentCity' in t &&
      'lastUpdated' in t
    );
  };
var OS = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 },
  by = pa.createContext && pa.createContext(OS),
  WT = ['attr', 'size', 'title'];
function ZT(a, t) {
  if (a == null) return {};
  var e = XT(a, t),
    s,
    l;
  if (Object.getOwnPropertySymbols) {
    var h = Object.getOwnPropertySymbols(a);
    for (l = 0; l < h.length; l++)
      (s = h[l]),
        !(t.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(a, s) && (e[s] = a[s]);
  }
  return e;
}
function XT(a, t) {
  if (a == null) return {};
  var e = {};
  for (var s in a)
    if (Object.prototype.hasOwnProperty.call(a, s)) {
      if (t.indexOf(s) >= 0) continue;
      e[s] = a[s];
    }
  return e;
}
function Nf() {
  return (
    (Nf = Object.assign
      ? Object.assign.bind()
      : function (a) {
          for (var t = 1; t < arguments.length; t++) {
            var e = arguments[t];
            for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && (a[s] = e[s]);
          }
          return a;
        }),
    Nf.apply(this, arguments)
  );
}
function Ey(a, t) {
  var e = Object.keys(a);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(a);
    t &&
      (s = s.filter(function (l) {
        return Object.getOwnPropertyDescriptor(a, l).enumerable;
      })),
      e.push.apply(e, s);
  }
  return e;
}
function zf(a) {
  for (var t = 1; t < arguments.length; t++) {
    var e = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? Ey(Object(e), !0).forEach(function (s) {
          jT(a, s, e[s]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(e))
        : Ey(Object(e)).forEach(function (s) {
            Object.defineProperty(a, s, Object.getOwnPropertyDescriptor(e, s));
          });
  }
  return a;
}
function jT(a, t, e) {
  return (
    (t = qT(t)),
    t in a
      ? Object.defineProperty(a, t, { value: e, enumerable: !0, configurable: !0, writable: !0 })
      : (a[t] = e),
    a
  );
}
function qT(a) {
  var t = YT(a, 'string');
  return typeof t == 'symbol' ? t : t + '';
}
function YT(a, t) {
  if (typeof a != 'object' || !a) return a;
  var e = a[Symbol.toPrimitive];
  if (e !== void 0) {
    var s = e.call(a, t);
    if (typeof s != 'object') return s;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(a);
}
function US(a) {
  return a && a.map((t, e) => pa.createElement(t.tag, zf({ key: e }, t.attr), US(t.child)));
}
function KT(a) {
  return (t) => pa.createElement(QT, Nf({ attr: zf({}, a.attr) }, t), US(a.child));
}
function QT(a) {
  var t = (e) => {
    var { attr: s, size: l, title: h } = a,
      f = ZT(a, WT),
      m = l || e.size || '1em',
      _;
    return (
      e.className && (_ = e.className),
      a.className && (_ = (_ ? _ + ' ' : '') + a.className),
      pa.createElement(
        'svg',
        Nf({ stroke: 'currentColor', fill: 'currentColor', strokeWidth: '0' }, e.attr, s, f, {
          className: _,
          style: zf(zf({ color: a.color || e.color }, e.style), a.style),
          height: m,
          width: m,
          xmlns: 'http://www.w3.org/2000/svg',
        }),
        h && pa.createElement('title', null, h),
        a.children,
      )
    );
  };
  return by !== void 0 ? pa.createElement(by.Consumer, null, (e) => t(e)) : t(OS);
}
function JT(a) {
  return KT({
    attr: { viewBox: '0 0 512 512' },
    child: [
      {
        tag: 'path',
        attr: {
          d: 'M0 405.3V448c0 35.3 86 64 192 64s192-28.7 192-64v-42.7C342.7 434.4 267.2 448 192 448S41.3 434.4 0 405.3zM320 128c106 0 192-28.7 192-64S426 0 320 0 128 28.7 128 64s86 64 192 64zM0 300.4V352c0 35.3 86 64 192 64s192-28.7 192-64v-51.6c-41.3 34-116.9 51.6-192 51.6S41.3 334.4 0 300.4zm416 11c57.3-11.1 96-31.7 96-55.4v-42.7c-23.2 16.4-57.3 27.6-96 34.5v63.6zM192 160C86 160 0 195.8 0 240s86 80 192 80 192-35.8 192-80-86-80-192-80zm219.3 56.3c60-10.8 100.7-32 100.7-56.3v-42.7c-35.5 25.1-96.5 38.6-160.7 41.8 29.5 14.3 51.2 33.5 60 57.2z',
        },
        child: [],
      },
    ],
  })(a);
}
const NS = 'topositev2_total_coins';
function zS() {
  const a = localStorage.getItem(NS);
  return a ? parseInt(a, 10) : 0;
}
function IS(a) {
  localStorage.setItem(NS, a.toString());
}
function Ty(a) {
  const t = zS();
  IS(t + a);
}
delete V_.Icon.Default.prototype._getIconUrl;
V_.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
});
const wy = jt.div`
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  background: linear-gradient(135deg, #f5f7fa 0%, #e4e8eb 100%);
  overflow: hidden;
`,
  $T = jt.header`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 2rem;
  background: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  flex-shrink: 0;
  z-index: 1000;

  @media (max-width: 768px) {
    padding: 0.75rem 1rem;
    flex-direction: column;
    gap: 0.5rem;
    height: 120px;
  }
`,
  tw = jt.div`
  display: flex;
  align-items: center;
  gap: 2rem;
`,
  ew = jt.h1`
  font-size: 1.5rem;
  color: #1a73e8;
  margin: 0;

  @media (max-width: 768px) {
    font-size: 1.2rem;
    text-align: center;
  }
`,
  nw = jt.h2`
  font-size: 1.2rem;
  color: #202124;
  margin: 0;
  font-weight: 500;

  @media (max-width: 768px) {
    font-size: 1rem;
    text-align: center;
  }
`,
  iw = jt.div`
  display: flex;
  align-items: center;
  gap: 1.5rem;
  margin-right: 1rem;

  @media (max-width: 768px) {
    flex-wrap: wrap;
    justify-content: center;
    gap: 0.75rem;
    margin-right: 0;
  }
`,
  Ay = jt.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;

  @media (max-width: 768px) {
    min-width: 80px;
  }
`,
  Cy = jt.span`
  font-size: 0.8rem;
  color: #5f6368;
`,
  Ry = jt.span`
  font-size: 1.1rem;
  font-weight: 600;
  color: #1a73e8;
`,
  Ef = jt.button`
  padding: 0.5rem 1rem;
  background: #1a73e8;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s;

  &:hover {
    background: #1557b0;
  }

  @media (max-width: 768px) {
    padding: 0.4rem 0.8rem;
    font-size: 0.9rem;
  }
`,
  aw = jt(Ef)`
  background-color: #ea4335;
  &:hover {
    background-color: #d33426;
  }
`,
  rw = jt.div`
  flex: 1;
  position: relative;
  overflow: hidden;
  min-height: 0;
  height: calc(100vh - 80px); // Account for header height

  @media (max-width: 768px) {
    height: calc(100vh - 120px); // Larger header on mobile
    position: fixed;
    top: 120px; // Match header height
    left: 0;
    right: 0;
    bottom: 0;
  }
`,
  sw = jt.div`
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  padding: 0.5rem 1rem;
  border-radius: 4px;
  color: ${(a) => (a.type === 'success' ? '#34a853' : '#ea4335')};
  font-weight: 600;
  font-size: 1.2rem;
  background: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 1000;
  opacity: 0;
  animation: fadeInOut 2s ease-in-out;
  margin-top: 1rem;

  @keyframes fadeInOut {
    0% {
      opacity: 0;
      transform: translate(-50%, -20px);
    }
    15% {
      opacity: 1;
      transform: translate(-50%, 0);
    }
    85% {
      opacity: 1;
      transform: translate(-50%, 0);
    }
    100% {
      opacity: 0;
      transform: translate(-50%, -20px);
    }
  }
`,
  ow = jt.div`
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  text-align: center;
  z-index: 1000;
  animation: fadeIn 0.3s ease-in-out;

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translate(-50%, -60%);
    }
    to {
      opacity: 1;
      transform: translate(-50%, -50%);
    }
  }
`,
  lw = jt.h2`
  color: #34a853;
  font-size: 1.5rem;
  margin-bottom: 1.5rem;
`,
  cw = jt.button`
  background: #1a73e8;
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s;

  &:hover {
    background: #1557b0;
  }
`,
  uw = jt.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
  animation: fadeIn 0.3s ease-in-out;
`,
  Ly = jt.div`
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background-color: #ff4444;
  color: white;
  padding: 1rem 2rem;
  border-radius: 4px;
  z-index: 1000;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  animation: slideIn 0.3s ease-out;

  @keyframes slideIn {
    from {
      transform: translate(-50%, -100%);
    }
    to {
      transform: translate(-50%, 0);
    }
  }
`,
  hw = jt.span`
  color: #1a73e8;
  font-weight: 600;
  margin-right: 1rem;
`,
  Py = jt.div`
  margin-right: 1.2rem;
`,
  fw = jt.div`
  margin-bottom: 1.5rem;
  text-align: left;
`,
  dw = jt.div`
  color: #34a853;
  font-weight: 600;
`,
  pw = jt.div`
  font-weight: 600;
  margin-bottom: 8px;
  color: #111;
`,
  mw = jt.ol`
  padding-left: 0;
  margin: 0;
  list-style: none;
`,
  _w = jt.li`
  margin-bottom: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 280px;
  padding: 2px 0;
`,
  gw = jt.span`
  color: #111;
  font-weight: 500;
`,
  vw = jt.span`
  color: #ea4335;
  font-weight: 500;
  min-width: 80px;
  text-align: right;
  display: inline-block;
  padding-left: 16px;
`,
  yw = jt.button`
  margin-left: 1rem;
  background: none;
  border: none;
  color: white;
  cursor: pointer;
`,
  Kp = 5,
  Wh = 5,
  Qp = 3,
  Dy = 10,
  xw = 0.2,
  Sw = jt.span`
  display: flex;
  align-items: center;
  font-size: 1.1rem;
  font-weight: 600;
  color: #ffd700;
  margin-left: 1.2rem;
  gap: 0.3rem;
`,
  Mw = jt.div`
  font-weight: 600;
  color: #ffd700;
  margin-bottom: 12px;
`,
  bw = ({ cities: a, onBack: t, selectedPackage: e }) => {
    const [s, l] = ot.useState(null),
      [h, f] = ot.useState(0),
      [m] = ot.useState(a.length),
      [_, g] = ot.useState(() => {
        const N = {};
        return (
          a.forEach((Q) => {
            N[Q.name] = 'unanswered';
          }),
          N
        );
      }),
      [x, S] = ot.useState(() => {
        const N = {};
        return (
          a.forEach((Q) => {
            N[Q.name] = 0;
          }),
          N
        );
      }),
      [b, E] = ot.useState(!1),
      [A, R] = ot.useState(!1),
      [T, M] = ot.useState(0),
      [z, P] = ot.useState(null),
      [D, W] = ot.useState(0),
      [Z, V] = ot.useState(0),
      J = ot.useRef(null),
      [F, I] = ot.useState(null),
      [j, ft] = ot.useState(Date.now()),
      [pt, Mt] = ot.useState(0),
      bt = ot.useCallback(() => {
        const N = Object.entries(_)
          .filter(([, Q]) => Q === 'blue' || Q === 'unanswered')
          .map(([Q]) => Q);
        if (N.length > 0) {
          const Q = N[Math.floor(Math.random() * N.length)],
            gt = a.find((At) => At.name === Q);
          gt && (l(gt), M(0), ft(Date.now()));
        } else l(null);
      }, [_, a]);
    ot.useEffect(() => {
      let N = !0;
      return (
        (async () => {
          try {
            const gt = await GT(e);
            N && gt
              ? (g(gt.cityStatus),
                S(gt.cityMistakes),
                f(gt.score),
                M(gt.currentAttempts),
                R(gt.hintUsed),
                l(gt.currentCity),
                typeof gt.sessionCoins == 'number' && W(gt.sessionCoins),
                typeof gt.coinsThisGame == 'number' && Mt(gt.coinsThisGame))
              : N && bt();
          } catch (gt) {
            N && (Yp(gt), P('Failed to load game state. Starting new game...'), bt());
          }
        })(),
        () => {
          N = !1;
        }
      );
    }, [e]),
      ot.useEffect(() => {
        let N = !0,
          Q;
        const gt = async () => {
          try {
            await HT({
              cityStatus: _,
              cityMistakes: x,
              score: h,
              currentAttempts: T,
              hintUsed: A,
              currentCity: s,
              selectedPackage: e,
              lastUpdated: Date.now(),
              sessionCoins: D,
              coinsThisGame: pt,
            });
          } catch (At) {
            N && (Yp(At), P('Failed to save game state. Your progress may not be saved.'));
          }
        };
        return (
          (Q = window.setTimeout(gt, 1e3)),
          () => {
            (N = !1), window.clearTimeout(Q);
          }
        );
      }, [_, x, h, T, A, s, e, D, pt]),
      ot.useEffect(() => {
        a.length > 0 && bt();
      }, [a, bt]),
      ot.useEffect(() => {
        if (Object.values(_).every((N) => N === 'green')) {
          E(!0);
          const N = Math.round(pt * xw);
          V(N), W(pt), Ty(N);
        }
      }, [_, pt]);
    const X = () => {
        R(!0);
      },
      it = async () => {
        try {
          await DS(e),
            g(Object.fromEntries(a.map((N) => [N.name, 'unanswered']))),
            S(Object.fromEntries(a.map((N) => [N.name, 0]))),
            f(0),
            M(0),
            R(!1),
            W(0),
            Mt(0),
            bt();
        } catch (N) {
          Yp(N), P('Failed to reset game. Please try again.');
        }
      },
      K = (N) => {
        let Q = '#ea4335';
        return (
          N === 'green' && (Q = '#34a853'),
          N === 'blue' && (Q = '#4285f4'),
          V_.divIcon({
            className: 'custom-dot',
            html: `<div style="
        width: 12px;
        height: 12px;
        background-color: ${Q};
        border-radius: 50%;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      "></div>`,
            iconSize: [12, 12],
            iconAnchor: [6, 6],
          })
        );
      },
      zt = (N) => {
        if (!s || (N.name === s.name && _[N.name] === 'green')) return;
        if (N.name !== s.name) {
          I('Dit is niet de juiste stad.'),
            setTimeout(() => I(null), 1500),
            M((st) => st + 1),
            S((st) => ({ ...st, [s.name]: st[s.name] + 1 }));
          return;
        }
        const Q = Date.now(),
          gt = (Q - j) / 1e3;
        ft(Q);
        let At = 0;
        gt <= Qp
          ? (At = Wh)
          : gt < Dy && (At = Math.max(0, Math.round(Wh * (1 - (gt - Qp) / (Dy - Qp)))));
        let tt = Kp + At;
        tt > Kp + Wh && (tt = Kp + Wh),
          W((st) => st + tt),
          Mt((st) => st + tt),
          Ty(tt),
          g((st) => {
            const _t = { ...st };
            return (
              T === 0 ? ((_t[N.name] = 'green'), f((It) => It + 1)) : (_t[N.name] = 'blue'), _t
            );
          }),
          bt(),
          M(0),
          I(`Goed! Je hebt ${N.name} gevonden!`),
          setTimeout(() => {
            I(null);
          }, 1200);
      };
    return a.length === 0
      ? at.jsx(wy, {
          children: at.jsxs(Ly, {
            children: [
              'Geen steden gevonden voor dit pakket. ',
              at.jsx('br', {}),
              at.jsx(Ef, { onClick: t, children: 'Terug naar hoofdmenu' }),
            ],
          }),
        })
      : at.jsxs(wy, {
          children: [
            z &&
              at.jsxs(Ly, { children: [z, at.jsx(yw, { onClick: () => P(null), children: '×' })] }),
            at.jsxs($T, {
              children: [
                at.jsxs(tw, {
                  children: [
                    at.jsx(ew, { children: e.replace('pakket', 'Pakket ') }),
                    s &&
                      at.jsxs(nw, {
                        style: { display: 'flex', alignItems: 'center' },
                        children: [
                          'Vind: ',
                          s.name,
                          at.jsxs(Sw, {
                            children: [
                              at.jsx(JT, { style: { color: '#FFD700', marginRight: 4 } }),
                              D,
                            ],
                          }),
                        ],
                      }),
                  ],
                }),
                at.jsxs(iw, {
                  children: [
                    A && s && at.jsxs(hw, { children: ['Tip: ', s.continent] }),
                    at.jsx(Py, {
                      children: at.jsx(Ef, { onClick: X, disabled: A, children: 'Hint' }),
                    }),
                    at.jsxs(Ay, {
                      children: [
                        at.jsx(Cy, { children: 'Score' }),
                        at.jsxs(Ry, {
                          children: [Object.values(_).filter((N) => N === 'green').length, '/', m],
                        }),
                      ],
                    }),
                    at.jsxs(Ay, {
                      children: [
                        at.jsx(Cy, { children: 'Nog te vinden' }),
                        at.jsx(Ry, {
                          children: m - Object.values(_).filter((N) => N === 'green').length,
                        }),
                      ],
                    }),
                    at.jsx(Py, { children: at.jsx(aw, { onClick: it, children: 'Herstart' }) }),
                    at.jsx(Ef, { onClick: t, children: 'Terug' }),
                  ],
                }),
              ],
            }),
            at.jsxs(rw, {
              children: [
                F && at.jsx(sw, { type: F.startsWith('Goed!') ? 'success' : 'error', children: F }),
                at.jsxs(CS, {
                  ref: J,
                  center: s ? [s.lat, s.lng] : [20, 0],
                  zoom: s ? 15 : 2,
                  style: { height: '100%', width: '100%' },
                  zoomControl: !1,
                  doubleClickZoom: !1,
                  scrollWheelZoom: !1,
                  dragging: !1,
                  touchZoom: !1,
                  children: [
                    at.jsx(LS, {
                      url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                      attribution:
                        '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    }),
                    a.map((N) =>
                      at.jsx(
                        RS,
                        {
                          position: [N.lat, N.lng],
                          icon: K(_[N.name]),
                          eventHandlers: { click: () => zt(N) },
                        },
                        N.name,
                      ),
                    ),
                  ],
                }),
              ],
            }),
            b &&
              at.jsxs(at.Fragment, {
                children: [
                  at.jsx(uw, {}),
                  at.jsxs(ow, {
                    children: [
                      at.jsx(lw, { children: 'Super! Je hebt alle steden gevonden!' }),
                      at.jsxs(Mw, {
                        children: [
                          'Munten dit spel: ',
                          pt,
                          ' ',
                          at.jsx('br', {}),
                          'Bonus: +',
                          Z,
                          ' ',
                          at.jsx('br', {}),
                          at.jsxs('b', { children: ['Totaal: ', pt + Z] }),
                        ],
                      }),
                      at.jsx(fw, {
                        children: (() => {
                          const N = Object.entries(x)
                            .filter(([, Q]) => Q > 0)
                            .sort((Q, gt) => gt[1] - Q[1]);
                          return N.length === 0
                            ? at.jsx(dw, { children: 'Je hebt alle steden in één keer goed!' })
                            : at.jsxs(at.Fragment, {
                                children: [
                                  at.jsx(pw, { children: 'Moeilijkste steden deze ronde:' }),
                                  at.jsx(mw, {
                                    children: N.map(([Q, gt]) =>
                                      at.jsxs(
                                        _w,
                                        {
                                          children: [
                                            at.jsx(gw, { children: Q }),
                                            at.jsxs(vw, {
                                              children: [gt, ' fout', gt > 1 ? 'en' : ''],
                                            }),
                                          ],
                                        },
                                        Q,
                                      ),
                                    ),
                                  }),
                                ],
                              });
                        })(),
                      }),
                      at.jsx(cw, {
                        onClick: async () => {
                          await it(), t();
                        },
                        children: 'Terug naar hoofdmenu',
                      }),
                    ],
                  }),
                ],
              }),
          ],
        });
  },
  Ew = jt.div`
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  background: linear-gradient(135deg, #f5f7fa 0%, #e4e8eb 100%);
  overflow: hidden;
`,
  Tw = jt.header`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 2rem;
  background: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  flex-shrink: 0;
  z-index: 1000;

  @media (max-width: 768px) {
    padding: 0.75rem 1rem;
    flex-direction: column;
    gap: 0.5rem;
    height: 80px;
  }
`,
  ww = jt.div`
  flex: 1;
  position: relative;
  overflow: hidden;
  min-height: 0;
  height: calc(100vh - 80px);

  @media (max-width: 768px) {
    height: calc(100vh - 80px);
    position: fixed;
    top: 80px;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
  }
`,
  Aw = jt.h1`
  font-size: 1.5rem;
  color: #1a73e8;
  margin: 0;

  @media (max-width: 768px) {
    font-size: 1.2rem;
    text-align: center;
  }
`,
  Cw = jt.button`
  padding: 0.5rem 1rem;
  background: #1a73e8;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s;

  &:hover {
    background: #1557b0;
  }

  @media (max-width: 768px) {
    padding: 0.4rem 0.8rem;
    font-size: 0.9rem;
  }
`,
  Rw = jt.div`
  height: 100%;
  width: 100%;
`,
  Lw = () =>
    new ql.Icon({
      iconUrl:
        'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iNiIgZmlsbD0iI2VhNDMzNSIvPjwvc3ZnPg==',
      iconSize: [12, 12],
      iconAnchor: [6, 6],
    }),
  Pw = jt.div`
  text-align: center;
  padding: 0.5rem;

  @media (max-width: 768px) {
    padding: 0.75rem;
  }
`,
  Dw = jt.h3`
  margin: 0 0 0.25rem 0;
  color: #202124;
  font-size: 1rem;

  @media (max-width: 768px) {
    font-size: 1.1rem;
  }
`,
  Ow = jt.p`
  margin: 0;
  color: #5f6368;
  font-size: 0.875rem;

  @media (max-width: 768px) {
    font-size: 1rem;
  }
`,
  Uw = ({ cities: a, onBack: t, selectedPackage: e }) => {
    const s = Lw();
    return at.jsxs(Ew, {
      children: [
        at.jsxs(Tw, {
          children: [
            at.jsx(Cw, { onClick: t, children: 'Terug' }),
            at.jsxs(Aw, { children: ['Interactieve Kaart ', e.replace('interactive', '')] }),
          ],
        }),
        at.jsx(ww, {
          children: at.jsx(Rw, {
            children: at.jsxs(CS, {
              center: [20, 0],
              zoom: 2,
              zoomControl: !1,
              doubleClickZoom: !1,
              scrollWheelZoom: !1,
              dragging: !1,
              touchZoom: !1,
              children: [
                at.jsx(LS, {
                  url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                  attribution:
                    '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                }),
                a.map((l) =>
                  at.jsx(
                    RS,
                    {
                      position: [l.lat, l.lng],
                      icon: s,
                      children: at.jsx(IT, {
                        children: at.jsxs(Pw, {
                          children: [
                            at.jsx(Dw, { children: l.name }),
                            at.jsx(Ow, { children: l.country }),
                          ],
                        }),
                      }),
                    },
                    l.name,
                  ),
                ),
              ],
            }),
          }),
        }),
      ],
    });
  };
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const q_ = '176',
  Nl = { ROTATE: 0, DOLLY: 1, PAN: 2 },
  Rl = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  Nw = 0,
  Oy = 1,
  zw = 2,
  BS = 1,
  Iw = 2,
  Pr = 3,
  Ns = 0,
  Ni = 1,
  Dr = 2,
  Os = 0,
  zl = 1,
  Bm = 2,
  Uy = 3,
  Ny = 4,
  Bw = 5,
  yo = 100,
  kw = 101,
  Fw = 102,
  Hw = 103,
  Gw = 104,
  Vw = 200,
  Ww = 201,
  Zw = 202,
  Xw = 203,
  km = 204,
  Fm = 205,
  jw = 206,
  qw = 207,
  Yw = 208,
  Kw = 209,
  Qw = 210,
  Jw = 211,
  $w = 212,
  tA = 213,
  eA = 214,
  Hm = 0,
  Gm = 1,
  Vm = 2,
  kl = 3,
  Wm = 4,
  Zm = 5,
  Xm = 6,
  jm = 7,
  Y_ = 0,
  nA = 1,
  iA = 2,
  Us = 0,
  aA = 1,
  rA = 2,
  sA = 3,
  oA = 4,
  lA = 5,
  cA = 6,
  uA = 7,
  kS = 300,
  Fl = 301,
  Hl = 302,
  qm = 303,
  Ym = 304,
  Xf = 306,
  Km = 1e3,
  So = 1001,
  Qm = 1002,
  Da = 1003,
  hA = 1004,
  Zh = 1005,
  ja = 1006,
  Jp = 1007,
  Mo = 1008,
  Ka = 1009,
  FS = 1010,
  HS = 1011,
  du = 1012,
  K_ = 1013,
  bo = 1014,
  Or = 1015,
  Tu = 1016,
  Q_ = 1017,
  J_ = 1018,
  pu = 1020,
  GS = 35902,
  VS = 1021,
  WS = 1022,
  Pa = 1023,
  mu = 1026,
  _u = 1027,
  ZS = 1028,
  $_ = 1029,
  XS = 1030,
  tg = 1031,
  eg = 1033,
  Tf = 33776,
  wf = 33777,
  Af = 33778,
  Cf = 33779,
  Jm = 35840,
  $m = 35841,
  t_ = 35842,
  e_ = 35843,
  n_ = 36196,
  i_ = 37492,
  a_ = 37496,
  r_ = 37808,
  s_ = 37809,
  o_ = 37810,
  l_ = 37811,
  c_ = 37812,
  u_ = 37813,
  h_ = 37814,
  f_ = 37815,
  d_ = 37816,
  p_ = 37817,
  m_ = 37818,
  __ = 37819,
  g_ = 37820,
  v_ = 37821,
  Rf = 36492,
  y_ = 36494,
  x_ = 36495,
  jS = 36283,
  S_ = 36284,
  M_ = 36285,
  b_ = 36286,
  fA = 3200,
  dA = 3201,
  qS = 0,
  pA = 1,
  Ds = '',
  fa = 'srgb',
  Gl = 'srgb-linear',
  If = 'linear',
  dn = 'srgb',
  pl = 7680,
  zy = 519,
  mA = 512,
  _A = 513,
  gA = 514,
  YS = 515,
  vA = 516,
  yA = 517,
  xA = 518,
  SA = 519,
  Iy = 35044,
  By = '300 es',
  Ur = 2e3,
  Bf = 2001;
class Co {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const s = this._listeners;
    s[t] === void 0 && (s[t] = []), s[t].indexOf(e) === -1 && s[t].push(e);
  }
  hasEventListener(t, e) {
    const s = this._listeners;
    return s === void 0 ? !1 : s[t] !== void 0 && s[t].indexOf(e) !== -1;
  }
  removeEventListener(t, e) {
    const s = this._listeners;
    if (s === void 0) return;
    const l = s[t];
    if (l !== void 0) {
      const h = l.indexOf(e);
      h !== -1 && l.splice(h, 1);
    }
  }
  dispatchEvent(t) {
    const e = this._listeners;
    if (e === void 0) return;
    const s = e[t.type];
    if (s !== void 0) {
      t.target = this;
      const l = s.slice(0);
      for (let h = 0, f = l.length; h < f; h++) l[h].call(this, t);
      t.target = null;
    }
  }
}
const mi = [
    '00',
    '01',
    '02',
    '03',
    '04',
    '05',
    '06',
    '07',
    '08',
    '09',
    '0a',
    '0b',
    '0c',
    '0d',
    '0e',
    '0f',
    '10',
    '11',
    '12',
    '13',
    '14',
    '15',
    '16',
    '17',
    '18',
    '19',
    '1a',
    '1b',
    '1c',
    '1d',
    '1e',
    '1f',
    '20',
    '21',
    '22',
    '23',
    '24',
    '25',
    '26',
    '27',
    '28',
    '29',
    '2a',
    '2b',
    '2c',
    '2d',
    '2e',
    '2f',
    '30',
    '31',
    '32',
    '33',
    '34',
    '35',
    '36',
    '37',
    '38',
    '39',
    '3a',
    '3b',
    '3c',
    '3d',
    '3e',
    '3f',
    '40',
    '41',
    '42',
    '43',
    '44',
    '45',
    '46',
    '47',
    '48',
    '49',
    '4a',
    '4b',
    '4c',
    '4d',
    '4e',
    '4f',
    '50',
    '51',
    '52',
    '53',
    '54',
    '55',
    '56',
    '57',
    '58',
    '59',
    '5a',
    '5b',
    '5c',
    '5d',
    '5e',
    '5f',
    '60',
    '61',
    '62',
    '63',
    '64',
    '65',
    '66',
    '67',
    '68',
    '69',
    '6a',
    '6b',
    '6c',
    '6d',
    '6e',
    '6f',
    '70',
    '71',
    '72',
    '73',
    '74',
    '75',
    '76',
    '77',
    '78',
    '79',
    '7a',
    '7b',
    '7c',
    '7d',
    '7e',
    '7f',
    '80',
    '81',
    '82',
    '83',
    '84',
    '85',
    '86',
    '87',
    '88',
    '89',
    '8a',
    '8b',
    '8c',
    '8d',
    '8e',
    '8f',
    '90',
    '91',
    '92',
    '93',
    '94',
    '95',
    '96',
    '97',
    '98',
    '99',
    '9a',
    '9b',
    '9c',
    '9d',
    '9e',
    '9f',
    'a0',
    'a1',
    'a2',
    'a3',
    'a4',
    'a5',
    'a6',
    'a7',
    'a8',
    'a9',
    'aa',
    'ab',
    'ac',
    'ad',
    'ae',
    'af',
    'b0',
    'b1',
    'b2',
    'b3',
    'b4',
    'b5',
    'b6',
    'b7',
    'b8',
    'b9',
    'ba',
    'bb',
    'bc',
    'bd',
    'be',
    'bf',
    'c0',
    'c1',
    'c2',
    'c3',
    'c4',
    'c5',
    'c6',
    'c7',
    'c8',
    'c9',
    'ca',
    'cb',
    'cc',
    'cd',
    'ce',
    'cf',
    'd0',
    'd1',
    'd2',
    'd3',
    'd4',
    'd5',
    'd6',
    'd7',
    'd8',
    'd9',
    'da',
    'db',
    'dc',
    'dd',
    'de',
    'df',
    'e0',
    'e1',
    'e2',
    'e3',
    'e4',
    'e5',
    'e6',
    'e7',
    'e8',
    'e9',
    'ea',
    'eb',
    'ec',
    'ed',
    'ee',
    'ef',
    'f0',
    'f1',
    'f2',
    'f3',
    'f4',
    'f5',
    'f6',
    'f7',
    'f8',
    'f9',
    'fa',
    'fb',
    'fc',
    'fd',
    'fe',
    'ff',
  ],
  Lf = Math.PI / 180,
  E_ = 180 / Math.PI;
function Yl() {
  const a = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    s = (Math.random() * 4294967295) | 0;
  return (
    mi[a & 255] +
    mi[(a >> 8) & 255] +
    mi[(a >> 16) & 255] +
    mi[(a >> 24) & 255] +
    '-' +
    mi[t & 255] +
    mi[(t >> 8) & 255] +
    '-' +
    mi[((t >> 16) & 15) | 64] +
    mi[(t >> 24) & 255] +
    '-' +
    mi[(e & 63) | 128] +
    mi[(e >> 8) & 255] +
    '-' +
    mi[(e >> 16) & 255] +
    mi[(e >> 24) & 255] +
    mi[s & 255] +
    mi[(s >> 8) & 255] +
    mi[(s >> 16) & 255] +
    mi[(s >> 24) & 255]
  ).toLowerCase();
}
function Ve(a, t, e) {
  return Math.max(t, Math.min(e, a));
}
function MA(a, t) {
  return ((a % t) + t) % t;
}
function $p(a, t, e) {
  return (1 - e) * a + e * t;
}
function Jc(a, t) {
  switch (t.constructor) {
    case Float32Array:
      return a;
    case Uint32Array:
      return a / 4294967295;
    case Uint16Array:
      return a / 65535;
    case Uint8Array:
      return a / 255;
    case Int32Array:
      return Math.max(a / 2147483647, -1);
    case Int16Array:
      return Math.max(a / 32767, -1);
    case Int8Array:
      return Math.max(a / 127, -1);
    default:
      throw new Error('Invalid component type.');
  }
}
function Oi(a, t) {
  switch (t.constructor) {
    case Float32Array:
      return a;
    case Uint32Array:
      return Math.round(a * 4294967295);
    case Uint16Array:
      return Math.round(a * 65535);
    case Uint8Array:
      return Math.round(a * 255);
    case Int32Array:
      return Math.round(a * 2147483647);
    case Int16Array:
      return Math.round(a * 32767);
    case Int8Array:
      return Math.round(a * 127);
    default:
      throw new Error('Invalid component type.');
  }
}
const bA = { DEG2RAD: Lf };
class Yt {
  constructor(t = 0, e = 0) {
    (Yt.prototype.isVector2 = !0), (this.x = t), (this.y = e);
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return (this.x = t), (this.y = e), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error('index is out of range: ' + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error('index is out of range: ' + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), this;
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), this;
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), this;
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), this;
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), this;
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), this;
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), this;
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x,
      s = this.y,
      l = t.elements;
    return (this.x = l[0] * e + l[3] * s + l[6]), (this.y = l[1] * e + l[4] * s + l[7]), this;
  }
  min(t) {
    return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this;
  }
  max(t) {
    return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this;
  }
  clamp(t, e) {
    return (this.x = Ve(this.x, t.x, e.x)), (this.y = Ve(this.y, t.y, e.y)), this;
  }
  clampScalar(t, e) {
    return (this.x = Ve(this.x, t, e)), (this.y = Ve(this.y, t, e)), this;
  }
  clampLength(t, e) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(Ve(s, t, e));
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    const s = this.dot(t) / e;
    return Math.acos(Ve(s, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      s = this.y - t.y;
    return e * e + s * s;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
  }
  lerpVectors(t, e, s) {
    return (this.x = t.x + (e.x - t.x) * s), (this.y = t.y + (e.y - t.y) * s), this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), t;
  }
  fromBufferAttribute(t, e) {
    return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
  }
  rotateAround(t, e) {
    const s = Math.cos(e),
      l = Math.sin(e),
      h = this.x - t.x,
      f = this.y - t.y;
    return (this.x = h * s - f * l + t.x), (this.y = h * l + f * s + t.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Be {
  constructor(t, e, s, l, h, f, m, _, g) {
    (Be.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      t !== void 0 && this.set(t, e, s, l, h, f, m, _, g);
  }
  set(t, e, s, l, h, f, m, _, g) {
    const x = this.elements;
    return (
      (x[0] = t),
      (x[1] = l),
      (x[2] = m),
      (x[3] = e),
      (x[4] = h),
      (x[5] = _),
      (x[6] = s),
      (x[7] = f),
      (x[8] = g),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t) {
    const e = this.elements,
      s = t.elements;
    return (
      (e[0] = s[0]),
      (e[1] = s[1]),
      (e[2] = s[2]),
      (e[3] = s[3]),
      (e[4] = s[4]),
      (e[5] = s[5]),
      (e[6] = s[6]),
      (e[7] = s[7]),
      (e[8] = s[8]),
      this
    );
  }
  extractBasis(t, e, s) {
    return (
      t.setFromMatrix3Column(this, 0),
      e.setFromMatrix3Column(this, 1),
      s.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const s = t.elements,
      l = e.elements,
      h = this.elements,
      f = s[0],
      m = s[3],
      _ = s[6],
      g = s[1],
      x = s[4],
      S = s[7],
      b = s[2],
      E = s[5],
      A = s[8],
      R = l[0],
      T = l[3],
      M = l[6],
      z = l[1],
      P = l[4],
      D = l[7],
      W = l[2],
      Z = l[5],
      V = l[8];
    return (
      (h[0] = f * R + m * z + _ * W),
      (h[3] = f * T + m * P + _ * Z),
      (h[6] = f * M + m * D + _ * V),
      (h[1] = g * R + x * z + S * W),
      (h[4] = g * T + x * P + S * Z),
      (h[7] = g * M + x * D + S * V),
      (h[2] = b * R + E * z + A * W),
      (h[5] = b * T + E * P + A * Z),
      (h[8] = b * M + E * D + A * V),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[3] *= t),
      (e[6] *= t),
      (e[1] *= t),
      (e[4] *= t),
      (e[7] *= t),
      (e[2] *= t),
      (e[5] *= t),
      (e[8] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      s = t[1],
      l = t[2],
      h = t[3],
      f = t[4],
      m = t[5],
      _ = t[6],
      g = t[7],
      x = t[8];
    return e * f * x - e * m * g - s * h * x + s * m * _ + l * h * g - l * f * _;
  }
  invert() {
    const t = this.elements,
      e = t[0],
      s = t[1],
      l = t[2],
      h = t[3],
      f = t[4],
      m = t[5],
      _ = t[6],
      g = t[7],
      x = t[8],
      S = x * f - m * g,
      b = m * _ - x * h,
      E = g * h - f * _,
      A = e * S + s * b + l * E;
    if (A === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const R = 1 / A;
    return (
      (t[0] = S * R),
      (t[1] = (l * g - x * s) * R),
      (t[2] = (m * s - l * f) * R),
      (t[3] = b * R),
      (t[4] = (x * e - l * _) * R),
      (t[5] = (l * h - m * e) * R),
      (t[6] = E * R),
      (t[7] = (s * _ - g * e) * R),
      (t[8] = (f * e - s * h) * R),
      this
    );
  }
  transpose() {
    let t;
    const e = this.elements;
    return (
      (t = e[1]),
      (e[1] = e[3]),
      (e[3] = t),
      (t = e[2]),
      (e[2] = e[6]),
      (e[6] = t),
      (t = e[5]),
      (e[5] = e[7]),
      (e[7] = t),
      this
    );
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return (
      (t[0] = e[0]),
      (t[1] = e[3]),
      (t[2] = e[6]),
      (t[3] = e[1]),
      (t[4] = e[4]),
      (t[5] = e[7]),
      (t[6] = e[2]),
      (t[7] = e[5]),
      (t[8] = e[8]),
      this
    );
  }
  setUvTransform(t, e, s, l, h, f, m) {
    const _ = Math.cos(h),
      g = Math.sin(h);
    return (
      this.set(
        s * _,
        s * g,
        -s * (_ * f + g * m) + f + t,
        -l * g,
        l * _,
        -l * (-g * f + _ * m) + m + e,
        0,
        0,
        1,
      ),
      this
    );
  }
  scale(t, e) {
    return this.premultiply(tm.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(tm.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(tm.makeTranslation(t, e)), this;
  }
  makeTranslation(t, e) {
    return (
      t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
      this
    );
  }
  makeRotation(t) {
    const e = Math.cos(t),
      s = Math.sin(t);
    return this.set(e, -s, 0, s, e, 0, 0, 0, 1), this;
  }
  makeScale(t, e) {
    return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
  }
  equals(t) {
    const e = this.elements,
      s = t.elements;
    for (let l = 0; l < 9; l++) if (e[l] !== s[l]) return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let s = 0; s < 9; s++) this.elements[s] = t[s + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const s = this.elements;
    return (
      (t[e] = s[0]),
      (t[e + 1] = s[1]),
      (t[e + 2] = s[2]),
      (t[e + 3] = s[3]),
      (t[e + 4] = s[4]),
      (t[e + 5] = s[5]),
      (t[e + 6] = s[6]),
      (t[e + 7] = s[7]),
      (t[e + 8] = s[8]),
      t
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const tm = new Be();
function KS(a) {
  for (let t = a.length - 1; t >= 0; --t) if (a[t] >= 65535) return !0;
  return !1;
}
function gu(a) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', a);
}
function EA() {
  const a = gu('canvas');
  return (a.style.display = 'block'), a;
}
const ky = {};
function Pf(a) {
  a in ky || ((ky[a] = !0), console.warn(a));
}
function TA(a, t, e) {
  return new Promise(function (s, l) {
    function h() {
      switch (a.clientWaitSync(t, a.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case a.WAIT_FAILED:
          l();
          break;
        case a.TIMEOUT_EXPIRED:
          setTimeout(h, e);
          break;
        default:
          s();
      }
    }
    setTimeout(h, e);
  });
}
function wA(a) {
  const t = a.elements;
  (t[2] = 0.5 * t[2] + 0.5 * t[3]),
    (t[6] = 0.5 * t[6] + 0.5 * t[7]),
    (t[10] = 0.5 * t[10] + 0.5 * t[11]),
    (t[14] = 0.5 * t[14] + 0.5 * t[15]);
}
function AA(a) {
  const t = a.elements;
  t[11] === -1
    ? ((t[10] = -t[10] - 1), (t[14] = -t[14]))
    : ((t[10] = -t[10]), (t[14] = -t[14] + 1));
}
const Fy = new Be().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322,
  ),
  Hy = new Be().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715,
  );
function CA() {
  const a = {
      enabled: !0,
      workingColorSpace: Gl,
      spaces: {},
      convert: function (l, h, f) {
        return (
          this.enabled === !1 ||
            h === f ||
            !h ||
            !f ||
            (this.spaces[h].transfer === dn && ((l.r = Ir(l.r)), (l.g = Ir(l.g)), (l.b = Ir(l.b))),
            this.spaces[h].primaries !== this.spaces[f].primaries &&
              (l.applyMatrix3(this.spaces[h].toXYZ), l.applyMatrix3(this.spaces[f].fromXYZ)),
            this.spaces[f].transfer === dn && ((l.r = Il(l.r)), (l.g = Il(l.g)), (l.b = Il(l.b)))),
          l
        );
      },
      fromWorkingColorSpace: function (l, h) {
        return this.convert(l, this.workingColorSpace, h);
      },
      toWorkingColorSpace: function (l, h) {
        return this.convert(l, h, this.workingColorSpace);
      },
      getPrimaries: function (l) {
        return this.spaces[l].primaries;
      },
      getTransfer: function (l) {
        return l === Ds ? If : this.spaces[l].transfer;
      },
      getLuminanceCoefficients: function (l, h = this.workingColorSpace) {
        return l.fromArray(this.spaces[h].luminanceCoefficients);
      },
      define: function (l) {
        Object.assign(this.spaces, l);
      },
      _getMatrix: function (l, h, f) {
        return l.copy(this.spaces[h].toXYZ).multiply(this.spaces[f].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (l) {
        return this.spaces[l].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (l = this.workingColorSpace) {
        return this.spaces[l].workingColorSpaceConfig.unpackColorSpace;
      },
    },
    t = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    e = [0.2126, 0.7152, 0.0722],
    s = [0.3127, 0.329];
  return (
    a.define({
      [Gl]: {
        primaries: t,
        whitePoint: s,
        transfer: If,
        toXYZ: Fy,
        fromXYZ: Hy,
        luminanceCoefficients: e,
        workingColorSpaceConfig: { unpackColorSpace: fa },
        outputColorSpaceConfig: { drawingBufferColorSpace: fa },
      },
      [fa]: {
        primaries: t,
        whitePoint: s,
        transfer: dn,
        toXYZ: Fy,
        fromXYZ: Hy,
        luminanceCoefficients: e,
        outputColorSpaceConfig: { drawingBufferColorSpace: fa },
      },
    }),
    a
  );
}
const en = CA();
function Ir(a) {
  return a < 0.04045 ? a * 0.0773993808 : Math.pow(a * 0.9478672986 + 0.0521327014, 2.4);
}
function Il(a) {
  return a < 0.0031308 ? a * 12.92 : 1.055 * Math.pow(a, 0.41666) - 0.055;
}
let ml;
class RA {
  static getDataURL(t, e = 'image/png') {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > 'u') return t.src;
    let s;
    if (t instanceof HTMLCanvasElement) s = t;
    else {
      ml === void 0 && (ml = gu('canvas')), (ml.width = t.width), (ml.height = t.height);
      const l = ml.getContext('2d');
      t instanceof ImageData ? l.putImageData(t, 0, 0) : l.drawImage(t, 0, 0, t.width, t.height),
        (s = ml);
    }
    return s.toDataURL(e);
  }
  static sRGBToLinear(t) {
    if (
      (typeof HTMLImageElement < 'u' && t instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < 'u' && t instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < 'u' && t instanceof ImageBitmap)
    ) {
      const e = gu('canvas');
      (e.width = t.width), (e.height = t.height);
      const s = e.getContext('2d');
      s.drawImage(t, 0, 0, t.width, t.height);
      const l = s.getImageData(0, 0, t.width, t.height),
        h = l.data;
      for (let f = 0; f < h.length; f++) h[f] = Ir(h[f] / 255) * 255;
      return s.putImageData(l, 0, 0), e;
    } else if (t.data) {
      const e = t.data.slice(0);
      for (let s = 0; s < e.length; s++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray
          ? (e[s] = Math.floor(Ir(e[s] / 255) * 255))
          : (e[s] = Ir(e[s]));
      return { data: e, width: t.width, height: t.height };
    } else
      return (
        console.warn(
          'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.',
        ),
        t
      );
  }
}
let LA = 0;
class ng {
  constructor(t = null) {
    (this.isSource = !0),
      Object.defineProperty(this, 'id', { value: LA++ }),
      (this.uuid = Yl()),
      (this.data = t),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == 'string';
    if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
    const s = { uuid: this.uuid, url: '' },
      l = this.data;
    if (l !== null) {
      let h;
      if (Array.isArray(l)) {
        h = [];
        for (let f = 0, m = l.length; f < m; f++)
          l[f].isDataTexture ? h.push(em(l[f].image)) : h.push(em(l[f]));
      } else h = em(l);
      s.url = h;
    }
    return e || (t.images[this.uuid] = s), s;
  }
}
function em(a) {
  return (typeof HTMLImageElement < 'u' && a instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < 'u' && a instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < 'u' && a instanceof ImageBitmap)
    ? RA.getDataURL(a)
    : a.data
      ? {
          data: Array.from(a.data),
          width: a.width,
          height: a.height,
          type: a.data.constructor.name,
        }
      : (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
}
let PA = 0;
class Ai extends Co {
  constructor(
    t = Ai.DEFAULT_IMAGE,
    e = Ai.DEFAULT_MAPPING,
    s = So,
    l = So,
    h = ja,
    f = Mo,
    m = Pa,
    _ = Ka,
    g = Ai.DEFAULT_ANISOTROPY,
    x = Ds,
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, 'id', { value: PA++ }),
      (this.uuid = Yl()),
      (this.name = ''),
      (this.source = new ng(t)),
      (this.mipmaps = []),
      (this.mapping = e),
      (this.channel = 0),
      (this.wrapS = s),
      (this.wrapT = l),
      (this.magFilter = h),
      (this.minFilter = f),
      (this.anisotropy = g),
      (this.format = m),
      (this.internalFormat = null),
      (this.type = _),
      (this.offset = new Yt(0, 0)),
      (this.repeat = new Yt(1, 1)),
      (this.center = new Yt(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Be()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = x),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.isTextureArray = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(t = null) {
    this.source.data = t;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.source = t.source),
      (this.mipmaps = t.mipmaps.slice(0)),
      (this.mapping = t.mapping),
      (this.channel = t.channel),
      (this.wrapS = t.wrapS),
      (this.wrapT = t.wrapT),
      (this.magFilter = t.magFilter),
      (this.minFilter = t.minFilter),
      (this.anisotropy = t.anisotropy),
      (this.format = t.format),
      (this.internalFormat = t.internalFormat),
      (this.type = t.type),
      this.offset.copy(t.offset),
      this.repeat.copy(t.repeat),
      this.center.copy(t.center),
      (this.rotation = t.rotation),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this.matrix.copy(t.matrix),
      (this.generateMipmaps = t.generateMipmaps),
      (this.premultiplyAlpha = t.premultiplyAlpha),
      (this.flipY = t.flipY),
      (this.unpackAlignment = t.unpackAlignment),
      (this.colorSpace = t.colorSpace),
      (this.renderTarget = t.renderTarget),
      (this.isRenderTargetTexture = t.isRenderTargetTexture),
      (this.isTextureArray = t.isTextureArray),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == 'string';
    if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
    const s = {
      metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (s.userData = this.userData),
      e || (t.textures[this.uuid] = s),
      s
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
  transformUv(t) {
    if (this.mapping !== kS) return t;
    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
      switch (this.wrapS) {
        case Km:
          t.x = t.x - Math.floor(t.x);
          break;
        case So:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case Qm:
          Math.abs(Math.floor(t.x) % 2) === 1
            ? (t.x = Math.ceil(t.x) - t.x)
            : (t.x = t.x - Math.floor(t.x));
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case Km:
          t.y = t.y - Math.floor(t.y);
          break;
        case So:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case Qm:
          Math.abs(Math.floor(t.y) % 2) === 1
            ? (t.y = Math.ceil(t.y) - t.y)
            : (t.y = t.y - Math.floor(t.y));
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(t) {
    t === !0 && this.pmremVersion++;
  }
}
Ai.DEFAULT_IMAGE = null;
Ai.DEFAULT_MAPPING = kS;
Ai.DEFAULT_ANISOTROPY = 1;
class Un {
  constructor(t = 0, e = 0, s = 0, l = 1) {
    (Un.prototype.isVector4 = !0), (this.x = t), (this.y = e), (this.z = s), (this.w = l);
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, s, l) {
    return (this.x = t), (this.y = e), (this.z = s), (this.w = l), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  setW(t) {
    return (this.w = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error('index is out of range: ' + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error('index is out of range: ' + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return (
      (this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = t.w !== void 0 ? t.w : 1), this
    );
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this;
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), (this.w = t.w + e.w), this
    );
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), (this.w += t.w * e), this;
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this;
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), (this.w = t.w - e.w), this
    );
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
  }
  applyMatrix4(t) {
    const e = this.x,
      s = this.y,
      l = this.z,
      h = this.w,
      f = t.elements;
    return (
      (this.x = f[0] * e + f[4] * s + f[8] * l + f[12] * h),
      (this.y = f[1] * e + f[5] * s + f[9] * l + f[13] * h),
      (this.z = f[2] * e + f[6] * s + f[10] * l + f[14] * h),
      (this.w = f[3] * e + f[7] * s + f[11] * l + f[15] * h),
      this
    );
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), (this.w /= t.w), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return (
      e < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, s, l, h;
    const _ = t.elements,
      g = _[0],
      x = _[4],
      S = _[8],
      b = _[1],
      E = _[5],
      A = _[9],
      R = _[2],
      T = _[6],
      M = _[10];
    if (Math.abs(x - b) < 0.01 && Math.abs(S - R) < 0.01 && Math.abs(A - T) < 0.01) {
      if (
        Math.abs(x + b) < 0.1 &&
        Math.abs(S + R) < 0.1 &&
        Math.abs(A + T) < 0.1 &&
        Math.abs(g + E + M - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const P = (g + 1) / 2,
        D = (E + 1) / 2,
        W = (M + 1) / 2,
        Z = (x + b) / 4,
        V = (S + R) / 4,
        J = (A + T) / 4;
      return (
        P > D && P > W
          ? P < 0.01
            ? ((s = 0), (l = 0.707106781), (h = 0.707106781))
            : ((s = Math.sqrt(P)), (l = Z / s), (h = V / s))
          : D > W
            ? D < 0.01
              ? ((s = 0.707106781), (l = 0), (h = 0.707106781))
              : ((l = Math.sqrt(D)), (s = Z / l), (h = J / l))
            : W < 0.01
              ? ((s = 0.707106781), (l = 0.707106781), (h = 0))
              : ((h = Math.sqrt(W)), (s = V / h), (l = J / h)),
        this.set(s, l, h, e),
        this
      );
    }
    let z = Math.sqrt((T - A) * (T - A) + (S - R) * (S - R) + (b - x) * (b - x));
    return (
      Math.abs(z) < 0.001 && (z = 1),
      (this.x = (T - A) / z),
      (this.y = (S - R) / z),
      (this.z = (b - x) / z),
      (this.w = Math.acos((g + E + M - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), (this.w = e[15]), this;
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      (this.w = Math.min(this.w, t.w)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      (this.w = Math.max(this.w, t.w)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Ve(this.x, t.x, e.x)),
      (this.y = Ve(this.y, t.y, e.y)),
      (this.z = Ve(this.z, t.z, e.z)),
      (this.w = Ve(this.w, t.w, e.w)),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Ve(this.x, t, e)),
      (this.y = Ve(this.y, t, e)),
      (this.z = Ve(this.z, t, e)),
      (this.w = Ve(this.w, t, e)),
      this
    );
  }
  clampLength(t, e) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(Ve(s, t, e));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      (this.w += (t.w - this.w) * e),
      this
    );
  }
  lerpVectors(t, e, s) {
    return (
      (this.x = t.x + (e.x - t.x) * s),
      (this.y = t.y + (e.y - t.y) * s),
      (this.z = t.z + (e.z - t.z) * s),
      (this.w = t.w + (e.w - t.w) * s),
      this
    );
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), (this.w = t[e + 3]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), (t[e + 3] = this.w), t;
  }
  fromBufferAttribute(t, e) {
    return (
      (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), (this.w = t.getW(e)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class DA extends Co {
  constructor(t = 1, e = 1, s = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = t),
      (this.height = e),
      (this.depth = s.depth ? s.depth : 1),
      (this.scissor = new Un(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new Un(0, 0, t, e));
    const l = { width: t, height: e, depth: this.depth };
    s = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: ja,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
        multiview: !1,
      },
      s,
    );
    const h = new Ai(
      l,
      s.mapping,
      s.wrapS,
      s.wrapT,
      s.magFilter,
      s.minFilter,
      s.format,
      s.type,
      s.anisotropy,
      s.colorSpace,
    );
    (h.flipY = !1),
      (h.generateMipmaps = s.generateMipmaps),
      (h.internalFormat = s.internalFormat),
      (this.textures = []);
    const f = s.count;
    for (let m = 0; m < f; m++)
      (this.textures[m] = h.clone()),
        (this.textures[m].isRenderTargetTexture = !0),
        (this.textures[m].renderTarget = this);
    (this.depthBuffer = s.depthBuffer),
      (this.stencilBuffer = s.stencilBuffer),
      (this.resolveDepthBuffer = s.resolveDepthBuffer),
      (this.resolveStencilBuffer = s.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = s.depthTexture),
      (this.samples = s.samples),
      (this.multiview = s.multiview);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(t) {
    this.textures[0] = t;
  }
  set depthTexture(t) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      t !== null && (t.renderTarget = this),
      (this._depthTexture = t);
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(t, e, s = 1) {
    if (this.width !== t || this.height !== e || this.depth !== s) {
      (this.width = t), (this.height = e), (this.depth = s);
      for (let l = 0, h = this.textures.length; l < h; l++)
        (this.textures[l].image.width = t),
          (this.textures[l].image.height = e),
          (this.textures[l].image.depth = s);
      this.dispose();
    }
    this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.width = t.width),
      (this.height = t.height),
      (this.depth = t.depth),
      this.scissor.copy(t.scissor),
      (this.scissorTest = t.scissorTest),
      this.viewport.copy(t.viewport),
      (this.textures.length = 0);
    for (let e = 0, s = t.textures.length; e < s; e++) {
      (this.textures[e] = t.textures[e].clone()),
        (this.textures[e].isRenderTargetTexture = !0),
        (this.textures[e].renderTarget = this);
      const l = Object.assign({}, t.textures[e].image);
      this.textures[e].source = new ng(l);
    }
    return (
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.resolveDepthBuffer = t.resolveDepthBuffer),
      (this.resolveStencilBuffer = t.resolveStencilBuffer),
      t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()),
      (this.samples = t.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
}
class Eo extends DA {
  constructor(t = 1, e = 1, s = {}) {
    super(t, e, s), (this.isWebGLRenderTarget = !0);
  }
}
class QS extends Ai {
  constructor(t = null, e = 1, s = 1, l = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: t, width: e, height: s, depth: l }),
      (this.magFilter = Da),
      (this.minFilter = Da),
      (this.wrapR = So),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(t) {
    this.layerUpdates.add(t);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class OA extends Ai {
  constructor(t = null, e = 1, s = 1, l = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: t, width: e, height: s, depth: l }),
      (this.magFilter = Da),
      (this.minFilter = Da),
      (this.wrapR = So),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class kr {
  constructor(t = 0, e = 0, s = 0, l = 1) {
    (this.isQuaternion = !0), (this._x = t), (this._y = e), (this._z = s), (this._w = l);
  }
  static slerpFlat(t, e, s, l, h, f, m) {
    let _ = s[l + 0],
      g = s[l + 1],
      x = s[l + 2],
      S = s[l + 3];
    const b = h[f + 0],
      E = h[f + 1],
      A = h[f + 2],
      R = h[f + 3];
    if (m === 0) {
      (t[e + 0] = _), (t[e + 1] = g), (t[e + 2] = x), (t[e + 3] = S);
      return;
    }
    if (m === 1) {
      (t[e + 0] = b), (t[e + 1] = E), (t[e + 2] = A), (t[e + 3] = R);
      return;
    }
    if (S !== R || _ !== b || g !== E || x !== A) {
      let T = 1 - m;
      const M = _ * b + g * E + x * A + S * R,
        z = M >= 0 ? 1 : -1,
        P = 1 - M * M;
      if (P > Number.EPSILON) {
        const W = Math.sqrt(P),
          Z = Math.atan2(W, M * z);
        (T = Math.sin(T * Z) / W), (m = Math.sin(m * Z) / W);
      }
      const D = m * z;
      if (
        ((_ = _ * T + b * D),
        (g = g * T + E * D),
        (x = x * T + A * D),
        (S = S * T + R * D),
        T === 1 - m)
      ) {
        const W = 1 / Math.sqrt(_ * _ + g * g + x * x + S * S);
        (_ *= W), (g *= W), (x *= W), (S *= W);
      }
    }
    (t[e] = _), (t[e + 1] = g), (t[e + 2] = x), (t[e + 3] = S);
  }
  static multiplyQuaternionsFlat(t, e, s, l, h, f) {
    const m = s[l],
      _ = s[l + 1],
      g = s[l + 2],
      x = s[l + 3],
      S = h[f],
      b = h[f + 1],
      E = h[f + 2],
      A = h[f + 3];
    return (
      (t[e] = m * A + x * S + _ * E - g * b),
      (t[e + 1] = _ * A + x * b + g * S - m * E),
      (t[e + 2] = g * A + x * E + m * b - _ * S),
      (t[e + 3] = x * A - m * S - _ * b - g * E),
      t
    );
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    (this._w = t), this._onChangeCallback();
  }
  set(t, e, s, l) {
    return (
      (this._x = t), (this._y = e), (this._z = s), (this._w = l), this._onChangeCallback(), this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return (
      (this._x = t.x),
      (this._y = t.y),
      (this._z = t.z),
      (this._w = t.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(t, e = !0) {
    const s = t._x,
      l = t._y,
      h = t._z,
      f = t._order,
      m = Math.cos,
      _ = Math.sin,
      g = m(s / 2),
      x = m(l / 2),
      S = m(h / 2),
      b = _(s / 2),
      E = _(l / 2),
      A = _(h / 2);
    switch (f) {
      case 'XYZ':
        (this._x = b * x * S + g * E * A),
          (this._y = g * E * S - b * x * A),
          (this._z = g * x * A + b * E * S),
          (this._w = g * x * S - b * E * A);
        break;
      case 'YXZ':
        (this._x = b * x * S + g * E * A),
          (this._y = g * E * S - b * x * A),
          (this._z = g * x * A - b * E * S),
          (this._w = g * x * S + b * E * A);
        break;
      case 'ZXY':
        (this._x = b * x * S - g * E * A),
          (this._y = g * E * S + b * x * A),
          (this._z = g * x * A + b * E * S),
          (this._w = g * x * S - b * E * A);
        break;
      case 'ZYX':
        (this._x = b * x * S - g * E * A),
          (this._y = g * E * S + b * x * A),
          (this._z = g * x * A - b * E * S),
          (this._w = g * x * S + b * E * A);
        break;
      case 'YZX':
        (this._x = b * x * S + g * E * A),
          (this._y = g * E * S + b * x * A),
          (this._z = g * x * A - b * E * S),
          (this._w = g * x * S - b * E * A);
        break;
      case 'XZY':
        (this._x = b * x * S - g * E * A),
          (this._y = g * E * S - b * x * A),
          (this._z = g * x * A + b * E * S),
          (this._w = g * x * S + b * E * A);
        break;
      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + f);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const s = e / 2,
      l = Math.sin(s);
    return (
      (this._x = t.x * l),
      (this._y = t.y * l),
      (this._z = t.z * l),
      (this._w = Math.cos(s)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t) {
    const e = t.elements,
      s = e[0],
      l = e[4],
      h = e[8],
      f = e[1],
      m = e[5],
      _ = e[9],
      g = e[2],
      x = e[6],
      S = e[10],
      b = s + m + S;
    if (b > 0) {
      const E = 0.5 / Math.sqrt(b + 1);
      (this._w = 0.25 / E),
        (this._x = (x - _) * E),
        (this._y = (h - g) * E),
        (this._z = (f - l) * E);
    } else if (s > m && s > S) {
      const E = 2 * Math.sqrt(1 + s - m - S);
      (this._w = (x - _) / E),
        (this._x = 0.25 * E),
        (this._y = (l + f) / E),
        (this._z = (h + g) / E);
    } else if (m > S) {
      const E = 2 * Math.sqrt(1 + m - s - S);
      (this._w = (h - g) / E),
        (this._x = (l + f) / E),
        (this._y = 0.25 * E),
        (this._z = (_ + x) / E);
    } else {
      const E = 2 * Math.sqrt(1 + S - s - m);
      (this._w = (f - l) / E),
        (this._x = (h + g) / E),
        (this._y = (_ + x) / E),
        (this._z = 0.25 * E);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let s = t.dot(e) + 1;
    return (
      s < Number.EPSILON
        ? ((s = 0),
          Math.abs(t.x) > Math.abs(t.z)
            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = s))
            : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = s)))
        : ((this._x = t.y * e.z - t.z * e.y),
          (this._y = t.z * e.x - t.x * e.z),
          (this._z = t.x * e.y - t.y * e.x),
          (this._w = s)),
      this.normalize()
    );
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(Ve(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const s = this.angleTo(t);
    if (s === 0) return this;
    const l = Math.min(1, e / s);
    return this.slerp(t, l), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return (
      t === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((t = 1 / t),
          (this._x = this._x * t),
          (this._y = this._y * t),
          (this._z = this._z * t),
          (this._w = this._w * t)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const s = t._x,
      l = t._y,
      h = t._z,
      f = t._w,
      m = e._x,
      _ = e._y,
      g = e._z,
      x = e._w;
    return (
      (this._x = s * x + f * m + l * g - h * _),
      (this._y = l * x + f * _ + h * m - s * g),
      (this._z = h * x + f * g + s * _ - l * m),
      (this._w = f * x - s * m - l * _ - h * g),
      this._onChangeCallback(),
      this
    );
  }
  slerp(t, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(t);
    const s = this._x,
      l = this._y,
      h = this._z,
      f = this._w;
    let m = f * t._w + s * t._x + l * t._y + h * t._z;
    if (
      (m < 0
        ? ((this._w = -t._w), (this._x = -t._x), (this._y = -t._y), (this._z = -t._z), (m = -m))
        : this.copy(t),
      m >= 1)
    )
      return (this._w = f), (this._x = s), (this._y = l), (this._z = h), this;
    const _ = 1 - m * m;
    if (_ <= Number.EPSILON) {
      const E = 1 - e;
      return (
        (this._w = E * f + e * this._w),
        (this._x = E * s + e * this._x),
        (this._y = E * l + e * this._y),
        (this._z = E * h + e * this._z),
        this.normalize(),
        this
      );
    }
    const g = Math.sqrt(_),
      x = Math.atan2(g, m),
      S = Math.sin((1 - e) * x) / g,
      b = Math.sin(e * x) / g;
    return (
      (this._w = f * S + this._w * b),
      (this._x = s * S + this._x * b),
      (this._y = l * S + this._y * b),
      (this._z = h * S + this._z * b),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(t, e, s) {
    return this.copy(t).slerp(e, s);
  }
  random() {
    const t = 2 * Math.PI * Math.random(),
      e = 2 * Math.PI * Math.random(),
      s = Math.random(),
      l = Math.sqrt(1 - s),
      h = Math.sqrt(s);
    return this.set(l * Math.sin(t), l * Math.cos(t), h * Math.sin(e), h * Math.cos(e));
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return (
      (this._x = t[e]),
      (this._y = t[e + 1]),
      (this._z = t[e + 2]),
      (this._w = t[e + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._w), t;
  }
  fromBufferAttribute(t, e) {
    return (
      (this._x = t.getX(e)),
      (this._y = t.getY(e)),
      (this._z = t.getZ(e)),
      (this._w = t.getW(e)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class et {
  constructor(t = 0, e = 0, s = 0) {
    (et.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = s);
  }
  set(t, e, s) {
    return s === void 0 && (s = this.z), (this.x = t), (this.y = e), (this.z = s), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error('index is out of range: ' + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error('index is out of range: ' + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), this;
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this;
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this;
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this;
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this;
  }
  multiplyVectors(t, e) {
    return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this;
  }
  applyEuler(t) {
    return this.applyQuaternion(Gy.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(Gy.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x,
      s = this.y,
      l = this.z,
      h = t.elements;
    return (
      (this.x = h[0] * e + h[3] * s + h[6] * l),
      (this.y = h[1] * e + h[4] * s + h[7] * l),
      (this.z = h[2] * e + h[5] * s + h[8] * l),
      this
    );
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x,
      s = this.y,
      l = this.z,
      h = t.elements,
      f = 1 / (h[3] * e + h[7] * s + h[11] * l + h[15]);
    return (
      (this.x = (h[0] * e + h[4] * s + h[8] * l + h[12]) * f),
      (this.y = (h[1] * e + h[5] * s + h[9] * l + h[13]) * f),
      (this.z = (h[2] * e + h[6] * s + h[10] * l + h[14]) * f),
      this
    );
  }
  applyQuaternion(t) {
    const e = this.x,
      s = this.y,
      l = this.z,
      h = t.x,
      f = t.y,
      m = t.z,
      _ = t.w,
      g = 2 * (f * l - m * s),
      x = 2 * (m * e - h * l),
      S = 2 * (h * s - f * e);
    return (
      (this.x = e + _ * g + f * S - m * x),
      (this.y = s + _ * x + m * g - h * S),
      (this.z = l + _ * S + h * x - f * g),
      this
    );
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  }
  transformDirection(t) {
    const e = this.x,
      s = this.y,
      l = this.z,
      h = t.elements;
    return (
      (this.x = h[0] * e + h[4] * s + h[8] * l),
      (this.y = h[1] * e + h[5] * s + h[9] * l),
      (this.z = h[2] * e + h[6] * s + h[10] * l),
      this.normalize()
    );
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Ve(this.x, t.x, e.x)),
      (this.y = Ve(this.y, t.y, e.y)),
      (this.z = Ve(this.z, t.z, e.z)),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Ve(this.x, t, e)), (this.y = Ve(this.y, t, e)), (this.z = Ve(this.z, t, e)), this
    );
  }
  clampLength(t, e) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(Ve(s, t, e));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      this
    );
  }
  lerpVectors(t, e, s) {
    return (
      (this.x = t.x + (e.x - t.x) * s),
      (this.y = t.y + (e.y - t.y) * s),
      (this.z = t.z + (e.z - t.z) * s),
      this
    );
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const s = t.x,
      l = t.y,
      h = t.z,
      f = e.x,
      m = e.y,
      _ = e.z;
    return (this.x = l * _ - h * m), (this.y = h * f - s * _), (this.z = s * m - l * f), this;
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0) return this.set(0, 0, 0);
    const s = t.dot(this) / e;
    return this.copy(t).multiplyScalar(s);
  }
  projectOnPlane(t) {
    return nm.copy(this).projectOnVector(t), this.sub(nm);
  }
  reflect(t) {
    return this.sub(nm.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    const s = this.dot(t) / e;
    return Math.acos(Ve(s, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      s = this.y - t.y,
      l = this.z - t.z;
    return e * e + s * s + l * l;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, s) {
    const l = Math.sin(e) * t;
    return (this.x = l * Math.sin(s)), (this.y = Math.cos(e) * t), (this.z = l * Math.cos(s)), this;
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, s) {
    return (this.x = t * Math.sin(e)), (this.y = s), (this.z = t * Math.cos(e)), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
      s = this.setFromMatrixColumn(t, 1).length(),
      l = this.setFromMatrixColumn(t, 2).length();
    return (this.x = e), (this.y = s), (this.z = l), this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
  }
  setFromColor(t) {
    return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
  }
  fromBufferAttribute(t, e) {
    return (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2,
      e = Math.random() * 2 - 1,
      s = Math.sqrt(1 - e * e);
    return (this.x = s * Math.cos(t)), (this.y = e), (this.z = s * Math.sin(t)), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const nm = new et(),
  Gy = new kr();
class wu {
  constructor(t = new et(1 / 0, 1 / 0, 1 / 0), e = new et(-1 / 0, -1 / 0, -1 / 0)) {
    (this.isBox3 = !0), (this.min = t), (this.max = e);
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    this.makeEmpty();
    for (let e = 0, s = t.length; e < s; e += 3) this.expandByPoint(Aa.fromArray(t, e));
    return this;
  }
  setFromBufferAttribute(t) {
    this.makeEmpty();
    for (let e = 0, s = t.count; e < s; e++) this.expandByPoint(Aa.fromBufferAttribute(t, e));
    return this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, s = t.length; e < s; e++) this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const s = Aa.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(s), this.max.copy(t).add(s), this;
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1);
    const s = t.geometry;
    if (s !== void 0) {
      const h = s.getAttribute('position');
      if (e === !0 && h !== void 0 && t.isInstancedMesh !== !0)
        for (let f = 0, m = h.count; f < m; f++)
          t.isMesh === !0 ? t.getVertexPosition(f, Aa) : Aa.fromBufferAttribute(h, f),
            Aa.applyMatrix4(t.matrixWorld),
            this.expandByPoint(Aa);
      else
        t.boundingBox !== void 0
          ? (t.boundingBox === null && t.computeBoundingBox(), Xh.copy(t.boundingBox))
          : (s.boundingBox === null && s.computeBoundingBox(), Xh.copy(s.boundingBox)),
          Xh.applyMatrix4(t.matrixWorld),
          this.union(Xh);
    }
    const l = t.children;
    for (let h = 0, f = l.length; h < f; h++) this.expandByObject(l[h], e);
    return this;
  }
  containsPoint(t) {
    return (
      t.x >= this.min.x &&
      t.x <= this.max.x &&
      t.y >= this.min.y &&
      t.y <= this.max.y &&
      t.z >= this.min.z &&
      t.z <= this.max.z
    );
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y &&
      this.min.z <= t.min.z &&
      t.max.z <= this.max.z
    );
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z),
    );
  }
  intersectsBox(t) {
    return (
      t.max.x >= this.min.x &&
      t.min.x <= this.max.x &&
      t.max.y >= this.min.y &&
      t.min.y <= this.max.y &&
      t.max.z >= this.min.z &&
      t.min.z <= this.max.z
    );
  }
  intersectsSphere(t) {
    return this.clampPoint(t.center, Aa), Aa.distanceToSquared(t.center) <= t.radius * t.radius;
  }
  intersectsPlane(t) {
    let e, s;
    return (
      t.normal.x > 0
        ? ((e = t.normal.x * this.min.x), (s = t.normal.x * this.max.x))
        : ((e = t.normal.x * this.max.x), (s = t.normal.x * this.min.x)),
      t.normal.y > 0
        ? ((e += t.normal.y * this.min.y), (s += t.normal.y * this.max.y))
        : ((e += t.normal.y * this.max.y), (s += t.normal.y * this.min.y)),
      t.normal.z > 0
        ? ((e += t.normal.z * this.min.z), (s += t.normal.z * this.max.z))
        : ((e += t.normal.z * this.max.z), (s += t.normal.z * this.min.z)),
      e <= -t.constant && s >= -t.constant
    );
  }
  intersectsTriangle(t) {
    if (this.isEmpty()) return !1;
    this.getCenter($c),
      jh.subVectors(this.max, $c),
      _l.subVectors(t.a, $c),
      gl.subVectors(t.b, $c),
      vl.subVectors(t.c, $c),
      Es.subVectors(gl, _l),
      Ts.subVectors(vl, gl),
      co.subVectors(_l, vl);
    let e = [
      0,
      -Es.z,
      Es.y,
      0,
      -Ts.z,
      Ts.y,
      0,
      -co.z,
      co.y,
      Es.z,
      0,
      -Es.x,
      Ts.z,
      0,
      -Ts.x,
      co.z,
      0,
      -co.x,
      -Es.y,
      Es.x,
      0,
      -Ts.y,
      Ts.x,
      0,
      -co.y,
      co.x,
      0,
    ];
    return !im(e, _l, gl, vl, jh) || ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !im(e, _l, gl, vl, jh))
      ? !1
      : (qh.crossVectors(Es, Ts), (e = [qh.x, qh.y, qh.z]), im(e, _l, gl, vl, jh));
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, Aa).distanceTo(t);
  }
  getBoundingSphere(t) {
    return (
      this.isEmpty()
        ? t.makeEmpty()
        : (this.getCenter(t.center), (t.radius = this.getSize(Aa).length() * 0.5)),
      t
    );
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty()
      ? this
      : (Tr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        Tr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        Tr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        Tr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        Tr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        Tr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        Tr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        Tr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(Tr),
        this);
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
const Tr = [new et(), new et(), new et(), new et(), new et(), new et(), new et(), new et()],
  Aa = new et(),
  Xh = new wu(),
  _l = new et(),
  gl = new et(),
  vl = new et(),
  Es = new et(),
  Ts = new et(),
  co = new et(),
  $c = new et(),
  jh = new et(),
  qh = new et(),
  uo = new et();
function im(a, t, e, s, l) {
  for (let h = 0, f = a.length - 3; h <= f; h += 3) {
    uo.fromArray(a, h);
    const m = l.x * Math.abs(uo.x) + l.y * Math.abs(uo.y) + l.z * Math.abs(uo.z),
      _ = t.dot(uo),
      g = e.dot(uo),
      x = s.dot(uo);
    if (Math.max(-Math.max(_, g, x), Math.min(_, g, x)) > m) return !1;
  }
  return !0;
}
const UA = new wu(),
  tu = new et(),
  am = new et();
class jf {
  constructor(t = new et(), e = -1) {
    (this.isSphere = !0), (this.center = t), (this.radius = e);
  }
  set(t, e) {
    return this.center.copy(t), (this.radius = e), this;
  }
  setFromPoints(t, e) {
    const s = this.center;
    e !== void 0 ? s.copy(e) : UA.setFromPoints(t).getCenter(s);
    let l = 0;
    for (let h = 0, f = t.length; h < f; h++) l = Math.max(l, s.distanceToSquared(t[h]));
    return (this.radius = Math.sqrt(l)), this;
  }
  copy(t) {
    return this.center.copy(t.center), (this.radius = t.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const s = this.center.distanceToSquared(t);
    return (
      e.copy(t),
      s > this.radius * this.radius &&
        (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)),
      e
    );
  }
  getBoundingBox(t) {
    return this.isEmpty()
      ? (t.makeEmpty(), t)
      : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this;
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this;
    tu.subVectors(t, this.center);
    const e = tu.lengthSq();
    if (e > this.radius * this.radius) {
      const s = Math.sqrt(e),
        l = (s - this.radius) * 0.5;
      this.center.addScaledVector(tu, l / s), (this.radius += l);
    }
    return this;
  }
  union(t) {
    return t.isEmpty()
      ? this
      : this.isEmpty()
        ? (this.copy(t), this)
        : (this.center.equals(t.center) === !0
            ? (this.radius = Math.max(this.radius, t.radius))
            : (am.subVectors(t.center, this.center).setLength(t.radius),
              this.expandByPoint(tu.copy(t.center).add(am)),
              this.expandByPoint(tu.copy(t.center).sub(am))),
          this);
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const wr = new et(),
  rm = new et(),
  Yh = new et(),
  ws = new et(),
  sm = new et(),
  Kh = new et(),
  om = new et();
class ig {
  constructor(t = new et(), e = new et(0, 0, -1)) {
    (this.origin = t), (this.direction = e);
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, wr)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    const s = e.dot(this.direction);
    return s < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, s);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = wr.subVectors(t, this.origin).dot(this.direction);
    return e < 0
      ? this.origin.distanceToSquared(t)
      : (wr.copy(this.origin).addScaledVector(this.direction, e), wr.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, s, l) {
    rm.copy(t).add(e).multiplyScalar(0.5),
      Yh.copy(e).sub(t).normalize(),
      ws.copy(this.origin).sub(rm);
    const h = t.distanceTo(e) * 0.5,
      f = -this.direction.dot(Yh),
      m = ws.dot(this.direction),
      _ = -ws.dot(Yh),
      g = ws.lengthSq(),
      x = Math.abs(1 - f * f);
    let S, b, E, A;
    if (x > 0)
      if (((S = f * _ - m), (b = f * m - _), (A = h * x), S >= 0))
        if (b >= -A)
          if (b <= A) {
            const R = 1 / x;
            (S *= R), (b *= R), (E = S * (S + f * b + 2 * m) + b * (f * S + b + 2 * _) + g);
          } else (b = h), (S = Math.max(0, -(f * b + m))), (E = -S * S + b * (b + 2 * _) + g);
        else (b = -h), (S = Math.max(0, -(f * b + m))), (E = -S * S + b * (b + 2 * _) + g);
      else
        b <= -A
          ? ((S = Math.max(0, -(-f * h + m))),
            (b = S > 0 ? -h : Math.min(Math.max(-h, -_), h)),
            (E = -S * S + b * (b + 2 * _) + g))
          : b <= A
            ? ((S = 0), (b = Math.min(Math.max(-h, -_), h)), (E = b * (b + 2 * _) + g))
            : ((S = Math.max(0, -(f * h + m))),
              (b = S > 0 ? h : Math.min(Math.max(-h, -_), h)),
              (E = -S * S + b * (b + 2 * _) + g));
    else (b = f > 0 ? -h : h), (S = Math.max(0, -(f * b + m))), (E = -S * S + b * (b + 2 * _) + g);
    return (
      s && s.copy(this.origin).addScaledVector(this.direction, S),
      l && l.copy(rm).addScaledVector(Yh, b),
      E
    );
  }
  intersectSphere(t, e) {
    wr.subVectors(t.center, this.origin);
    const s = wr.dot(this.direction),
      l = wr.dot(wr) - s * s,
      h = t.radius * t.radius;
    if (l > h) return null;
    const f = Math.sqrt(h - l),
      m = s - f,
      _ = s + f;
    return _ < 0 ? null : m < 0 ? this.at(_, e) : this.at(m, e);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const s = -(this.origin.dot(t.normal) + t.constant) / e;
    return s >= 0 ? s : null;
  }
  intersectPlane(t, e) {
    const s = this.distanceToPlane(t);
    return s === null ? null : this.at(s, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let s, l, h, f, m, _;
    const g = 1 / this.direction.x,
      x = 1 / this.direction.y,
      S = 1 / this.direction.z,
      b = this.origin;
    return (
      g >= 0
        ? ((s = (t.min.x - b.x) * g), (l = (t.max.x - b.x) * g))
        : ((s = (t.max.x - b.x) * g), (l = (t.min.x - b.x) * g)),
      x >= 0
        ? ((h = (t.min.y - b.y) * x), (f = (t.max.y - b.y) * x))
        : ((h = (t.max.y - b.y) * x), (f = (t.min.y - b.y) * x)),
      s > f ||
      h > l ||
      ((h > s || isNaN(s)) && (s = h),
      (f < l || isNaN(l)) && (l = f),
      S >= 0
        ? ((m = (t.min.z - b.z) * S), (_ = (t.max.z - b.z) * S))
        : ((m = (t.max.z - b.z) * S), (_ = (t.min.z - b.z) * S)),
      s > _ || m > l) ||
      ((m > s || s !== s) && (s = m), (_ < l || l !== l) && (l = _), l < 0)
        ? null
        : this.at(s >= 0 ? s : l, e)
    );
  }
  intersectsBox(t) {
    return this.intersectBox(t, wr) !== null;
  }
  intersectTriangle(t, e, s, l, h) {
    sm.subVectors(e, t), Kh.subVectors(s, t), om.crossVectors(sm, Kh);
    let f = this.direction.dot(om),
      m;
    if (f > 0) {
      if (l) return null;
      m = 1;
    } else if (f < 0) (m = -1), (f = -f);
    else return null;
    ws.subVectors(this.origin, t);
    const _ = m * this.direction.dot(Kh.crossVectors(ws, Kh));
    if (_ < 0) return null;
    const g = m * this.direction.dot(sm.cross(ws));
    if (g < 0 || _ + g > f) return null;
    const x = -m * ws.dot(om);
    return x < 0 ? null : this.at(x / f, h);
  }
  applyMatrix4(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class En {
  constructor(t, e, s, l, h, f, m, _, g, x, S, b, E, A, R, T) {
    (En.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      t !== void 0 && this.set(t, e, s, l, h, f, m, _, g, x, S, b, E, A, R, T);
  }
  set(t, e, s, l, h, f, m, _, g, x, S, b, E, A, R, T) {
    const M = this.elements;
    return (
      (M[0] = t),
      (M[4] = e),
      (M[8] = s),
      (M[12] = l),
      (M[1] = h),
      (M[5] = f),
      (M[9] = m),
      (M[13] = _),
      (M[2] = g),
      (M[6] = x),
      (M[10] = S),
      (M[14] = b),
      (M[3] = E),
      (M[7] = A),
      (M[11] = R),
      (M[15] = T),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new En().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements,
      s = t.elements;
    return (
      (e[0] = s[0]),
      (e[1] = s[1]),
      (e[2] = s[2]),
      (e[3] = s[3]),
      (e[4] = s[4]),
      (e[5] = s[5]),
      (e[6] = s[6]),
      (e[7] = s[7]),
      (e[8] = s[8]),
      (e[9] = s[9]),
      (e[10] = s[10]),
      (e[11] = s[11]),
      (e[12] = s[12]),
      (e[13] = s[13]),
      (e[14] = s[14]),
      (e[15] = s[15]),
      this
    );
  }
  copyPosition(t) {
    const e = this.elements,
      s = t.elements;
    return (e[12] = s[12]), (e[13] = s[13]), (e[14] = s[14]), this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return (
      this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
    );
  }
  extractBasis(t, e, s) {
    return (
      t.setFromMatrixColumn(this, 0),
      e.setFromMatrixColumn(this, 1),
      s.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(t, e, s) {
    return this.set(t.x, e.x, s.x, 0, t.y, e.y, s.y, 0, t.z, e.z, s.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(t) {
    const e = this.elements,
      s = t.elements,
      l = 1 / yl.setFromMatrixColumn(t, 0).length(),
      h = 1 / yl.setFromMatrixColumn(t, 1).length(),
      f = 1 / yl.setFromMatrixColumn(t, 2).length();
    return (
      (e[0] = s[0] * l),
      (e[1] = s[1] * l),
      (e[2] = s[2] * l),
      (e[3] = 0),
      (e[4] = s[4] * h),
      (e[5] = s[5] * h),
      (e[6] = s[6] * h),
      (e[7] = 0),
      (e[8] = s[8] * f),
      (e[9] = s[9] * f),
      (e[10] = s[10] * f),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  }
  makeRotationFromEuler(t) {
    const e = this.elements,
      s = t.x,
      l = t.y,
      h = t.z,
      f = Math.cos(s),
      m = Math.sin(s),
      _ = Math.cos(l),
      g = Math.sin(l),
      x = Math.cos(h),
      S = Math.sin(h);
    if (t.order === 'XYZ') {
      const b = f * x,
        E = f * S,
        A = m * x,
        R = m * S;
      (e[0] = _ * x),
        (e[4] = -_ * S),
        (e[8] = g),
        (e[1] = E + A * g),
        (e[5] = b - R * g),
        (e[9] = -m * _),
        (e[2] = R - b * g),
        (e[6] = A + E * g),
        (e[10] = f * _);
    } else if (t.order === 'YXZ') {
      const b = _ * x,
        E = _ * S,
        A = g * x,
        R = g * S;
      (e[0] = b + R * m),
        (e[4] = A * m - E),
        (e[8] = f * g),
        (e[1] = f * S),
        (e[5] = f * x),
        (e[9] = -m),
        (e[2] = E * m - A),
        (e[6] = R + b * m),
        (e[10] = f * _);
    } else if (t.order === 'ZXY') {
      const b = _ * x,
        E = _ * S,
        A = g * x,
        R = g * S;
      (e[0] = b - R * m),
        (e[4] = -f * S),
        (e[8] = A + E * m),
        (e[1] = E + A * m),
        (e[5] = f * x),
        (e[9] = R - b * m),
        (e[2] = -f * g),
        (e[6] = m),
        (e[10] = f * _);
    } else if (t.order === 'ZYX') {
      const b = f * x,
        E = f * S,
        A = m * x,
        R = m * S;
      (e[0] = _ * x),
        (e[4] = A * g - E),
        (e[8] = b * g + R),
        (e[1] = _ * S),
        (e[5] = R * g + b),
        (e[9] = E * g - A),
        (e[2] = -g),
        (e[6] = m * _),
        (e[10] = f * _);
    } else if (t.order === 'YZX') {
      const b = f * _,
        E = f * g,
        A = m * _,
        R = m * g;
      (e[0] = _ * x),
        (e[4] = R - b * S),
        (e[8] = A * S + E),
        (e[1] = S),
        (e[5] = f * x),
        (e[9] = -m * x),
        (e[2] = -g * x),
        (e[6] = E * S + A),
        (e[10] = b - R * S);
    } else if (t.order === 'XZY') {
      const b = f * _,
        E = f * g,
        A = m * _,
        R = m * g;
      (e[0] = _ * x),
        (e[4] = -S),
        (e[8] = g * x),
        (e[1] = b * S + R),
        (e[5] = f * x),
        (e[9] = E * S - A),
        (e[2] = A * S - E),
        (e[6] = m * x),
        (e[10] = R * S + b);
    }
    return (
      (e[3] = 0), (e[7] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this
    );
  }
  makeRotationFromQuaternion(t) {
    return this.compose(NA, t, zA);
  }
  lookAt(t, e, s) {
    const l = this.elements;
    return (
      Ki.subVectors(t, e),
      Ki.lengthSq() === 0 && (Ki.z = 1),
      Ki.normalize(),
      As.crossVectors(s, Ki),
      As.lengthSq() === 0 &&
        (Math.abs(s.z) === 1 ? (Ki.x += 1e-4) : (Ki.z += 1e-4),
        Ki.normalize(),
        As.crossVectors(s, Ki)),
      As.normalize(),
      Qh.crossVectors(Ki, As),
      (l[0] = As.x),
      (l[4] = Qh.x),
      (l[8] = Ki.x),
      (l[1] = As.y),
      (l[5] = Qh.y),
      (l[9] = Ki.y),
      (l[2] = As.z),
      (l[6] = Qh.z),
      (l[10] = Ki.z),
      this
    );
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const s = t.elements,
      l = e.elements,
      h = this.elements,
      f = s[0],
      m = s[4],
      _ = s[8],
      g = s[12],
      x = s[1],
      S = s[5],
      b = s[9],
      E = s[13],
      A = s[2],
      R = s[6],
      T = s[10],
      M = s[14],
      z = s[3],
      P = s[7],
      D = s[11],
      W = s[15],
      Z = l[0],
      V = l[4],
      J = l[8],
      F = l[12],
      I = l[1],
      j = l[5],
      ft = l[9],
      pt = l[13],
      Mt = l[2],
      bt = l[6],
      X = l[10],
      it = l[14],
      K = l[3],
      zt = l[7],
      N = l[11],
      Q = l[15];
    return (
      (h[0] = f * Z + m * I + _ * Mt + g * K),
      (h[4] = f * V + m * j + _ * bt + g * zt),
      (h[8] = f * J + m * ft + _ * X + g * N),
      (h[12] = f * F + m * pt + _ * it + g * Q),
      (h[1] = x * Z + S * I + b * Mt + E * K),
      (h[5] = x * V + S * j + b * bt + E * zt),
      (h[9] = x * J + S * ft + b * X + E * N),
      (h[13] = x * F + S * pt + b * it + E * Q),
      (h[2] = A * Z + R * I + T * Mt + M * K),
      (h[6] = A * V + R * j + T * bt + M * zt),
      (h[10] = A * J + R * ft + T * X + M * N),
      (h[14] = A * F + R * pt + T * it + M * Q),
      (h[3] = z * Z + P * I + D * Mt + W * K),
      (h[7] = z * V + P * j + D * bt + W * zt),
      (h[11] = z * J + P * ft + D * X + W * N),
      (h[15] = z * F + P * pt + D * it + W * Q),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[4] *= t),
      (e[8] *= t),
      (e[12] *= t),
      (e[1] *= t),
      (e[5] *= t),
      (e[9] *= t),
      (e[13] *= t),
      (e[2] *= t),
      (e[6] *= t),
      (e[10] *= t),
      (e[14] *= t),
      (e[3] *= t),
      (e[7] *= t),
      (e[11] *= t),
      (e[15] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      s = t[4],
      l = t[8],
      h = t[12],
      f = t[1],
      m = t[5],
      _ = t[9],
      g = t[13],
      x = t[2],
      S = t[6],
      b = t[10],
      E = t[14],
      A = t[3],
      R = t[7],
      T = t[11],
      M = t[15];
    return (
      A * (+h * _ * S - l * g * S - h * m * b + s * g * b + l * m * E - s * _ * E) +
      R * (+e * _ * E - e * g * b + h * f * b - l * f * E + l * g * x - h * _ * x) +
      T * (+e * g * S - e * m * E - h * f * S + s * f * E + h * m * x - s * g * x) +
      M * (-l * m * x - e * _ * S + e * m * b + l * f * S - s * f * b + s * _ * x)
    );
  }
  transpose() {
    const t = this.elements;
    let e;
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    );
  }
  setPosition(t, e, s) {
    const l = this.elements;
    return (
      t.isVector3
        ? ((l[12] = t.x), (l[13] = t.y), (l[14] = t.z))
        : ((l[12] = t), (l[13] = e), (l[14] = s)),
      this
    );
  }
  invert() {
    const t = this.elements,
      e = t[0],
      s = t[1],
      l = t[2],
      h = t[3],
      f = t[4],
      m = t[5],
      _ = t[6],
      g = t[7],
      x = t[8],
      S = t[9],
      b = t[10],
      E = t[11],
      A = t[12],
      R = t[13],
      T = t[14],
      M = t[15],
      z = S * T * g - R * b * g + R * _ * E - m * T * E - S * _ * M + m * b * M,
      P = A * b * g - x * T * g - A * _ * E + f * T * E + x * _ * M - f * b * M,
      D = x * R * g - A * S * g + A * m * E - f * R * E - x * m * M + f * S * M,
      W = A * S * _ - x * R * _ - A * m * b + f * R * b + x * m * T - f * S * T,
      Z = e * z + s * P + l * D + h * W;
    if (Z === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const V = 1 / Z;
    return (
      (t[0] = z * V),
      (t[1] = (R * b * h - S * T * h - R * l * E + s * T * E + S * l * M - s * b * M) * V),
      (t[2] = (m * T * h - R * _ * h + R * l * g - s * T * g - m * l * M + s * _ * M) * V),
      (t[3] = (S * _ * h - m * b * h - S * l * g + s * b * g + m * l * E - s * _ * E) * V),
      (t[4] = P * V),
      (t[5] = (x * T * h - A * b * h + A * l * E - e * T * E - x * l * M + e * b * M) * V),
      (t[6] = (A * _ * h - f * T * h - A * l * g + e * T * g + f * l * M - e * _ * M) * V),
      (t[7] = (f * b * h - x * _ * h + x * l * g - e * b * g - f * l * E + e * _ * E) * V),
      (t[8] = D * V),
      (t[9] = (A * S * h - x * R * h - A * s * E + e * R * E + x * s * M - e * S * M) * V),
      (t[10] = (f * R * h - A * m * h + A * s * g - e * R * g - f * s * M + e * m * M) * V),
      (t[11] = (x * m * h - f * S * h - x * s * g + e * S * g + f * s * E - e * m * E) * V),
      (t[12] = W * V),
      (t[13] = (x * R * l - A * S * l + A * s * b - e * R * b - x * s * T + e * S * T) * V),
      (t[14] = (A * m * l - f * R * l - A * s * _ + e * R * _ + f * s * T - e * m * T) * V),
      (t[15] = (f * S * l - x * m * l + x * s * _ - e * S * _ - f * s * b + e * m * b) * V),
      this
    );
  }
  scale(t) {
    const e = this.elements,
      s = t.x,
      l = t.y,
      h = t.z;
    return (
      (e[0] *= s),
      (e[4] *= l),
      (e[8] *= h),
      (e[1] *= s),
      (e[5] *= l),
      (e[9] *= h),
      (e[2] *= s),
      (e[6] *= l),
      (e[10] *= h),
      (e[3] *= s),
      (e[7] *= l),
      (e[11] *= h),
      this
    );
  }
  getMaxScaleOnAxis() {
    const t = this.elements,
      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
      s = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
      l = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, s, l));
  }
  makeTranslation(t, e, s) {
    return (
      t.isVector3
        ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, s, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(t) {
    const e = Math.cos(t),
      s = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -s, 0, 0, s, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t),
      s = Math.sin(t);
    return this.set(e, 0, s, 0, 0, 1, 0, 0, -s, 0, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t),
      s = Math.sin(t);
    return this.set(e, -s, 0, 0, s, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t, e) {
    const s = Math.cos(e),
      l = Math.sin(e),
      h = 1 - s,
      f = t.x,
      m = t.y,
      _ = t.z,
      g = h * f,
      x = h * m;
    return (
      this.set(
        g * f + s,
        g * m - l * _,
        g * _ + l * m,
        0,
        g * m + l * _,
        x * m + s,
        x * _ - l * f,
        0,
        g * _ - l * m,
        x * _ + l * f,
        h * _ * _ + s,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  makeScale(t, e, s) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, s, 0, 0, 0, 0, 1), this;
  }
  makeShear(t, e, s, l, h, f) {
    return this.set(1, s, h, 0, t, 1, f, 0, e, l, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t, e, s) {
    const l = this.elements,
      h = e._x,
      f = e._y,
      m = e._z,
      _ = e._w,
      g = h + h,
      x = f + f,
      S = m + m,
      b = h * g,
      E = h * x,
      A = h * S,
      R = f * x,
      T = f * S,
      M = m * S,
      z = _ * g,
      P = _ * x,
      D = _ * S,
      W = s.x,
      Z = s.y,
      V = s.z;
    return (
      (l[0] = (1 - (R + M)) * W),
      (l[1] = (E + D) * W),
      (l[2] = (A - P) * W),
      (l[3] = 0),
      (l[4] = (E - D) * Z),
      (l[5] = (1 - (b + M)) * Z),
      (l[6] = (T + z) * Z),
      (l[7] = 0),
      (l[8] = (A + P) * V),
      (l[9] = (T - z) * V),
      (l[10] = (1 - (b + R)) * V),
      (l[11] = 0),
      (l[12] = t.x),
      (l[13] = t.y),
      (l[14] = t.z),
      (l[15] = 1),
      this
    );
  }
  decompose(t, e, s) {
    const l = this.elements;
    let h = yl.set(l[0], l[1], l[2]).length();
    const f = yl.set(l[4], l[5], l[6]).length(),
      m = yl.set(l[8], l[9], l[10]).length();
    this.determinant() < 0 && (h = -h), (t.x = l[12]), (t.y = l[13]), (t.z = l[14]), Ca.copy(this);
    const g = 1 / h,
      x = 1 / f,
      S = 1 / m;
    return (
      (Ca.elements[0] *= g),
      (Ca.elements[1] *= g),
      (Ca.elements[2] *= g),
      (Ca.elements[4] *= x),
      (Ca.elements[5] *= x),
      (Ca.elements[6] *= x),
      (Ca.elements[8] *= S),
      (Ca.elements[9] *= S),
      (Ca.elements[10] *= S),
      e.setFromRotationMatrix(Ca),
      (s.x = h),
      (s.y = f),
      (s.z = m),
      this
    );
  }
  makePerspective(t, e, s, l, h, f, m = Ur) {
    const _ = this.elements,
      g = (2 * h) / (e - t),
      x = (2 * h) / (s - l),
      S = (e + t) / (e - t),
      b = (s + l) / (s - l);
    let E, A;
    if (m === Ur) (E = -(f + h) / (f - h)), (A = (-2 * f * h) / (f - h));
    else if (m === Bf) (E = -f / (f - h)), (A = (-f * h) / (f - h));
    else throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + m);
    return (
      (_[0] = g),
      (_[4] = 0),
      (_[8] = S),
      (_[12] = 0),
      (_[1] = 0),
      (_[5] = x),
      (_[9] = b),
      (_[13] = 0),
      (_[2] = 0),
      (_[6] = 0),
      (_[10] = E),
      (_[14] = A),
      (_[3] = 0),
      (_[7] = 0),
      (_[11] = -1),
      (_[15] = 0),
      this
    );
  }
  makeOrthographic(t, e, s, l, h, f, m = Ur) {
    const _ = this.elements,
      g = 1 / (e - t),
      x = 1 / (s - l),
      S = 1 / (f - h),
      b = (e + t) * g,
      E = (s + l) * x;
    let A, R;
    if (m === Ur) (A = (f + h) * S), (R = -2 * S);
    else if (m === Bf) (A = h * S), (R = -1 * S);
    else throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + m);
    return (
      (_[0] = 2 * g),
      (_[4] = 0),
      (_[8] = 0),
      (_[12] = -b),
      (_[1] = 0),
      (_[5] = 2 * x),
      (_[9] = 0),
      (_[13] = -E),
      (_[2] = 0),
      (_[6] = 0),
      (_[10] = R),
      (_[14] = -A),
      (_[3] = 0),
      (_[7] = 0),
      (_[11] = 0),
      (_[15] = 1),
      this
    );
  }
  equals(t) {
    const e = this.elements,
      s = t.elements;
    for (let l = 0; l < 16; l++) if (e[l] !== s[l]) return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let s = 0; s < 16; s++) this.elements[s] = t[s + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const s = this.elements;
    return (
      (t[e] = s[0]),
      (t[e + 1] = s[1]),
      (t[e + 2] = s[2]),
      (t[e + 3] = s[3]),
      (t[e + 4] = s[4]),
      (t[e + 5] = s[5]),
      (t[e + 6] = s[6]),
      (t[e + 7] = s[7]),
      (t[e + 8] = s[8]),
      (t[e + 9] = s[9]),
      (t[e + 10] = s[10]),
      (t[e + 11] = s[11]),
      (t[e + 12] = s[12]),
      (t[e + 13] = s[13]),
      (t[e + 14] = s[14]),
      (t[e + 15] = s[15]),
      t
    );
  }
}
const yl = new et(),
  Ca = new En(),
  NA = new et(0, 0, 0),
  zA = new et(1, 1, 1),
  As = new et(),
  Qh = new et(),
  Ki = new et(),
  Vy = new En(),
  Wy = new kr();
class Qa {
  constructor(t = 0, e = 0, s = 0, l = Qa.DEFAULT_ORDER) {
    (this.isEuler = !0), (this._x = t), (this._y = e), (this._z = s), (this._order = l);
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    (this._order = t), this._onChangeCallback();
  }
  set(t, e, s, l = this._order) {
    return (
      (this._x = t), (this._y = e), (this._z = s), (this._order = l), this._onChangeCallback(), this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return (
      (this._x = t._x),
      (this._y = t._y),
      (this._z = t._z),
      (this._order = t._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t, e = this._order, s = !0) {
    const l = t.elements,
      h = l[0],
      f = l[4],
      m = l[8],
      _ = l[1],
      g = l[5],
      x = l[9],
      S = l[2],
      b = l[6],
      E = l[10];
    switch (e) {
      case 'XYZ':
        (this._y = Math.asin(Ve(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._x = Math.atan2(-x, E)), (this._z = Math.atan2(-f, h)))
            : ((this._x = Math.atan2(b, g)), (this._z = 0));
        break;
      case 'YXZ':
        (this._x = Math.asin(-Ve(x, -1, 1))),
          Math.abs(x) < 0.9999999
            ? ((this._y = Math.atan2(m, E)), (this._z = Math.atan2(_, g)))
            : ((this._y = Math.atan2(-S, h)), (this._z = 0));
        break;
      case 'ZXY':
        (this._x = Math.asin(Ve(b, -1, 1))),
          Math.abs(b) < 0.9999999
            ? ((this._y = Math.atan2(-S, E)), (this._z = Math.atan2(-f, g)))
            : ((this._y = 0), (this._z = Math.atan2(_, h)));
        break;
      case 'ZYX':
        (this._y = Math.asin(-Ve(S, -1, 1))),
          Math.abs(S) < 0.9999999
            ? ((this._x = Math.atan2(b, E)), (this._z = Math.atan2(_, h)))
            : ((this._x = 0), (this._z = Math.atan2(-f, g)));
        break;
      case 'YZX':
        (this._z = Math.asin(Ve(_, -1, 1))),
          Math.abs(_) < 0.9999999
            ? ((this._x = Math.atan2(-x, g)), (this._y = Math.atan2(-S, h)))
            : ((this._x = 0), (this._y = Math.atan2(m, E)));
        break;
      case 'XZY':
        (this._z = Math.asin(-Ve(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._x = Math.atan2(b, g)), (this._y = Math.atan2(m, h)))
            : ((this._x = Math.atan2(-x, E)), (this._y = 0));
        break;
      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + e);
    }
    return (this._order = e), s === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, s) {
    return Vy.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Vy, e, s);
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return Wy.setFromEuler(this), this.setFromQuaternion(Wy, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return (
      (this._x = t[0]),
      (this._y = t[1]),
      (this._z = t[2]),
      t[3] !== void 0 && (this._order = t[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._order), t
    );
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Qa.DEFAULT_ORDER = 'XYZ';
class JS {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = ((1 << t) | 0) >>> 0;
  }
  enable(t) {
    this.mask |= (1 << t) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= (1 << t) | 0;
  }
  disable(t) {
    this.mask &= ~((1 << t) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) !== 0;
  }
  isEnabled(t) {
    return (this.mask & ((1 << t) | 0)) !== 0;
  }
}
let IA = 0;
const Zy = new et(),
  xl = new kr(),
  Ar = new En(),
  Jh = new et(),
  eu = new et(),
  BA = new et(),
  kA = new kr(),
  Xy = new et(1, 0, 0),
  jy = new et(0, 1, 0),
  qy = new et(0, 0, 1),
  Yy = { type: 'added' },
  FA = { type: 'removed' },
  Sl = { type: 'childadded', child: null },
  lm = { type: 'childremoved', child: null };
class ci extends Co {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, 'id', { value: IA++ }),
      (this.uuid = Yl()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = ci.DEFAULT_UP.clone());
    const t = new et(),
      e = new Qa(),
      s = new kr(),
      l = new et(1, 1, 1);
    function h() {
      s.setFromEuler(e, !1);
    }
    function f() {
      e.setFromQuaternion(s, void 0, !1);
    }
    e._onChange(h),
      s._onChange(f),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: t },
        rotation: { configurable: !0, enumerable: !0, value: e },
        quaternion: { configurable: !0, enumerable: !0, value: s },
        scale: { configurable: !0, enumerable: !0, value: l },
        modelViewMatrix: { value: new En() },
        normalMatrix: { value: new Be() },
      }),
      (this.matrix = new En()),
      (this.matrixWorld = new En()),
      (this.matrixAutoUpdate = ci.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = ci.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new JS()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.customDepthMaterial = void 0),
      (this.customDistanceMaterial = void 0),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(t),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, e) {
    return xl.setFromAxisAngle(t, e), this.quaternion.multiply(xl), this;
  }
  rotateOnWorldAxis(t, e) {
    return xl.setFromAxisAngle(t, e), this.quaternion.premultiply(xl), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(Xy, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(jy, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(qy, t);
  }
  translateOnAxis(t, e) {
    return (
      Zy.copy(t).applyQuaternion(this.quaternion), this.position.add(Zy.multiplyScalar(e)), this
    );
  }
  translateX(t) {
    return this.translateOnAxis(Xy, t);
  }
  translateY(t) {
    return this.translateOnAxis(jy, t);
  }
  translateZ(t) {
    return this.translateOnAxis(qy, t);
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(Ar.copy(this.matrixWorld).invert());
  }
  lookAt(t, e, s) {
    t.isVector3 ? Jh.copy(t) : Jh.set(t, e, s);
    const l = this.parent;
    this.updateWorldMatrix(!0, !1),
      eu.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight ? Ar.lookAt(eu, Jh, this.up) : Ar.lookAt(Jh, eu, this.up),
      this.quaternion.setFromRotationMatrix(Ar),
      l &&
        (Ar.extractRotation(l.matrixWorld),
        xl.setFromRotationMatrix(Ar),
        this.quaternion.premultiply(xl.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
      return this;
    }
    return t === this
      ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this)
      : (t && t.isObject3D
          ? (t.removeFromParent(),
            (t.parent = this),
            this.children.push(t),
            t.dispatchEvent(Yy),
            (Sl.child = t),
            this.dispatchEvent(Sl),
            (Sl.child = null))
          : console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', t),
        this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let s = 0; s < arguments.length; s++) this.remove(arguments[s]);
      return this;
    }
    const e = this.children.indexOf(t);
    return (
      e !== -1 &&
        ((t.parent = null),
        this.children.splice(e, 1),
        t.dispatchEvent(FA),
        (lm.child = t),
        this.dispatchEvent(lm),
        (lm.child = null)),
      this
    );
  }
  removeFromParent() {
    const t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(t) {
    return (
      this.updateWorldMatrix(!0, !1),
      Ar.copy(this.matrixWorld).invert(),
      t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), Ar.multiply(t.parent.matrixWorld)),
      t.applyMatrix4(Ar),
      t.removeFromParent(),
      (t.parent = this),
      this.children.push(t),
      t.updateWorldMatrix(!1, !0),
      t.dispatchEvent(Yy),
      (Sl.child = t),
      this.dispatchEvent(Sl),
      (Sl.child = null),
      this
    );
  }
  getObjectById(t) {
    return this.getObjectByProperty('id', t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty('name', t);
  }
  getObjectByProperty(t, e) {
    if (this[t] === e) return this;
    for (let s = 0, l = this.children.length; s < l; s++) {
      const f = this.children[s].getObjectByProperty(t, e);
      if (f !== void 0) return f;
    }
  }
  getObjectsByProperty(t, e, s = []) {
    this[t] === e && s.push(this);
    const l = this.children;
    for (let h = 0, f = l.length; h < f; h++) l[h].getObjectsByProperty(t, e, s);
    return s;
  }
  getWorldPosition(t) {
    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(eu, t, BA), t;
  }
  getWorldScale(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(eu, kA, t), t;
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {}
  traverse(t) {
    t(this);
    const e = this.children;
    for (let s = 0, l = e.length; s < l; s++) e[s].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === !1) return;
    t(this);
    const e = this.children;
    for (let s = 0, l = e.length; s < l; s++) e[s].traverseVisible(t);
  }
  traverseAncestors(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || t) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        (this.matrixWorldNeedsUpdate = !1),
        (t = !0));
    const e = this.children;
    for (let s = 0, l = e.length; s < l; s++) e[s].updateMatrixWorld(t);
  }
  updateWorldMatrix(t, e) {
    const s = this.parent;
    if (
      (t === !0 && s !== null && s.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
      e === !0)
    ) {
      const l = this.children;
      for (let h = 0, f = l.length; h < f; h++) l[h].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == 'string',
      s = {};
    e &&
      ((t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (s.metadata = { version: 4.6, type: 'Object', generator: 'Object3D.toJSON' }));
    const l = {};
    (l.uuid = this.uuid),
      (l.type = this.type),
      this.name !== '' && (l.name = this.name),
      this.castShadow === !0 && (l.castShadow = !0),
      this.receiveShadow === !0 && (l.receiveShadow = !0),
      this.visible === !1 && (l.visible = !1),
      this.frustumCulled === !1 && (l.frustumCulled = !1),
      this.renderOrder !== 0 && (l.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (l.userData = this.userData),
      (l.layers = this.layers.mask),
      (l.matrix = this.matrix.toArray()),
      (l.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (l.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((l.type = 'InstancedMesh'),
        (l.count = this.count),
        (l.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null && (l.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((l.type = 'BatchedMesh'),
        (l.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (l.sortObjects = this.sortObjects),
        (l.drawRanges = this._drawRanges),
        (l.reservedRanges = this._reservedRanges),
        (l.geometryInfo = this._geometryInfo.map((m) => ({
          ...m,
          boundingBox: m.boundingBox
            ? { min: m.boundingBox.min.toArray(), max: m.boundingBox.max.toArray() }
            : void 0,
          boundingSphere: m.boundingSphere
            ? { radius: m.boundingSphere.radius, center: m.boundingSphere.center.toArray() }
            : void 0,
        }))),
        (l.instanceInfo = this._instanceInfo.map((m) => ({ ...m }))),
        (l.availableInstanceIds = this._availableInstanceIds.slice()),
        (l.availableGeometryIds = this._availableGeometryIds.slice()),
        (l.nextIndexStart = this._nextIndexStart),
        (l.nextVertexStart = this._nextVertexStart),
        (l.geometryCount = this._geometryCount),
        (l.maxInstanceCount = this._maxInstanceCount),
        (l.maxVertexCount = this._maxVertexCount),
        (l.maxIndexCount = this._maxIndexCount),
        (l.geometryInitialized = this._geometryInitialized),
        (l.matricesTexture = this._matricesTexture.toJSON(t)),
        (l.indirectTexture = this._indirectTexture.toJSON(t)),
        this._colorsTexture !== null && (l.colorsTexture = this._colorsTexture.toJSON(t)),
        this.boundingSphere !== null &&
          (l.boundingSphere = {
            center: this.boundingSphere.center.toArray(),
            radius: this.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (l.boundingBox = {
            min: this.boundingBox.min.toArray(),
            max: this.boundingBox.max.toArray(),
          }));
    function h(m, _) {
      return m[_.uuid] === void 0 && (m[_.uuid] = _.toJSON(t)), _.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (l.background = this.background.toJSON())
          : this.background.isTexture && (l.background = this.background.toJSON(t).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (l.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      l.geometry = h(t.geometries, this.geometry);
      const m = this.geometry.parameters;
      if (m !== void 0 && m.shapes !== void 0) {
        const _ = m.shapes;
        if (Array.isArray(_))
          for (let g = 0, x = _.length; g < x; g++) {
            const S = _[g];
            h(t.shapes, S);
          }
        else h(t.shapes, _);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((l.bindMode = this.bindMode),
        (l.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (h(t.skeletons, this.skeleton), (l.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const m = [];
        for (let _ = 0, g = this.material.length; _ < g; _++)
          m.push(h(t.materials, this.material[_]));
        l.material = m;
      } else l.material = h(t.materials, this.material);
    if (this.children.length > 0) {
      l.children = [];
      for (let m = 0; m < this.children.length; m++)
        l.children.push(this.children[m].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      l.animations = [];
      for (let m = 0; m < this.animations.length; m++) {
        const _ = this.animations[m];
        l.animations.push(h(t.animations, _));
      }
    }
    if (e) {
      const m = f(t.geometries),
        _ = f(t.materials),
        g = f(t.textures),
        x = f(t.images),
        S = f(t.shapes),
        b = f(t.skeletons),
        E = f(t.animations),
        A = f(t.nodes);
      m.length > 0 && (s.geometries = m),
        _.length > 0 && (s.materials = _),
        g.length > 0 && (s.textures = g),
        x.length > 0 && (s.images = x),
        S.length > 0 && (s.shapes = S),
        b.length > 0 && (s.skeletons = b),
        E.length > 0 && (s.animations = E),
        A.length > 0 && (s.nodes = A);
    }
    return (s.object = l), s;
    function f(m) {
      const _ = [];
      for (const g in m) {
        const x = m[g];
        delete x.metadata, _.push(x);
      }
      return _;
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, e = !0) {
    if (
      ((this.name = t.name),
      this.up.copy(t.up),
      this.position.copy(t.position),
      (this.rotation.order = t.rotation.order),
      this.quaternion.copy(t.quaternion),
      this.scale.copy(t.scale),
      this.matrix.copy(t.matrix),
      this.matrixWorld.copy(t.matrixWorld),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
      (this.layers.mask = t.layers.mask),
      (this.visible = t.visible),
      (this.castShadow = t.castShadow),
      (this.receiveShadow = t.receiveShadow),
      (this.frustumCulled = t.frustumCulled),
      (this.renderOrder = t.renderOrder),
      (this.animations = t.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      e === !0)
    )
      for (let s = 0; s < t.children.length; s++) {
        const l = t.children[s];
        this.add(l.clone());
      }
    return this;
  }
}
ci.DEFAULT_UP = new et(0, 1, 0);
ci.DEFAULT_MATRIX_AUTO_UPDATE = !0;
ci.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Ra = new et(),
  Cr = new et(),
  cm = new et(),
  Rr = new et(),
  Ml = new et(),
  bl = new et(),
  Ky = new et(),
  um = new et(),
  hm = new et(),
  fm = new et(),
  dm = new Un(),
  pm = new Un(),
  mm = new Un();
class La {
  constructor(t = new et(), e = new et(), s = new et()) {
    (this.a = t), (this.b = e), (this.c = s);
  }
  static getNormal(t, e, s, l) {
    l.subVectors(s, e), Ra.subVectors(t, e), l.cross(Ra);
    const h = l.lengthSq();
    return h > 0 ? l.multiplyScalar(1 / Math.sqrt(h)) : l.set(0, 0, 0);
  }
  static getBarycoord(t, e, s, l, h) {
    Ra.subVectors(l, e), Cr.subVectors(s, e), cm.subVectors(t, e);
    const f = Ra.dot(Ra),
      m = Ra.dot(Cr),
      _ = Ra.dot(cm),
      g = Cr.dot(Cr),
      x = Cr.dot(cm),
      S = f * g - m * m;
    if (S === 0) return h.set(0, 0, 0), null;
    const b = 1 / S,
      E = (g * _ - m * x) * b,
      A = (f * x - m * _) * b;
    return h.set(1 - E - A, A, E);
  }
  static containsPoint(t, e, s, l) {
    return this.getBarycoord(t, e, s, l, Rr) === null
      ? !1
      : Rr.x >= 0 && Rr.y >= 0 && Rr.x + Rr.y <= 1;
  }
  static getInterpolation(t, e, s, l, h, f, m, _) {
    return this.getBarycoord(t, e, s, l, Rr) === null
      ? ((_.x = 0), (_.y = 0), 'z' in _ && (_.z = 0), 'w' in _ && (_.w = 0), null)
      : (_.setScalar(0),
        _.addScaledVector(h, Rr.x),
        _.addScaledVector(f, Rr.y),
        _.addScaledVector(m, Rr.z),
        _);
  }
  static getInterpolatedAttribute(t, e, s, l, h, f) {
    return (
      dm.setScalar(0),
      pm.setScalar(0),
      mm.setScalar(0),
      dm.fromBufferAttribute(t, e),
      pm.fromBufferAttribute(t, s),
      mm.fromBufferAttribute(t, l),
      f.setScalar(0),
      f.addScaledVector(dm, h.x),
      f.addScaledVector(pm, h.y),
      f.addScaledVector(mm, h.z),
      f
    );
  }
  static isFrontFacing(t, e, s, l) {
    return Ra.subVectors(s, e), Cr.subVectors(t, e), Ra.cross(Cr).dot(l) < 0;
  }
  set(t, e, s) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(s), this;
  }
  setFromPointsAndIndices(t, e, s, l) {
    return this.a.copy(t[e]), this.b.copy(t[s]), this.c.copy(t[l]), this;
  }
  setFromAttributeAndIndices(t, e, s, l) {
    return (
      this.a.fromBufferAttribute(t, e),
      this.b.fromBufferAttribute(t, s),
      this.c.fromBufferAttribute(t, l),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return (
      Ra.subVectors(this.c, this.b), Cr.subVectors(this.a, this.b), Ra.cross(Cr).length() * 0.5
    );
  }
  getMidpoint(t) {
    return t
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return La.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return La.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getInterpolation(t, e, s, l, h) {
    return La.getInterpolation(t, this.a, this.b, this.c, e, s, l, h);
  }
  containsPoint(t) {
    return La.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return La.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    const s = this.a,
      l = this.b,
      h = this.c;
    let f, m;
    Ml.subVectors(l, s), bl.subVectors(h, s), um.subVectors(t, s);
    const _ = Ml.dot(um),
      g = bl.dot(um);
    if (_ <= 0 && g <= 0) return e.copy(s);
    hm.subVectors(t, l);
    const x = Ml.dot(hm),
      S = bl.dot(hm);
    if (x >= 0 && S <= x) return e.copy(l);
    const b = _ * S - x * g;
    if (b <= 0 && _ >= 0 && x <= 0) return (f = _ / (_ - x)), e.copy(s).addScaledVector(Ml, f);
    fm.subVectors(t, h);
    const E = Ml.dot(fm),
      A = bl.dot(fm);
    if (A >= 0 && E <= A) return e.copy(h);
    const R = E * g - _ * A;
    if (R <= 0 && g >= 0 && A <= 0) return (m = g / (g - A)), e.copy(s).addScaledVector(bl, m);
    const T = x * A - E * S;
    if (T <= 0 && S - x >= 0 && E - A >= 0)
      return (
        Ky.subVectors(h, l), (m = (S - x) / (S - x + (E - A))), e.copy(l).addScaledVector(Ky, m)
      );
    const M = 1 / (T + R + b);
    return (f = R * M), (m = b * M), e.copy(s).addScaledVector(Ml, f).addScaledVector(bl, m);
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
}
const $S = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Cs = { h: 0, s: 0, l: 0 },
  $h = { h: 0, s: 0, l: 0 };
function _m(a, t, e) {
  return (
    e < 0 && (e += 1),
    e > 1 && (e -= 1),
    e < 1 / 6 ? a + (t - a) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? a + (t - a) * 6 * (2 / 3 - e) : a
  );
}
class Qe {
  constructor(t, e, s) {
    return (this.isColor = !0), (this.r = 1), (this.g = 1), (this.b = 1), this.set(t, e, s);
  }
  set(t, e, s) {
    if (e === void 0 && s === void 0) {
      const l = t;
      l && l.isColor
        ? this.copy(l)
        : typeof l == 'number'
          ? this.setHex(l)
          : typeof l == 'string' && this.setStyle(l);
    } else this.setRGB(t, e, s);
    return this;
  }
  setScalar(t) {
    return (this.r = t), (this.g = t), (this.b = t), this;
  }
  setHex(t, e = fa) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (t & 255) / 255),
      en.toWorkingColorSpace(this, e),
      this
    );
  }
  setRGB(t, e, s, l = en.workingColorSpace) {
    return (this.r = t), (this.g = e), (this.b = s), en.toWorkingColorSpace(this, l), this;
  }
  setHSL(t, e, s, l = en.workingColorSpace) {
    if (((t = MA(t, 1)), (e = Ve(e, 0, 1)), (s = Ve(s, 0, 1)), e === 0))
      this.r = this.g = this.b = s;
    else {
      const h = s <= 0.5 ? s * (1 + e) : s + e - s * e,
        f = 2 * s - h;
      (this.r = _m(f, h, t + 1 / 3)), (this.g = _m(f, h, t)), (this.b = _m(f, h, t - 1 / 3));
    }
    return en.toWorkingColorSpace(this, l), this;
  }
  setStyle(t, e = fa) {
    function s(h) {
      h !== void 0 &&
        parseFloat(h) < 1 &&
        console.warn('THREE.Color: Alpha component of ' + t + ' will be ignored.');
    }
    let l;
    if ((l = /^(\w+)\(([^\)]*)\)/.exec(t))) {
      let h;
      const f = l[1],
        m = l[2];
      switch (f) {
        case 'rgb':
        case 'rgba':
          if ((h = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(m)))
            return (
              s(h[4]),
              this.setRGB(
                Math.min(255, parseInt(h[1], 10)) / 255,
                Math.min(255, parseInt(h[2], 10)) / 255,
                Math.min(255, parseInt(h[3], 10)) / 255,
                e,
              )
            );
          if ((h = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(m)))
            return (
              s(h[4]),
              this.setRGB(
                Math.min(100, parseInt(h[1], 10)) / 100,
                Math.min(100, parseInt(h[2], 10)) / 100,
                Math.min(100, parseInt(h[3], 10)) / 100,
                e,
              )
            );
          break;
        case 'hsl':
        case 'hsla':
          if (
            (h =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                m,
              ))
          )
            return (
              s(h[4]),
              this.setHSL(parseFloat(h[1]) / 360, parseFloat(h[2]) / 100, parseFloat(h[3]) / 100, e)
            );
          break;
        default:
          console.warn('THREE.Color: Unknown color model ' + t);
      }
    } else if ((l = /^\#([A-Fa-f\d]+)$/.exec(t))) {
      const h = l[1],
        f = h.length;
      if (f === 3)
        return this.setRGB(
          parseInt(h.charAt(0), 16) / 15,
          parseInt(h.charAt(1), 16) / 15,
          parseInt(h.charAt(2), 16) / 15,
          e,
        );
      if (f === 6) return this.setHex(parseInt(h, 16), e);
      console.warn('THREE.Color: Invalid hex color ' + t);
    } else if (t && t.length > 0) return this.setColorName(t, e);
    return this;
  }
  setColorName(t, e = fa) {
    const s = $S[t.toLowerCase()];
    return s !== void 0 ? this.setHex(s, e) : console.warn('THREE.Color: Unknown color ' + t), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
  }
  copySRGBToLinear(t) {
    return (this.r = Ir(t.r)), (this.g = Ir(t.g)), (this.b = Ir(t.b)), this;
  }
  copyLinearToSRGB(t) {
    return (this.r = Il(t.r)), (this.g = Il(t.g)), (this.b = Il(t.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t = fa) {
    return (
      en.fromWorkingColorSpace(_i.copy(this), t),
      Math.round(Ve(_i.r * 255, 0, 255)) * 65536 +
        Math.round(Ve(_i.g * 255, 0, 255)) * 256 +
        Math.round(Ve(_i.b * 255, 0, 255))
    );
  }
  getHexString(t = fa) {
    return ('000000' + this.getHex(t).toString(16)).slice(-6);
  }
  getHSL(t, e = en.workingColorSpace) {
    en.fromWorkingColorSpace(_i.copy(this), e);
    const s = _i.r,
      l = _i.g,
      h = _i.b,
      f = Math.max(s, l, h),
      m = Math.min(s, l, h);
    let _, g;
    const x = (m + f) / 2;
    if (m === f) (_ = 0), (g = 0);
    else {
      const S = f - m;
      switch (((g = x <= 0.5 ? S / (f + m) : S / (2 - f - m)), f)) {
        case s:
          _ = (l - h) / S + (l < h ? 6 : 0);
          break;
        case l:
          _ = (h - s) / S + 2;
          break;
        case h:
          _ = (s - l) / S + 4;
          break;
      }
      _ /= 6;
    }
    return (t.h = _), (t.s = g), (t.l = x), t;
  }
  getRGB(t, e = en.workingColorSpace) {
    return en.fromWorkingColorSpace(_i.copy(this), e), (t.r = _i.r), (t.g = _i.g), (t.b = _i.b), t;
  }
  getStyle(t = fa) {
    en.fromWorkingColorSpace(_i.copy(this), t);
    const e = _i.r,
      s = _i.g,
      l = _i.b;
    return t !== fa
      ? `color(${t} ${e.toFixed(3)} ${s.toFixed(3)} ${l.toFixed(3)})`
      : `rgb(${Math.round(e * 255)},${Math.round(s * 255)},${Math.round(l * 255)})`;
  }
  offsetHSL(t, e, s) {
    return this.getHSL(Cs), this.setHSL(Cs.h + t, Cs.s + e, Cs.l + s);
  }
  add(t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
  }
  addColors(t, e) {
    return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this;
  }
  addScalar(t) {
    return (this.r += t), (this.g += t), (this.b += t), this;
  }
  sub(t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    );
  }
  multiply(t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
  }
  multiplyScalar(t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this;
  }
  lerp(t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    );
  }
  lerpColors(t, e, s) {
    return (
      (this.r = t.r + (e.r - t.r) * s),
      (this.g = t.g + (e.g - t.g) * s),
      (this.b = t.b + (e.b - t.b) * s),
      this
    );
  }
  lerpHSL(t, e) {
    this.getHSL(Cs), t.getHSL($h);
    const s = $p(Cs.h, $h.h, e),
      l = $p(Cs.s, $h.s, e),
      h = $p(Cs.l, $h.l, e);
    return this.setHSL(s, l, h), this;
  }
  setFromVector3(t) {
    return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
  }
  applyMatrix3(t) {
    const e = this.r,
      s = this.g,
      l = this.b,
      h = t.elements;
    return (
      (this.r = h[0] * e + h[3] * s + h[6] * l),
      (this.g = h[1] * e + h[4] * s + h[7] * l),
      (this.b = h[2] * e + h[5] * s + h[8] * l),
      this
    );
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
  }
  fromBufferAttribute(t, e) {
    return (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const _i = new Qe();
Qe.NAMES = $S;
let HA = 0;
class Kl extends Co {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, 'id', { value: HA++ }),
      (this.uuid = Yl()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.blending = zl),
      (this.side = Ns),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = km),
      (this.blendDst = Fm),
      (this.blendEquation = yo),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Qe(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = kl),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = zy),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = pl),
      (this.stencilZFail = pl),
      (this.stencilZPass = pl),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.allowOverride = !0),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0)
      for (const e in t) {
        const s = t[e];
        if (s === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const l = this[e];
        if (l === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        l && l.isColor
          ? l.set(s)
          : l && l.isVector3 && s && s.isVector3
            ? l.copy(s)
            : (this[e] = s);
      }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == 'string';
    e && (t = { textures: {}, images: {} });
    const s = { metadata: { version: 4.6, type: 'Material', generator: 'Material.toJSON' } };
    (s.uuid = this.uuid),
      (s.type = this.type),
      this.name !== '' && (s.name = this.name),
      this.color && this.color.isColor && (s.color = this.color.getHex()),
      this.roughness !== void 0 && (s.roughness = this.roughness),
      this.metalness !== void 0 && (s.metalness = this.metalness),
      this.sheen !== void 0 && (s.sheen = this.sheen),
      this.sheenColor && this.sheenColor.isColor && (s.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 && (s.sheenRoughness = this.sheenRoughness),
      this.emissive && this.emissive.isColor && (s.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (s.emissiveIntensity = this.emissiveIntensity),
      this.specular && this.specular.isColor && (s.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 && (s.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (s.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (s.shininess = this.shininess),
      this.clearcoat !== void 0 && (s.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (s.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (s.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((s.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
        (s.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (s.dispersion = this.dispersion),
      this.iridescence !== void 0 && (s.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 && (s.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (s.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (s.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (s.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid),
      this.anisotropy !== void 0 && (s.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 && (s.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (s.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
      this.map && this.map.isTexture && (s.map = this.map.toJSON(t).uuid),
      this.matcap && this.matcap.isTexture && (s.matcap = this.matcap.toJSON(t).uuid),
      this.alphaMap && this.alphaMap.isTexture && (s.alphaMap = this.alphaMap.toJSON(t).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((s.lightMap = this.lightMap.toJSON(t).uuid),
        (s.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((s.aoMap = this.aoMap.toJSON(t).uuid), (s.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((s.bumpMap = this.bumpMap.toJSON(t).uuid), (s.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((s.normalMap = this.normalMap.toJSON(t).uuid),
        (s.normalMapType = this.normalMapType),
        (s.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((s.displacementMap = this.displacementMap.toJSON(t).uuid),
        (s.displacementScale = this.displacementScale),
        (s.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (s.roughnessMap = this.roughnessMap.toJSON(t).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (s.metalnessMap = this.metalnessMap.toJSON(t).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (s.emissiveMap = this.emissiveMap.toJSON(t).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (s.specularMap = this.specularMap.toJSON(t).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (s.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (s.specularColorMap = this.specularColorMap.toJSON(t).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((s.envMap = this.envMap.toJSON(t).uuid),
        this.combine !== void 0 && (s.combine = this.combine)),
      this.envMapRotation !== void 0 && (s.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 && (s.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (s.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 && (s.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (s.gradientMap = this.gradientMap.toJSON(t).uuid),
      this.transmission !== void 0 && (s.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (s.transmissionMap = this.transmissionMap.toJSON(t).uuid),
      this.thickness !== void 0 && (s.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (s.thicknessMap = this.thicknessMap.toJSON(t).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (s.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 && (s.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (s.size = this.size),
      this.shadowSide !== null && (s.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 && (s.sizeAttenuation = this.sizeAttenuation),
      this.blending !== zl && (s.blending = this.blending),
      this.side !== Ns && (s.side = this.side),
      this.vertexColors === !0 && (s.vertexColors = !0),
      this.opacity < 1 && (s.opacity = this.opacity),
      this.transparent === !0 && (s.transparent = !0),
      this.blendSrc !== km && (s.blendSrc = this.blendSrc),
      this.blendDst !== Fm && (s.blendDst = this.blendDst),
      this.blendEquation !== yo && (s.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (s.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (s.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null && (s.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor && this.blendColor.isColor && (s.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (s.blendAlpha = this.blendAlpha),
      this.depthFunc !== kl && (s.depthFunc = this.depthFunc),
      this.depthTest === !1 && (s.depthTest = this.depthTest),
      this.depthWrite === !1 && (s.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (s.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 && (s.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== zy && (s.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (s.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 && (s.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== pl && (s.stencilFail = this.stencilFail),
      this.stencilZFail !== pl && (s.stencilZFail = this.stencilZFail),
      this.stencilZPass !== pl && (s.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (s.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 && this.rotation !== 0 && (s.rotation = this.rotation),
      this.polygonOffset === !0 && (s.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 && (s.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 && (s.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 && this.linewidth !== 1 && (s.linewidth = this.linewidth),
      this.dashSize !== void 0 && (s.dashSize = this.dashSize),
      this.gapSize !== void 0 && (s.gapSize = this.gapSize),
      this.scale !== void 0 && (s.scale = this.scale),
      this.dithering === !0 && (s.dithering = !0),
      this.alphaTest > 0 && (s.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (s.alphaHash = !0),
      this.alphaToCoverage === !0 && (s.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (s.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (s.forceSinglePass = !0),
      this.wireframe === !0 && (s.wireframe = !0),
      this.wireframeLinewidth > 1 && (s.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== 'round' && (s.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== 'round' && (s.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (s.flatShading = !0),
      this.visible === !1 && (s.visible = !1),
      this.toneMapped === !1 && (s.toneMapped = !1),
      this.fog === !1 && (s.fog = !1),
      Object.keys(this.userData).length > 0 && (s.userData = this.userData);
    function l(h) {
      const f = [];
      for (const m in h) {
        const _ = h[m];
        delete _.metadata, f.push(_);
      }
      return f;
    }
    if (e) {
      const h = l(t.textures),
        f = l(t.images);
      h.length > 0 && (s.textures = h), f.length > 0 && (s.images = f);
    }
    return s;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.name = t.name),
      (this.blending = t.blending),
      (this.side = t.side),
      (this.vertexColors = t.vertexColors),
      (this.opacity = t.opacity),
      (this.transparent = t.transparent),
      (this.blendSrc = t.blendSrc),
      (this.blendDst = t.blendDst),
      (this.blendEquation = t.blendEquation),
      (this.blendSrcAlpha = t.blendSrcAlpha),
      (this.blendDstAlpha = t.blendDstAlpha),
      (this.blendEquationAlpha = t.blendEquationAlpha),
      this.blendColor.copy(t.blendColor),
      (this.blendAlpha = t.blendAlpha),
      (this.depthFunc = t.depthFunc),
      (this.depthTest = t.depthTest),
      (this.depthWrite = t.depthWrite),
      (this.stencilWriteMask = t.stencilWriteMask),
      (this.stencilFunc = t.stencilFunc),
      (this.stencilRef = t.stencilRef),
      (this.stencilFuncMask = t.stencilFuncMask),
      (this.stencilFail = t.stencilFail),
      (this.stencilZFail = t.stencilZFail),
      (this.stencilZPass = t.stencilZPass),
      (this.stencilWrite = t.stencilWrite);
    const e = t.clippingPlanes;
    let s = null;
    if (e !== null) {
      const l = e.length;
      s = new Array(l);
      for (let h = 0; h !== l; ++h) s[h] = e[h].clone();
    }
    return (
      (this.clippingPlanes = s),
      (this.clipIntersection = t.clipIntersection),
      (this.clipShadows = t.clipShadows),
      (this.shadowSide = t.shadowSide),
      (this.colorWrite = t.colorWrite),
      (this.precision = t.precision),
      (this.polygonOffset = t.polygonOffset),
      (this.polygonOffsetFactor = t.polygonOffsetFactor),
      (this.polygonOffsetUnits = t.polygonOffsetUnits),
      (this.dithering = t.dithering),
      (this.alphaTest = t.alphaTest),
      (this.alphaHash = t.alphaHash),
      (this.alphaToCoverage = t.alphaToCoverage),
      (this.premultipliedAlpha = t.premultipliedAlpha),
      (this.forceSinglePass = t.forceSinglePass),
      (this.visible = t.visible),
      (this.toneMapped = t.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
}
class tM extends Kl {
  constructor(t) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new Qe(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Qa()),
      (this.combine = Y_),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.fog = t.fog),
      this
    );
  }
}
const Gn = new et(),
  tf = new Yt();
let GA = 0;
class ma {
  constructor(t, e, s = !1) {
    if (Array.isArray(t))
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    (this.isBufferAttribute = !0),
      Object.defineProperty(this, 'id', { value: GA++ }),
      (this.name = ''),
      (this.array = t),
      (this.itemSize = e),
      (this.count = t !== void 0 ? t.length / e : 0),
      (this.normalized = s),
      (this.usage = Iy),
      (this.updateRanges = []),
      (this.gpuType = Or),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setUsage(t) {
    return (this.usage = t), this;
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.array = new t.array.constructor(t.array)),
      (this.itemSize = t.itemSize),
      (this.count = t.count),
      (this.normalized = t.normalized),
      (this.usage = t.usage),
      (this.gpuType = t.gpuType),
      this
    );
  }
  copyAt(t, e, s) {
    (t *= this.itemSize), (s *= e.itemSize);
    for (let l = 0, h = this.itemSize; l < h; l++) this.array[t + l] = e.array[s + l];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let e = 0, s = this.count; e < s; e++)
        tf.fromBufferAttribute(this, e), tf.applyMatrix3(t), this.setXY(e, tf.x, tf.y);
    else if (this.itemSize === 3)
      for (let e = 0, s = this.count; e < s; e++)
        Gn.fromBufferAttribute(this, e), Gn.applyMatrix3(t), this.setXYZ(e, Gn.x, Gn.y, Gn.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, s = this.count; e < s; e++)
      Gn.fromBufferAttribute(this, e), Gn.applyMatrix4(t), this.setXYZ(e, Gn.x, Gn.y, Gn.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, s = this.count; e < s; e++)
      Gn.fromBufferAttribute(this, e), Gn.applyNormalMatrix(t), this.setXYZ(e, Gn.x, Gn.y, Gn.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, s = this.count; e < s; e++)
      Gn.fromBufferAttribute(this, e), Gn.transformDirection(t), this.setXYZ(e, Gn.x, Gn.y, Gn.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getComponent(t, e) {
    let s = this.array[t * this.itemSize + e];
    return this.normalized && (s = Jc(s, this.array)), s;
  }
  setComponent(t, e, s) {
    return (
      this.normalized && (s = Oi(s, this.array)), (this.array[t * this.itemSize + e] = s), this
    );
  }
  getX(t) {
    let e = this.array[t * this.itemSize];
    return this.normalized && (e = Jc(e, this.array)), e;
  }
  setX(t, e) {
    return this.normalized && (e = Oi(e, this.array)), (this.array[t * this.itemSize] = e), this;
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1];
    return this.normalized && (e = Jc(e, this.array)), e;
  }
  setY(t, e) {
    return (
      this.normalized && (e = Oi(e, this.array)), (this.array[t * this.itemSize + 1] = e), this
    );
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2];
    return this.normalized && (e = Jc(e, this.array)), e;
  }
  setZ(t, e) {
    return (
      this.normalized && (e = Oi(e, this.array)), (this.array[t * this.itemSize + 2] = e), this
    );
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3];
    return this.normalized && (e = Jc(e, this.array)), e;
  }
  setW(t, e) {
    return (
      this.normalized && (e = Oi(e, this.array)), (this.array[t * this.itemSize + 3] = e), this
    );
  }
  setXY(t, e, s) {
    return (
      (t *= this.itemSize),
      this.normalized && ((e = Oi(e, this.array)), (s = Oi(s, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = s),
      this
    );
  }
  setXYZ(t, e, s, l) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = Oi(e, this.array)), (s = Oi(s, this.array)), (l = Oi(l, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = s),
      (this.array[t + 2] = l),
      this
    );
  }
  setXYZW(t, e, s, l, h) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = Oi(e, this.array)),
        (s = Oi(s, this.array)),
        (l = Oi(l, this.array)),
        (h = Oi(h, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = s),
      (this.array[t + 2] = l),
      (this.array[t + 3] = h),
      this
    );
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return this.name !== '' && (t.name = this.name), this.usage !== Iy && (t.usage = this.usage), t;
  }
}
class eM extends ma {
  constructor(t, e, s) {
    super(new Uint16Array(t), e, s);
  }
}
class nM extends ma {
  constructor(t, e, s) {
    super(new Uint32Array(t), e, s);
  }
}
class vi extends ma {
  constructor(t, e, s) {
    super(new Float32Array(t), e, s);
  }
}
let VA = 0;
const ha = new En(),
  gm = new ci(),
  El = new et(),
  Qi = new wu(),
  nu = new wu(),
  ni = new et();
class $i extends Co {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, 'id', { value: VA++ }),
      (this.uuid = Yl()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return Array.isArray(t) ? (this.index = new (KS(t) ? nM : eM)(t, 1)) : (this.index = t), this;
  }
  setIndirect(t) {
    return (this.indirect = t), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return (this.attributes[t] = e), this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, e, s = 0) {
    this.groups.push({ start: t, count: e, materialIndex: s });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    (this.drawRange.start = t), (this.drawRange.count = e);
  }
  applyMatrix4(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), (e.needsUpdate = !0));
    const s = this.attributes.normal;
    if (s !== void 0) {
      const h = new Be().getNormalMatrix(t);
      s.applyNormalMatrix(h), (s.needsUpdate = !0);
    }
    const l = this.attributes.tangent;
    return (
      l !== void 0 && (l.transformDirection(t), (l.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(t) {
    return ha.makeRotationFromQuaternion(t), this.applyMatrix4(ha), this;
  }
  rotateX(t) {
    return ha.makeRotationX(t), this.applyMatrix4(ha), this;
  }
  rotateY(t) {
    return ha.makeRotationY(t), this.applyMatrix4(ha), this;
  }
  rotateZ(t) {
    return ha.makeRotationZ(t), this.applyMatrix4(ha), this;
  }
  translate(t, e, s) {
    return ha.makeTranslation(t, e, s), this.applyMatrix4(ha), this;
  }
  scale(t, e, s) {
    return ha.makeScale(t, e, s), this.applyMatrix4(ha), this;
  }
  lookAt(t) {
    return gm.lookAt(t), gm.updateMatrix(), this.applyMatrix4(gm.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(El).negate(),
      this.translate(El.x, El.y, El.z),
      this
    );
  }
  setFromPoints(t) {
    const e = this.getAttribute('position');
    if (e === void 0) {
      const s = [];
      for (let l = 0, h = t.length; l < h; l++) {
        const f = t[l];
        s.push(f.x, f.y, f.z || 0);
      }
      this.setAttribute('position', new vi(s, 3));
    } else {
      const s = Math.min(t.length, e.count);
      for (let l = 0; l < s; l++) {
        const h = t[l];
        e.setXYZ(l, h.x, h.y, h.z || 0);
      }
      t.length > e.count &&
        console.warn(
          'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.',
        ),
        (e.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new wu());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',
        this,
      ),
        this.boundingBox.set(new et(-1 / 0, -1 / 0, -1 / 0), new et(1 / 0, 1 / 0, 1 / 0));
      return;
    }
    if (t !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(t), e))
        for (let s = 0, l = e.length; s < l; s++) {
          const h = e[s];
          Qi.setFromBufferAttribute(h),
            this.morphTargetsRelative
              ? (ni.addVectors(this.boundingBox.min, Qi.min),
                this.boundingBox.expandByPoint(ni),
                ni.addVectors(this.boundingBox.max, Qi.max),
                this.boundingBox.expandByPoint(ni))
              : (this.boundingBox.expandByPoint(Qi.min), this.boundingBox.expandByPoint(Qi.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new jf());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',
        this,
      ),
        this.boundingSphere.set(new et(), 1 / 0);
      return;
    }
    if (t) {
      const s = this.boundingSphere.center;
      if ((Qi.setFromBufferAttribute(t), e))
        for (let h = 0, f = e.length; h < f; h++) {
          const m = e[h];
          nu.setFromBufferAttribute(m),
            this.morphTargetsRelative
              ? (ni.addVectors(Qi.min, nu.min),
                Qi.expandByPoint(ni),
                ni.addVectors(Qi.max, nu.max),
                Qi.expandByPoint(ni))
              : (Qi.expandByPoint(nu.min), Qi.expandByPoint(nu.max));
        }
      Qi.getCenter(s);
      let l = 0;
      for (let h = 0, f = t.count; h < f; h++)
        ni.fromBufferAttribute(t, h), (l = Math.max(l, s.distanceToSquared(ni)));
      if (e)
        for (let h = 0, f = e.length; h < f; h++) {
          const m = e[h],
            _ = this.morphTargetsRelative;
          for (let g = 0, x = m.count; g < x; g++)
            ni.fromBufferAttribute(m, g),
              _ && (El.fromBufferAttribute(t, g), ni.add(El)),
              (l = Math.max(l, s.distanceToSquared(ni)));
        }
      (this.boundingSphere.radius = Math.sqrt(l)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          );
    }
  }
  computeTangents() {
    const t = this.index,
      e = this.attributes;
    if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
      console.error(
        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)',
      );
      return;
    }
    const s = e.position,
      l = e.normal,
      h = e.uv;
    this.hasAttribute('tangent') === !1 &&
      this.setAttribute('tangent', new ma(new Float32Array(4 * s.count), 4));
    const f = this.getAttribute('tangent'),
      m = [],
      _ = [];
    for (let J = 0; J < s.count; J++) (m[J] = new et()), (_[J] = new et());
    const g = new et(),
      x = new et(),
      S = new et(),
      b = new Yt(),
      E = new Yt(),
      A = new Yt(),
      R = new et(),
      T = new et();
    function M(J, F, I) {
      g.fromBufferAttribute(s, J),
        x.fromBufferAttribute(s, F),
        S.fromBufferAttribute(s, I),
        b.fromBufferAttribute(h, J),
        E.fromBufferAttribute(h, F),
        A.fromBufferAttribute(h, I),
        x.sub(g),
        S.sub(g),
        E.sub(b),
        A.sub(b);
      const j = 1 / (E.x * A.y - A.x * E.y);
      isFinite(j) &&
        (R.copy(x).multiplyScalar(A.y).addScaledVector(S, -E.y).multiplyScalar(j),
        T.copy(S).multiplyScalar(E.x).addScaledVector(x, -A.x).multiplyScalar(j),
        m[J].add(R),
        m[F].add(R),
        m[I].add(R),
        _[J].add(T),
        _[F].add(T),
        _[I].add(T));
    }
    let z = this.groups;
    z.length === 0 && (z = [{ start: 0, count: t.count }]);
    for (let J = 0, F = z.length; J < F; ++J) {
      const I = z[J],
        j = I.start,
        ft = I.count;
      for (let pt = j, Mt = j + ft; pt < Mt; pt += 3)
        M(t.getX(pt + 0), t.getX(pt + 1), t.getX(pt + 2));
    }
    const P = new et(),
      D = new et(),
      W = new et(),
      Z = new et();
    function V(J) {
      W.fromBufferAttribute(l, J), Z.copy(W);
      const F = m[J];
      P.copy(F), P.sub(W.multiplyScalar(W.dot(F))).normalize(), D.crossVectors(Z, F);
      const j = D.dot(_[J]) < 0 ? -1 : 1;
      f.setXYZW(J, P.x, P.y, P.z, j);
    }
    for (let J = 0, F = z.length; J < F; ++J) {
      const I = z[J],
        j = I.start,
        ft = I.count;
      for (let pt = j, Mt = j + ft; pt < Mt; pt += 3)
        V(t.getX(pt + 0)), V(t.getX(pt + 1)), V(t.getX(pt + 2));
    }
  }
  computeVertexNormals() {
    const t = this.index,
      e = this.getAttribute('position');
    if (e !== void 0) {
      let s = this.getAttribute('normal');
      if (s === void 0)
        (s = new ma(new Float32Array(e.count * 3), 3)), this.setAttribute('normal', s);
      else for (let b = 0, E = s.count; b < E; b++) s.setXYZ(b, 0, 0, 0);
      const l = new et(),
        h = new et(),
        f = new et(),
        m = new et(),
        _ = new et(),
        g = new et(),
        x = new et(),
        S = new et();
      if (t)
        for (let b = 0, E = t.count; b < E; b += 3) {
          const A = t.getX(b + 0),
            R = t.getX(b + 1),
            T = t.getX(b + 2);
          l.fromBufferAttribute(e, A),
            h.fromBufferAttribute(e, R),
            f.fromBufferAttribute(e, T),
            x.subVectors(f, h),
            S.subVectors(l, h),
            x.cross(S),
            m.fromBufferAttribute(s, A),
            _.fromBufferAttribute(s, R),
            g.fromBufferAttribute(s, T),
            m.add(x),
            _.add(x),
            g.add(x),
            s.setXYZ(A, m.x, m.y, m.z),
            s.setXYZ(R, _.x, _.y, _.z),
            s.setXYZ(T, g.x, g.y, g.z);
        }
      else
        for (let b = 0, E = e.count; b < E; b += 3)
          l.fromBufferAttribute(e, b + 0),
            h.fromBufferAttribute(e, b + 1),
            f.fromBufferAttribute(e, b + 2),
            x.subVectors(f, h),
            S.subVectors(l, h),
            x.cross(S),
            s.setXYZ(b + 0, x.x, x.y, x.z),
            s.setXYZ(b + 1, x.x, x.y, x.z),
            s.setXYZ(b + 2, x.x, x.y, x.z);
      this.normalizeNormals(), (s.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let e = 0, s = t.count; e < s; e++)
      ni.fromBufferAttribute(t, e), ni.normalize(), t.setXYZ(e, ni.x, ni.y, ni.z);
  }
  toNonIndexed() {
    function t(m, _) {
      const g = m.array,
        x = m.itemSize,
        S = m.normalized,
        b = new g.constructor(_.length * x);
      let E = 0,
        A = 0;
      for (let R = 0, T = _.length; R < T; R++) {
        m.isInterleavedBufferAttribute ? (E = _[R] * m.data.stride + m.offset) : (E = _[R] * x);
        for (let M = 0; M < x; M++) b[A++] = g[E++];
      }
      return new ma(b, x, S);
    }
    if (this.index === null)
      return (
        console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'),
        this
      );
    const e = new $i(),
      s = this.index.array,
      l = this.attributes;
    for (const m in l) {
      const _ = l[m],
        g = t(_, s);
      e.setAttribute(m, g);
    }
    const h = this.morphAttributes;
    for (const m in h) {
      const _ = [],
        g = h[m];
      for (let x = 0, S = g.length; x < S; x++) {
        const b = g[x],
          E = t(b, s);
        _.push(E);
      }
      e.morphAttributes[m] = _;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const f = this.groups;
    for (let m = 0, _ = f.length; m < _; m++) {
      const g = f[m];
      e.addGroup(g.start, g.count, g.materialIndex);
    }
    return e;
  }
  toJSON() {
    const t = {
      metadata: { version: 4.6, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' },
    };
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      this.name !== '' && (t.name = this.name),
      Object.keys(this.userData).length > 0 && (t.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const _ = this.parameters;
      for (const g in _) _[g] !== void 0 && (t[g] = _[g]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null &&
      (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array),
      });
    const s = this.attributes;
    for (const _ in s) {
      const g = s[_];
      t.data.attributes[_] = g.toJSON(t.data);
    }
    const l = {};
    let h = !1;
    for (const _ in this.morphAttributes) {
      const g = this.morphAttributes[_],
        x = [];
      for (let S = 0, b = g.length; S < b; S++) {
        const E = g[S];
        x.push(E.toJSON(t.data));
      }
      x.length > 0 && ((l[_] = x), (h = !0));
    }
    h && ((t.data.morphAttributes = l), (t.data.morphTargetsRelative = this.morphTargetsRelative));
    const f = this.groups;
    f.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(f)));
    const m = this.boundingSphere;
    return (
      m !== null && (t.data.boundingSphere = { center: m.center.toArray(), radius: m.radius }), t
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const e = {};
    this.name = t.name;
    const s = t.index;
    s !== null && this.setIndex(s.clone());
    const l = t.attributes;
    for (const g in l) {
      const x = l[g];
      this.setAttribute(g, x.clone(e));
    }
    const h = t.morphAttributes;
    for (const g in h) {
      const x = [],
        S = h[g];
      for (let b = 0, E = S.length; b < E; b++) x.push(S[b].clone(e));
      this.morphAttributes[g] = x;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const f = t.groups;
    for (let g = 0, x = f.length; g < x; g++) {
      const S = f[g];
      this.addGroup(S.start, S.count, S.materialIndex);
    }
    const m = t.boundingBox;
    m !== null && (this.boundingBox = m.clone());
    const _ = t.boundingSphere;
    return (
      _ !== null && (this.boundingSphere = _.clone()),
      (this.drawRange.start = t.drawRange.start),
      (this.drawRange.count = t.drawRange.count),
      (this.userData = t.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
}
const Qy = new En(),
  ho = new ig(),
  ef = new jf(),
  Jy = new et(),
  nf = new et(),
  af = new et(),
  rf = new et(),
  vm = new et(),
  sf = new et(),
  $y = new et(),
  of = new et();
class bn extends ci {
  constructor(t = new $i(), e = new tM()) {
    super(),
      (this.isMesh = !0),
      (this.type = 'Mesh'),
      (this.geometry = t),
      (this.material = e),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
      t.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
      (this.material = Array.isArray(t.material) ? t.material.slice() : t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      s = Object.keys(e);
    if (s.length > 0) {
      const l = e[s[0]];
      if (l !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let h = 0, f = l.length; h < f; h++) {
          const m = l[h].name || String(h);
          this.morphTargetInfluences.push(0), (this.morphTargetDictionary[m] = h);
        }
      }
    }
  }
  getVertexPosition(t, e) {
    const s = this.geometry,
      l = s.attributes.position,
      h = s.morphAttributes.position,
      f = s.morphTargetsRelative;
    e.fromBufferAttribute(l, t);
    const m = this.morphTargetInfluences;
    if (h && m) {
      sf.set(0, 0, 0);
      for (let _ = 0, g = h.length; _ < g; _++) {
        const x = m[_],
          S = h[_];
        x !== 0 &&
          (vm.fromBufferAttribute(S, t),
          f ? sf.addScaledVector(vm, x) : sf.addScaledVector(vm.sub(e), x));
      }
      e.add(sf);
    }
    return e;
  }
  raycast(t, e) {
    const s = this.geometry,
      l = this.material,
      h = this.matrixWorld;
    l !== void 0 &&
      (s.boundingSphere === null && s.computeBoundingSphere(),
      ef.copy(s.boundingSphere),
      ef.applyMatrix4(h),
      ho.copy(t.ray).recast(t.near),
      !(
        ef.containsPoint(ho.origin) === !1 &&
        (ho.intersectSphere(ef, Jy) === null ||
          ho.origin.distanceToSquared(Jy) > (t.far - t.near) ** 2)
      ) &&
        (Qy.copy(h).invert(),
        ho.copy(t.ray).applyMatrix4(Qy),
        !(s.boundingBox !== null && ho.intersectsBox(s.boundingBox) === !1) &&
          this._computeIntersections(t, e, ho)));
  }
  _computeIntersections(t, e, s) {
    let l;
    const h = this.geometry,
      f = this.material,
      m = h.index,
      _ = h.attributes.position,
      g = h.attributes.uv,
      x = h.attributes.uv1,
      S = h.attributes.normal,
      b = h.groups,
      E = h.drawRange;
    if (m !== null)
      if (Array.isArray(f))
        for (let A = 0, R = b.length; A < R; A++) {
          const T = b[A],
            M = f[T.materialIndex],
            z = Math.max(T.start, E.start),
            P = Math.min(m.count, Math.min(T.start + T.count, E.start + E.count));
          for (let D = z, W = P; D < W; D += 3) {
            const Z = m.getX(D),
              V = m.getX(D + 1),
              J = m.getX(D + 2);
            (l = lf(this, M, t, s, g, x, S, Z, V, J)),
              l &&
                ((l.faceIndex = Math.floor(D / 3)),
                (l.face.materialIndex = T.materialIndex),
                e.push(l));
          }
        }
      else {
        const A = Math.max(0, E.start),
          R = Math.min(m.count, E.start + E.count);
        for (let T = A, M = R; T < M; T += 3) {
          const z = m.getX(T),
            P = m.getX(T + 1),
            D = m.getX(T + 2);
          (l = lf(this, f, t, s, g, x, S, z, P, D)),
            l && ((l.faceIndex = Math.floor(T / 3)), e.push(l));
        }
      }
    else if (_ !== void 0)
      if (Array.isArray(f))
        for (let A = 0, R = b.length; A < R; A++) {
          const T = b[A],
            M = f[T.materialIndex],
            z = Math.max(T.start, E.start),
            P = Math.min(_.count, Math.min(T.start + T.count, E.start + E.count));
          for (let D = z, W = P; D < W; D += 3) {
            const Z = D,
              V = D + 1,
              J = D + 2;
            (l = lf(this, M, t, s, g, x, S, Z, V, J)),
              l &&
                ((l.faceIndex = Math.floor(D / 3)),
                (l.face.materialIndex = T.materialIndex),
                e.push(l));
          }
        }
      else {
        const A = Math.max(0, E.start),
          R = Math.min(_.count, E.start + E.count);
        for (let T = A, M = R; T < M; T += 3) {
          const z = T,
            P = T + 1,
            D = T + 2;
          (l = lf(this, f, t, s, g, x, S, z, P, D)),
            l && ((l.faceIndex = Math.floor(T / 3)), e.push(l));
        }
      }
  }
}
function WA(a, t, e, s, l, h, f, m) {
  let _;
  if (
    (t.side === Ni
      ? (_ = s.intersectTriangle(f, h, l, !0, m))
      : (_ = s.intersectTriangle(l, h, f, t.side === Ns, m)),
    _ === null)
  )
    return null;
  of.copy(m), of.applyMatrix4(a.matrixWorld);
  const g = e.ray.origin.distanceTo(of);
  return g < e.near || g > e.far ? null : { distance: g, point: of.clone(), object: a };
}
function lf(a, t, e, s, l, h, f, m, _, g) {
  a.getVertexPosition(m, nf), a.getVertexPosition(_, af), a.getVertexPosition(g, rf);
  const x = WA(a, t, e, s, nf, af, rf, $y);
  if (x) {
    const S = new et();
    La.getBarycoord($y, nf, af, rf, S),
      l && (x.uv = La.getInterpolatedAttribute(l, m, _, g, S, new Yt())),
      h && (x.uv1 = La.getInterpolatedAttribute(h, m, _, g, S, new Yt())),
      f &&
        ((x.normal = La.getInterpolatedAttribute(f, m, _, g, S, new et())),
        x.normal.dot(s.direction) > 0 && x.normal.multiplyScalar(-1));
    const b = { a: m, b: _, c: g, normal: new et(), materialIndex: 0 };
    La.getNormal(nf, af, rf, b.normal), (x.face = b), (x.barycoord = S);
  }
  return x;
}
class Nr extends $i {
  constructor(t = 1, e = 1, s = 1, l = 1, h = 1, f = 1) {
    super(),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: t,
        height: e,
        depth: s,
        widthSegments: l,
        heightSegments: h,
        depthSegments: f,
      });
    const m = this;
    (l = Math.floor(l)), (h = Math.floor(h)), (f = Math.floor(f));
    const _ = [],
      g = [],
      x = [],
      S = [];
    let b = 0,
      E = 0;
    A('z', 'y', 'x', -1, -1, s, e, t, f, h, 0),
      A('z', 'y', 'x', 1, -1, s, e, -t, f, h, 1),
      A('x', 'z', 'y', 1, 1, t, s, e, l, f, 2),
      A('x', 'z', 'y', 1, -1, t, s, -e, l, f, 3),
      A('x', 'y', 'z', 1, -1, t, e, s, l, h, 4),
      A('x', 'y', 'z', -1, -1, t, e, -s, l, h, 5),
      this.setIndex(_),
      this.setAttribute('position', new vi(g, 3)),
      this.setAttribute('normal', new vi(x, 3)),
      this.setAttribute('uv', new vi(S, 2));
    function A(R, T, M, z, P, D, W, Z, V, J, F) {
      const I = D / V,
        j = W / J,
        ft = D / 2,
        pt = W / 2,
        Mt = Z / 2,
        bt = V + 1,
        X = J + 1;
      let it = 0,
        K = 0;
      const zt = new et();
      for (let N = 0; N < X; N++) {
        const Q = N * j - pt;
        for (let gt = 0; gt < bt; gt++) {
          const At = gt * I - ft;
          (zt[R] = At * z),
            (zt[T] = Q * P),
            (zt[M] = Mt),
            g.push(zt.x, zt.y, zt.z),
            (zt[R] = 0),
            (zt[T] = 0),
            (zt[M] = Z > 0 ? 1 : -1),
            x.push(zt.x, zt.y, zt.z),
            S.push(gt / V),
            S.push(1 - N / J),
            (it += 1);
        }
      }
      for (let N = 0; N < J; N++)
        for (let Q = 0; Q < V; Q++) {
          const gt = b + Q + bt * N,
            At = b + Q + bt * (N + 1),
            tt = b + (Q + 1) + bt * (N + 1),
            st = b + (Q + 1) + bt * N;
          _.push(gt, At, st), _.push(At, tt, st), (K += 6);
        }
      m.addGroup(E, K, F), (E += K), (b += it);
    }
  }
  copy(t) {
    return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
  }
  static fromJSON(t) {
    return new Nr(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
  }
}
function Vl(a) {
  const t = {};
  for (const e in a) {
    t[e] = {};
    for (const s in a[e]) {
      const l = a[e][s];
      l &&
      (l.isColor ||
        l.isMatrix3 ||
        l.isMatrix4 ||
        l.isVector2 ||
        l.isVector3 ||
        l.isVector4 ||
        l.isTexture ||
        l.isQuaternion)
        ? l.isRenderTargetTexture
          ? (console.warn(
              'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().',
            ),
            (t[e][s] = null))
          : (t[e][s] = l.clone())
        : Array.isArray(l)
          ? (t[e][s] = l.slice())
          : (t[e][s] = l);
    }
  }
  return t;
}
function wi(a) {
  const t = {};
  for (let e = 0; e < a.length; e++) {
    const s = Vl(a[e]);
    for (const l in s) t[l] = s[l];
  }
  return t;
}
function ZA(a) {
  const t = [];
  for (let e = 0; e < a.length; e++) t.push(a[e].clone());
  return t;
}
function iM(a) {
  const t = a.getRenderTarget();
  return t === null
    ? a.outputColorSpace
    : t.isXRRenderTarget === !0
      ? t.texture.colorSpace
      : en.workingColorSpace;
}
const XA = { clone: Vl, merge: wi };
var jA = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  qA = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class zs extends Kl {
  constructor(t) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = jA),
      (this.fragmentShader = qA),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      t !== void 0 && this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.fragmentShader = t.fragmentShader),
      (this.vertexShader = t.vertexShader),
      (this.uniforms = Vl(t.uniforms)),
      (this.uniformsGroups = ZA(t.uniformsGroups)),
      (this.defines = Object.assign({}, t.defines)),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.fog = t.fog),
      (this.lights = t.lights),
      (this.clipping = t.clipping),
      (this.extensions = Object.assign({}, t.extensions)),
      (this.glslVersion = t.glslVersion),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    (e.glslVersion = this.glslVersion), (e.uniforms = {});
    for (const l in this.uniforms) {
      const f = this.uniforms[l].value;
      f && f.isTexture
        ? (e.uniforms[l] = { type: 't', value: f.toJSON(t).uuid })
        : f && f.isColor
          ? (e.uniforms[l] = { type: 'c', value: f.getHex() })
          : f && f.isVector2
            ? (e.uniforms[l] = { type: 'v2', value: f.toArray() })
            : f && f.isVector3
              ? (e.uniforms[l] = { type: 'v3', value: f.toArray() })
              : f && f.isVector4
                ? (e.uniforms[l] = { type: 'v4', value: f.toArray() })
                : f && f.isMatrix3
                  ? (e.uniforms[l] = { type: 'm3', value: f.toArray() })
                  : f && f.isMatrix4
                    ? (e.uniforms[l] = { type: 'm4', value: f.toArray() })
                    : (e.uniforms[l] = { value: f });
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines),
      (e.vertexShader = this.vertexShader),
      (e.fragmentShader = this.fragmentShader),
      (e.lights = this.lights),
      (e.clipping = this.clipping);
    const s = {};
    for (const l in this.extensions) this.extensions[l] === !0 && (s[l] = !0);
    return Object.keys(s).length > 0 && (e.extensions = s), e;
  }
}
class aM extends ci {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new En()),
      (this.projectionMatrix = new En()),
      (this.projectionMatrixInverse = new En()),
      (this.coordinateSystem = Ur);
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.matrixWorldInverse.copy(t.matrixWorldInverse),
      this.projectionMatrix.copy(t.projectionMatrix),
      this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
      (this.coordinateSystem = t.coordinateSystem),
      this
    );
  }
  getWorldDirection(t) {
    return super.getWorldDirection(t).negate();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Rs = new et(),
  tx = new Yt(),
  ex = new Yt();
class da extends aM {
  constructor(t = 50, e = 1, s = 0.1, l = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = 'PerspectiveCamera'),
      (this.fov = t),
      (this.zoom = 1),
      (this.near = s),
      (this.far = l),
      (this.focus = 10),
      (this.aspect = e),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.fov = t.fov),
      (this.zoom = t.zoom),
      (this.near = t.near),
      (this.far = t.far),
      (this.focus = t.focus),
      (this.aspect = t.aspect),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      (this.filmGauge = t.filmGauge),
      (this.filmOffset = t.filmOffset),
      this
    );
  }
  setFocalLength(t) {
    const e = (0.5 * this.getFilmHeight()) / t;
    (this.fov = E_ * 2 * Math.atan(e)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const t = Math.tan(Lf * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / t;
  }
  getEffectiveFOV() {
    return E_ * 2 * Math.atan(Math.tan(Lf * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(t, e, s) {
    Rs.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      e.set(Rs.x, Rs.y).multiplyScalar(-t / Rs.z),
      Rs.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      s.set(Rs.x, Rs.y).multiplyScalar(-t / Rs.z);
  }
  getViewSize(t, e) {
    return this.getViewBounds(t, tx, ex), e.subVectors(ex, tx);
  }
  setViewOffset(t, e, s, l, h, f) {
    (this.aspect = t / e),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = s),
      (this.view.offsetY = l),
      (this.view.width = h),
      (this.view.height = f),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = this.near;
    let e = (t * Math.tan(Lf * 0.5 * this.fov)) / this.zoom,
      s = 2 * e,
      l = this.aspect * s,
      h = -0.5 * l;
    const f = this.view;
    if (this.view !== null && this.view.enabled) {
      const _ = f.fullWidth,
        g = f.fullHeight;
      (h += (f.offsetX * l) / _),
        (e -= (f.offsetY * s) / g),
        (l *= f.width / _),
        (s *= f.height / g);
    }
    const m = this.filmOffset;
    m !== 0 && (h += (t * m) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(h, h + l, e, e - s, t, this.far, this.coordinateSystem),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.fov = this.fov),
      (e.object.zoom = this.zoom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      (e.object.focus = this.focus),
      (e.object.aspect = this.aspect),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      (e.object.filmGauge = this.filmGauge),
      (e.object.filmOffset = this.filmOffset),
      e
    );
  }
}
const Tl = -90,
  wl = 1;
class YA extends ci {
  constructor(t, e, s) {
    super(),
      (this.type = 'CubeCamera'),
      (this.renderTarget = s),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const l = new da(Tl, wl, t, e);
    (l.layers = this.layers), this.add(l);
    const h = new da(Tl, wl, t, e);
    (h.layers = this.layers), this.add(h);
    const f = new da(Tl, wl, t, e);
    (f.layers = this.layers), this.add(f);
    const m = new da(Tl, wl, t, e);
    (m.layers = this.layers), this.add(m);
    const _ = new da(Tl, wl, t, e);
    (_.layers = this.layers), this.add(_);
    const g = new da(Tl, wl, t, e);
    (g.layers = this.layers), this.add(g);
  }
  updateCoordinateSystem() {
    const t = this.coordinateSystem,
      e = this.children.concat(),
      [s, l, h, f, m, _] = e;
    for (const g of e) this.remove(g);
    if (t === Ur)
      s.up.set(0, 1, 0),
        s.lookAt(1, 0, 0),
        l.up.set(0, 1, 0),
        l.lookAt(-1, 0, 0),
        h.up.set(0, 0, -1),
        h.lookAt(0, 1, 0),
        f.up.set(0, 0, 1),
        f.lookAt(0, -1, 0),
        m.up.set(0, 1, 0),
        m.lookAt(0, 0, 1),
        _.up.set(0, 1, 0),
        _.lookAt(0, 0, -1);
    else if (t === Bf)
      s.up.set(0, -1, 0),
        s.lookAt(-1, 0, 0),
        l.up.set(0, -1, 0),
        l.lookAt(1, 0, 0),
        h.up.set(0, 0, 1),
        h.lookAt(0, 1, 0),
        f.up.set(0, 0, -1),
        f.lookAt(0, -1, 0),
        m.up.set(0, -1, 0),
        m.lookAt(0, 0, 1),
        _.up.set(0, -1, 0),
        _.lookAt(0, 0, -1);
    else
      throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + t);
    for (const g of e) this.add(g), g.updateMatrixWorld();
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: s, activeMipmapLevel: l } = this;
    this.coordinateSystem !== t.coordinateSystem &&
      ((this.coordinateSystem = t.coordinateSystem), this.updateCoordinateSystem());
    const [h, f, m, _, g, x] = this.children,
      S = t.getRenderTarget(),
      b = t.getActiveCubeFace(),
      E = t.getActiveMipmapLevel(),
      A = t.xr.enabled;
    t.xr.enabled = !1;
    const R = s.texture.generateMipmaps;
    (s.texture.generateMipmaps = !1),
      t.setRenderTarget(s, 0, l),
      t.render(e, h),
      t.setRenderTarget(s, 1, l),
      t.render(e, f),
      t.setRenderTarget(s, 2, l),
      t.render(e, m),
      t.setRenderTarget(s, 3, l),
      t.render(e, _),
      t.setRenderTarget(s, 4, l),
      t.render(e, g),
      (s.texture.generateMipmaps = R),
      t.setRenderTarget(s, 5, l),
      t.render(e, x),
      t.setRenderTarget(S, b, E),
      (t.xr.enabled = A),
      (s.texture.needsPMREMUpdate = !0);
  }
}
class rM extends Ai {
  constructor(t = [], e = Fl, s, l, h, f, m, _, g, x) {
    super(t, e, s, l, h, f, m, _, g, x), (this.isCubeTexture = !0), (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
}
class KA extends Eo {
  constructor(t = 1, e = {}) {
    super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
    const s = { width: t, height: t, depth: 1 },
      l = [s, s, s, s, s, s];
    (this.texture = new rM(
      l,
      e.mapping,
      e.wrapS,
      e.wrapT,
      e.magFilter,
      e.minFilter,
      e.format,
      e.type,
      e.anisotropy,
      e.colorSpace,
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1),
      (this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : ja);
  }
  fromEquirectangularTexture(t, e) {
    (this.texture.type = e.type),
      (this.texture.colorSpace = e.colorSpace),
      (this.texture.generateMipmaps = e.generateMipmaps),
      (this.texture.minFilter = e.minFilter),
      (this.texture.magFilter = e.magFilter);
    const s = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      l = new Nr(5, 5, 5),
      h = new zs({
        name: 'CubemapFromEquirect',
        uniforms: Vl(s.uniforms),
        vertexShader: s.vertexShader,
        fragmentShader: s.fragmentShader,
        side: Ni,
        blending: Os,
      });
    h.uniforms.tEquirect.value = e;
    const f = new bn(l, h),
      m = e.minFilter;
    return (
      e.minFilter === Mo && (e.minFilter = ja),
      new YA(1, 10, this).update(t, f),
      (e.minFilter = m),
      f.geometry.dispose(),
      f.material.dispose(),
      this
    );
  }
  clear(t, e = !0, s = !0, l = !0) {
    const h = t.getRenderTarget();
    for (let f = 0; f < 6; f++) t.setRenderTarget(this, f), t.clear(e, s, l);
    t.setRenderTarget(h);
  }
}
class Ll extends ci {
  constructor() {
    super(), (this.isGroup = !0), (this.type = 'Group');
  }
}
const QA = { type: 'move' };
class ym {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Ll()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Ll()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new et()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new et())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Ll()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new et()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new et())),
      this._grip
    );
  }
  dispatchEvent(t) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(t),
      this._grip !== null && this._grip.dispatchEvent(t),
      this._hand !== null && this._hand.dispatchEvent(t),
      this
    );
  }
  connect(t) {
    if (t && t.hand) {
      const e = this._hand;
      if (e) for (const s of t.hand.values()) this._getHandJoint(e, s);
    }
    return this.dispatchEvent({ type: 'connected', data: t }), this;
  }
  disconnect(t) {
    return (
      this.dispatchEvent({ type: 'disconnected', data: t }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(t, e, s) {
    let l = null,
      h = null,
      f = null;
    const m = this._targetRay,
      _ = this._grip,
      g = this._hand;
    if (t && e.session.visibilityState !== 'visible-blurred') {
      if (g && t.hand) {
        f = !0;
        for (const R of t.hand.values()) {
          const T = e.getJointPose(R, s),
            M = this._getHandJoint(g, R);
          T !== null &&
            (M.matrix.fromArray(T.transform.matrix),
            M.matrix.decompose(M.position, M.rotation, M.scale),
            (M.matrixWorldNeedsUpdate = !0),
            (M.jointRadius = T.radius)),
            (M.visible = T !== null);
        }
        const x = g.joints['index-finger-tip'],
          S = g.joints['thumb-tip'],
          b = x.position.distanceTo(S.position),
          E = 0.02,
          A = 0.005;
        g.inputState.pinching && b > E + A
          ? ((g.inputState.pinching = !1),
            this.dispatchEvent({ type: 'pinchend', handedness: t.handedness, target: this }))
          : !g.inputState.pinching &&
            b <= E - A &&
            ((g.inputState.pinching = !0),
            this.dispatchEvent({ type: 'pinchstart', handedness: t.handedness, target: this }));
      } else
        _ !== null &&
          t.gripSpace &&
          ((h = e.getPose(t.gripSpace, s)),
          h !== null &&
            (_.matrix.fromArray(h.transform.matrix),
            _.matrix.decompose(_.position, _.rotation, _.scale),
            (_.matrixWorldNeedsUpdate = !0),
            h.linearVelocity
              ? ((_.hasLinearVelocity = !0), _.linearVelocity.copy(h.linearVelocity))
              : (_.hasLinearVelocity = !1),
            h.angularVelocity
              ? ((_.hasAngularVelocity = !0), _.angularVelocity.copy(h.angularVelocity))
              : (_.hasAngularVelocity = !1)));
      m !== null &&
        ((l = e.getPose(t.targetRaySpace, s)),
        l === null && h !== null && (l = h),
        l !== null &&
          (m.matrix.fromArray(l.transform.matrix),
          m.matrix.decompose(m.position, m.rotation, m.scale),
          (m.matrixWorldNeedsUpdate = !0),
          l.linearVelocity
            ? ((m.hasLinearVelocity = !0), m.linearVelocity.copy(l.linearVelocity))
            : (m.hasLinearVelocity = !1),
          l.angularVelocity
            ? ((m.hasAngularVelocity = !0), m.angularVelocity.copy(l.angularVelocity))
            : (m.hasAngularVelocity = !1),
          this.dispatchEvent(QA)));
    }
    return (
      m !== null && (m.visible = l !== null),
      _ !== null && (_.visible = h !== null),
      g !== null && (g.visible = f !== null),
      this
    );
  }
  _getHandJoint(t, e) {
    if (t.joints[e.jointName] === void 0) {
      const s = new Ll();
      (s.matrixAutoUpdate = !1), (s.visible = !1), (t.joints[e.jointName] = s), t.add(s);
    }
    return t.joints[e.jointName];
  }
}
class JA extends ci {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Qa()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Qa()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.background !== null && (this.background = t.background.clone()),
      t.environment !== null && (this.environment = t.environment.clone()),
      t.fog !== null && (this.fog = t.fog.clone()),
      (this.backgroundBlurriness = t.backgroundBlurriness),
      (this.backgroundIntensity = t.backgroundIntensity),
      this.backgroundRotation.copy(t.backgroundRotation),
      (this.environmentIntensity = t.environmentIntensity),
      this.environmentRotation.copy(t.environmentRotation),
      t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      this.fog !== null && (e.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity),
      (e.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (e.object.environmentIntensity = this.environmentIntensity),
      (e.object.environmentRotation = this.environmentRotation.toArray()),
      e
    );
  }
}
const xm = new et(),
  $A = new et(),
  t2 = new Be();
class Ls {
  constructor(t = new et(1, 0, 0), e = 0) {
    (this.isPlane = !0), (this.normal = t), (this.constant = e);
  }
  set(t, e) {
    return this.normal.copy(t), (this.constant = e), this;
  }
  setComponents(t, e, s, l) {
    return this.normal.set(t, e, s), (this.constant = l), this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
  }
  setFromCoplanarPoints(t, e, s) {
    const l = xm.subVectors(s, e).cross($A.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(l, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), (this.constant = t.constant), this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), (this.constant *= t), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
  }
  intersectLine(t, e) {
    const s = t.delta(xm),
      l = this.normal.dot(s);
    if (l === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
    const h = -(t.start.dot(this.normal) + this.constant) / l;
    return h < 0 || h > 1 ? null : e.copy(t.start).addScaledVector(s, h);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start),
      s = this.distanceToPoint(t.end);
    return (e < 0 && s > 0) || (s < 0 && e > 0);
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    const s = e || t2.getNormalMatrix(t),
      l = this.coplanarPoint(xm).applyMatrix4(t),
      h = this.normal.applyMatrix3(s).normalize();
    return (this.constant = -l.dot(h)), this;
  }
  translate(t) {
    return (this.constant -= t.dot(this.normal)), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const fo = new jf(),
  cf = new et();
class ag {
  constructor(t = new Ls(), e = new Ls(), s = new Ls(), l = new Ls(), h = new Ls(), f = new Ls()) {
    this.planes = [t, e, s, l, h, f];
  }
  set(t, e, s, l, h, f) {
    const m = this.planes;
    return m[0].copy(t), m[1].copy(e), m[2].copy(s), m[3].copy(l), m[4].copy(h), m[5].copy(f), this;
  }
  copy(t) {
    const e = this.planes;
    for (let s = 0; s < 6; s++) e[s].copy(t.planes[s]);
    return this;
  }
  setFromProjectionMatrix(t, e = Ur) {
    const s = this.planes,
      l = t.elements,
      h = l[0],
      f = l[1],
      m = l[2],
      _ = l[3],
      g = l[4],
      x = l[5],
      S = l[6],
      b = l[7],
      E = l[8],
      A = l[9],
      R = l[10],
      T = l[11],
      M = l[12],
      z = l[13],
      P = l[14],
      D = l[15];
    if (
      (s[0].setComponents(_ - h, b - g, T - E, D - M).normalize(),
      s[1].setComponents(_ + h, b + g, T + E, D + M).normalize(),
      s[2].setComponents(_ + f, b + x, T + A, D + z).normalize(),
      s[3].setComponents(_ - f, b - x, T - A, D - z).normalize(),
      s[4].setComponents(_ - m, b - S, T - R, D - P).normalize(),
      e === Ur)
    )
      s[5].setComponents(_ + m, b + S, T + R, D + P).normalize();
    else if (e === Bf) s[5].setComponents(m, S, R, P).normalize();
    else
      throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + e);
    return this;
  }
  intersectsObject(t) {
    if (t.boundingSphere !== void 0)
      t.boundingSphere === null && t.computeBoundingSphere(),
        fo.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
    else {
      const e = t.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(),
        fo.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
    }
    return this.intersectsSphere(fo);
  }
  intersectsSprite(t) {
    return (
      fo.center.set(0, 0, 0),
      (fo.radius = 0.7071067811865476),
      fo.applyMatrix4(t.matrixWorld),
      this.intersectsSphere(fo)
    );
  }
  intersectsSphere(t) {
    const e = this.planes,
      s = t.center,
      l = -t.radius;
    for (let h = 0; h < 6; h++) if (e[h].distanceToPoint(s) < l) return !1;
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let s = 0; s < 6; s++) {
      const l = e[s];
      if (
        ((cf.x = l.normal.x > 0 ? t.max.x : t.min.x),
        (cf.y = l.normal.y > 0 ? t.max.y : t.min.y),
        (cf.z = l.normal.z > 0 ? t.max.z : t.min.z),
        l.distanceToPoint(cf) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let s = 0; s < 6; s++) if (e[s].distanceToPoint(t) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class T_ extends Kl {
  constructor(t) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = 'PointsMaterial'),
      (this.color = new Qe(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.size = t.size),
      (this.sizeAttenuation = t.sizeAttenuation),
      (this.fog = t.fog),
      this
    );
  }
}
const nx = new En(),
  w_ = new ig(),
  uf = new jf(),
  hf = new et();
class ix extends ci {
  constructor(t = new $i(), e = new T_()) {
    super(),
      (this.isPoints = !0),
      (this.type = 'Points'),
      (this.geometry = t),
      (this.material = e),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.material = Array.isArray(t.material) ? t.material.slice() : t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  raycast(t, e) {
    const s = this.geometry,
      l = this.matrixWorld,
      h = t.params.Points.threshold,
      f = s.drawRange;
    if (
      (s.boundingSphere === null && s.computeBoundingSphere(),
      uf.copy(s.boundingSphere),
      uf.applyMatrix4(l),
      (uf.radius += h),
      t.ray.intersectsSphere(uf) === !1)
    )
      return;
    nx.copy(l).invert(), w_.copy(t.ray).applyMatrix4(nx);
    const m = h / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      _ = m * m,
      g = s.index,
      S = s.attributes.position;
    if (g !== null) {
      const b = Math.max(0, f.start),
        E = Math.min(g.count, f.start + f.count);
      for (let A = b, R = E; A < R; A++) {
        const T = g.getX(A);
        hf.fromBufferAttribute(S, T), ax(hf, T, _, l, t, e, this);
      }
    } else {
      const b = Math.max(0, f.start),
        E = Math.min(S.count, f.start + f.count);
      for (let A = b, R = E; A < R; A++) hf.fromBufferAttribute(S, A), ax(hf, A, _, l, t, e, this);
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      s = Object.keys(e);
    if (s.length > 0) {
      const l = e[s[0]];
      if (l !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let h = 0, f = l.length; h < f; h++) {
          const m = l[h].name || String(h);
          this.morphTargetInfluences.push(0), (this.morphTargetDictionary[m] = h);
        }
      }
    }
  }
}
function ax(a, t, e, s, l, h, f) {
  const m = w_.distanceSqToPoint(a);
  if (m < e) {
    const _ = new et();
    w_.closestPointToPoint(a, _), _.applyMatrix4(s);
    const g = l.ray.origin.distanceTo(_);
    if (g < l.near || g > l.far) return;
    h.push({
      distance: g,
      distanceToRay: Math.sqrt(m),
      point: _,
      index: t,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: f,
    });
  }
}
class sM extends Ai {
  constructor(t, e, s = bo, l, h, f, m = Da, _ = Da, g, x = mu) {
    if (x !== mu && x !== _u)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
      );
    super(null, l, h, f, m, _, x, s, g),
      (this.isDepthTexture = !0),
      (this.image = { width: t, height: e }),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.source = new ng(Object.assign({}, t.image))),
      (this.compareFunction = t.compareFunction),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
}
class kf extends $i {
  constructor(t = 1, e = 1, s = 1, l = 32, h = 1, f = !1, m = 0, _ = Math.PI * 2) {
    super(),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: s,
        radialSegments: l,
        heightSegments: h,
        openEnded: f,
        thetaStart: m,
        thetaLength: _,
      });
    const g = this;
    (l = Math.floor(l)), (h = Math.floor(h));
    const x = [],
      S = [],
      b = [],
      E = [];
    let A = 0;
    const R = [],
      T = s / 2;
    let M = 0;
    z(),
      f === !1 && (t > 0 && P(!0), e > 0 && P(!1)),
      this.setIndex(x),
      this.setAttribute('position', new vi(S, 3)),
      this.setAttribute('normal', new vi(b, 3)),
      this.setAttribute('uv', new vi(E, 2));
    function z() {
      const D = new et(),
        W = new et();
      let Z = 0;
      const V = (e - t) / s;
      for (let J = 0; J <= h; J++) {
        const F = [],
          I = J / h,
          j = I * (e - t) + t;
        for (let ft = 0; ft <= l; ft++) {
          const pt = ft / l,
            Mt = pt * _ + m,
            bt = Math.sin(Mt),
            X = Math.cos(Mt);
          (W.x = j * bt),
            (W.y = -I * s + T),
            (W.z = j * X),
            S.push(W.x, W.y, W.z),
            D.set(bt, V, X).normalize(),
            b.push(D.x, D.y, D.z),
            E.push(pt, 1 - I),
            F.push(A++);
        }
        R.push(F);
      }
      for (let J = 0; J < l; J++)
        for (let F = 0; F < h; F++) {
          const I = R[F][J],
            j = R[F + 1][J],
            ft = R[F + 1][J + 1],
            pt = R[F][J + 1];
          (t > 0 || F !== 0) && (x.push(I, j, pt), (Z += 3)),
            (e > 0 || F !== h - 1) && (x.push(j, ft, pt), (Z += 3));
        }
      g.addGroup(M, Z, 0), (M += Z);
    }
    function P(D) {
      const W = A,
        Z = new Yt(),
        V = new et();
      let J = 0;
      const F = D === !0 ? t : e,
        I = D === !0 ? 1 : -1;
      for (let ft = 1; ft <= l; ft++) S.push(0, T * I, 0), b.push(0, I, 0), E.push(0.5, 0.5), A++;
      const j = A;
      for (let ft = 0; ft <= l; ft++) {
        const Mt = (ft / l) * _ + m,
          bt = Math.cos(Mt),
          X = Math.sin(Mt);
        (V.x = F * X),
          (V.y = T * I),
          (V.z = F * bt),
          S.push(V.x, V.y, V.z),
          b.push(0, I, 0),
          (Z.x = bt * 0.5 + 0.5),
          (Z.y = X * 0.5 * I + 0.5),
          E.push(Z.x, Z.y),
          A++;
      }
      for (let ft = 0; ft < l; ft++) {
        const pt = W + ft,
          Mt = j + ft;
        D === !0 ? x.push(Mt, Mt + 1, pt) : x.push(Mt + 1, Mt, pt), (J += 3);
      }
      g.addGroup(M, J, D === !0 ? 1 : 2), (M += J);
    }
  }
  copy(t) {
    return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
  }
  static fromJSON(t) {
    return new kf(
      t.radiusTop,
      t.radiusBottom,
      t.height,
      t.radialSegments,
      t.heightSegments,
      t.openEnded,
      t.thetaStart,
      t.thetaLength,
    );
  }
}
class tr {
  constructor() {
    (this.type = 'Curve'),
      (this.arcLengthDivisions = 200),
      (this.needsUpdate = !1),
      (this.cacheArcLengths = null);
  }
  getPoint() {
    console.warn('THREE.Curve: .getPoint() not implemented.');
  }
  getPointAt(t, e) {
    const s = this.getUtoTmapping(t);
    return this.getPoint(s, e);
  }
  getPoints(t = 5) {
    const e = [];
    for (let s = 0; s <= t; s++) e.push(this.getPoint(s / t));
    return e;
  }
  getSpacedPoints(t = 5) {
    const e = [];
    for (let s = 0; s <= t; s++) e.push(this.getPointAt(s / t));
    return e;
  }
  getLength() {
    const t = this.getLengths();
    return t[t.length - 1];
  }
  getLengths(t = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let s,
      l = this.getPoint(0),
      h = 0;
    e.push(0);
    for (let f = 1; f <= t; f++)
      (s = this.getPoint(f / t)), (h += s.distanceTo(l)), e.push(h), (l = s);
    return (this.cacheArcLengths = e), e;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(t, e = null) {
    const s = this.getLengths();
    let l = 0;
    const h = s.length;
    let f;
    e ? (f = e) : (f = t * s[h - 1]);
    let m = 0,
      _ = h - 1,
      g;
    for (; m <= _; )
      if (((l = Math.floor(m + (_ - m) / 2)), (g = s[l] - f), g < 0)) m = l + 1;
      else if (g > 0) _ = l - 1;
      else {
        _ = l;
        break;
      }
    if (((l = _), s[l] === f)) return l / (h - 1);
    const x = s[l],
      b = s[l + 1] - x,
      E = (f - x) / b;
    return (l + E) / (h - 1);
  }
  getTangent(t, e) {
    let l = t - 1e-4,
      h = t + 1e-4;
    l < 0 && (l = 0), h > 1 && (h = 1);
    const f = this.getPoint(l),
      m = this.getPoint(h),
      _ = e || (f.isVector2 ? new Yt() : new et());
    return _.copy(m).sub(f).normalize(), _;
  }
  getTangentAt(t, e) {
    const s = this.getUtoTmapping(t);
    return this.getTangent(s, e);
  }
  computeFrenetFrames(t, e = !1) {
    const s = new et(),
      l = [],
      h = [],
      f = [],
      m = new et(),
      _ = new En();
    for (let E = 0; E <= t; E++) {
      const A = E / t;
      l[E] = this.getTangentAt(A, new et());
    }
    (h[0] = new et()), (f[0] = new et());
    let g = Number.MAX_VALUE;
    const x = Math.abs(l[0].x),
      S = Math.abs(l[0].y),
      b = Math.abs(l[0].z);
    x <= g && ((g = x), s.set(1, 0, 0)),
      S <= g && ((g = S), s.set(0, 1, 0)),
      b <= g && s.set(0, 0, 1),
      m.crossVectors(l[0], s).normalize(),
      h[0].crossVectors(l[0], m),
      f[0].crossVectors(l[0], h[0]);
    for (let E = 1; E <= t; E++) {
      if (
        ((h[E] = h[E - 1].clone()),
        (f[E] = f[E - 1].clone()),
        m.crossVectors(l[E - 1], l[E]),
        m.length() > Number.EPSILON)
      ) {
        m.normalize();
        const A = Math.acos(Ve(l[E - 1].dot(l[E]), -1, 1));
        h[E].applyMatrix4(_.makeRotationAxis(m, A));
      }
      f[E].crossVectors(l[E], h[E]);
    }
    if (e === !0) {
      let E = Math.acos(Ve(h[0].dot(h[t]), -1, 1));
      (E /= t), l[0].dot(m.crossVectors(h[0], h[t])) > 0 && (E = -E);
      for (let A = 1; A <= t; A++)
        h[A].applyMatrix4(_.makeRotationAxis(l[A], E * A)), f[A].crossVectors(l[A], h[A]);
    }
    return { tangents: l, normals: h, binormals: f };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  }
  toJSON() {
    const t = { metadata: { version: 4.6, type: 'Curve', generator: 'Curve.toJSON' } };
    return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t;
  }
  fromJSON(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  }
}
class rg extends tr {
  constructor(t = 0, e = 0, s = 1, l = 1, h = 0, f = Math.PI * 2, m = !1, _ = 0) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = 'EllipseCurve'),
      (this.aX = t),
      (this.aY = e),
      (this.xRadius = s),
      (this.yRadius = l),
      (this.aStartAngle = h),
      (this.aEndAngle = f),
      (this.aClockwise = m),
      (this.aRotation = _);
  }
  getPoint(t, e = new Yt()) {
    const s = e,
      l = Math.PI * 2;
    let h = this.aEndAngle - this.aStartAngle;
    const f = Math.abs(h) < Number.EPSILON;
    for (; h < 0; ) h += l;
    for (; h > l; ) h -= l;
    h < Number.EPSILON && (f ? (h = 0) : (h = l)),
      this.aClockwise === !0 && !f && (h === l ? (h = -l) : (h = h - l));
    const m = this.aStartAngle + t * h;
    let _ = this.aX + this.xRadius * Math.cos(m),
      g = this.aY + this.yRadius * Math.sin(m);
    if (this.aRotation !== 0) {
      const x = Math.cos(this.aRotation),
        S = Math.sin(this.aRotation),
        b = _ - this.aX,
        E = g - this.aY;
      (_ = b * x - E * S + this.aX), (g = b * S + E * x + this.aY);
    }
    return s.set(_, g);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.aX = this.aX),
      (t.aY = this.aY),
      (t.xRadius = this.xRadius),
      (t.yRadius = this.yRadius),
      (t.aStartAngle = this.aStartAngle),
      (t.aEndAngle = this.aEndAngle),
      (t.aClockwise = this.aClockwise),
      (t.aRotation = this.aRotation),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }
}
class e2 extends rg {
  constructor(t, e, s, l, h, f) {
    super(t, e, s, s, l, h, f), (this.isArcCurve = !0), (this.type = 'ArcCurve');
  }
}
function sg() {
  let a = 0,
    t = 0,
    e = 0,
    s = 0;
  function l(h, f, m, _) {
    (a = h), (t = m), (e = -3 * h + 3 * f - 2 * m - _), (s = 2 * h - 2 * f + m + _);
  }
  return {
    initCatmullRom: function (h, f, m, _, g) {
      l(f, m, g * (m - h), g * (_ - f));
    },
    initNonuniformCatmullRom: function (h, f, m, _, g, x, S) {
      let b = (f - h) / g - (m - h) / (g + x) + (m - f) / x,
        E = (m - f) / x - (_ - f) / (x + S) + (_ - m) / S;
      (b *= x), (E *= x), l(f, m, b, E);
    },
    calc: function (h) {
      const f = h * h,
        m = f * h;
      return a + t * h + e * f + s * m;
    },
  };
}
const ff = new et(),
  Sm = new sg(),
  Mm = new sg(),
  bm = new sg();
class n2 extends tr {
  constructor(t = [], e = !1, s = 'centripetal', l = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = 'CatmullRomCurve3'),
      (this.points = t),
      (this.closed = e),
      (this.curveType = s),
      (this.tension = l);
  }
  getPoint(t, e = new et()) {
    const s = e,
      l = this.points,
      h = l.length,
      f = (h - (this.closed ? 0 : 1)) * t;
    let m = Math.floor(f),
      _ = f - m;
    this.closed
      ? (m += m > 0 ? 0 : (Math.floor(Math.abs(m) / h) + 1) * h)
      : _ === 0 && m === h - 1 && ((m = h - 2), (_ = 1));
    let g, x;
    this.closed || m > 0 ? (g = l[(m - 1) % h]) : (ff.subVectors(l[0], l[1]).add(l[0]), (g = ff));
    const S = l[m % h],
      b = l[(m + 1) % h];
    if (
      (this.closed || m + 2 < h
        ? (x = l[(m + 2) % h])
        : (ff.subVectors(l[h - 1], l[h - 2]).add(l[h - 1]), (x = ff)),
      this.curveType === 'centripetal' || this.curveType === 'chordal')
    ) {
      const E = this.curveType === 'chordal' ? 0.5 : 0.25;
      let A = Math.pow(g.distanceToSquared(S), E),
        R = Math.pow(S.distanceToSquared(b), E),
        T = Math.pow(b.distanceToSquared(x), E);
      R < 1e-4 && (R = 1),
        A < 1e-4 && (A = R),
        T < 1e-4 && (T = R),
        Sm.initNonuniformCatmullRom(g.x, S.x, b.x, x.x, A, R, T),
        Mm.initNonuniformCatmullRom(g.y, S.y, b.y, x.y, A, R, T),
        bm.initNonuniformCatmullRom(g.z, S.z, b.z, x.z, A, R, T);
    } else
      this.curveType === 'catmullrom' &&
        (Sm.initCatmullRom(g.x, S.x, b.x, x.x, this.tension),
        Mm.initCatmullRom(g.y, S.y, b.y, x.y, this.tension),
        bm.initCatmullRom(g.z, S.z, b.z, x.z, this.tension));
    return s.set(Sm.calc(_), Mm.calc(_), bm.calc(_)), s;
  }
  copy(t) {
    super.copy(t), (this.points = []);
    for (let e = 0, s = t.points.length; e < s; e++) {
      const l = t.points[e];
      this.points.push(l.clone());
    }
    return (
      (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this
    );
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, s = this.points.length; e < s; e++) {
      const l = this.points[e];
      t.points.push(l.toArray());
    }
    return (t.closed = this.closed), (t.curveType = this.curveType), (t.tension = this.tension), t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = []);
    for (let e = 0, s = t.points.length; e < s; e++) {
      const l = t.points[e];
      this.points.push(new et().fromArray(l));
    }
    return (
      (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this
    );
  }
}
function rx(a, t, e, s, l) {
  const h = (s - t) * 0.5,
    f = (l - e) * 0.5,
    m = a * a,
    _ = a * m;
  return (2 * e - 2 * s + h + f) * _ + (-3 * e + 3 * s - 2 * h - f) * m + h * a + e;
}
function i2(a, t) {
  const e = 1 - a;
  return e * e * t;
}
function a2(a, t) {
  return 2 * (1 - a) * a * t;
}
function r2(a, t) {
  return a * a * t;
}
function ou(a, t, e, s) {
  return i2(a, t) + a2(a, e) + r2(a, s);
}
function s2(a, t) {
  const e = 1 - a;
  return e * e * e * t;
}
function o2(a, t) {
  const e = 1 - a;
  return 3 * e * e * a * t;
}
function l2(a, t) {
  return 3 * (1 - a) * a * a * t;
}
function c2(a, t) {
  return a * a * a * t;
}
function lu(a, t, e, s, l) {
  return s2(a, t) + o2(a, e) + l2(a, s) + c2(a, l);
}
class oM extends tr {
  constructor(t = new Yt(), e = new Yt(), s = new Yt(), l = new Yt()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = s),
      (this.v3 = l);
  }
  getPoint(t, e = new Yt()) {
    const s = e,
      l = this.v0,
      h = this.v1,
      f = this.v2,
      m = this.v3;
    return s.set(lu(t, l.x, h.x, f.x, m.x), lu(t, l.y, h.y, f.y, m.y)), s;
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }
}
class u2 extends tr {
  constructor(t = new et(), e = new et(), s = new et(), l = new et()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = s),
      (this.v3 = l);
  }
  getPoint(t, e = new et()) {
    const s = e,
      l = this.v0,
      h = this.v1,
      f = this.v2,
      m = this.v3;
    return (
      s.set(lu(t, l.x, h.x, f.x, m.x), lu(t, l.y, h.y, f.y, m.y), lu(t, l.z, h.z, f.z, m.z)), s
    );
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }
}
class lM extends tr {
  constructor(t = new Yt(), e = new Yt()) {
    super(), (this.isLineCurve = !0), (this.type = 'LineCurve'), (this.v1 = t), (this.v2 = e);
  }
  getPoint(t, e = new Yt()) {
    const s = e;
    return (
      t === 1 ? s.copy(this.v2) : (s.copy(this.v2).sub(this.v1), s.multiplyScalar(t).add(this.v1)),
      s
    );
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e = new Yt()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class h2 extends tr {
  constructor(t = new et(), e = new et()) {
    super(), (this.isLineCurve3 = !0), (this.type = 'LineCurve3'), (this.v1 = t), (this.v2 = e);
  }
  getPoint(t, e = new et()) {
    const s = e;
    return (
      t === 1 ? s.copy(this.v2) : (s.copy(this.v2).sub(this.v1), s.multiplyScalar(t).add(this.v1)),
      s
    );
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e = new et()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class cM extends tr {
  constructor(t = new Yt(), e = new Yt(), s = new Yt()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = 'QuadraticBezierCurve'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = s);
  }
  getPoint(t, e = new Yt()) {
    const s = e,
      l = this.v0,
      h = this.v1,
      f = this.v2;
    return s.set(ou(t, l.x, h.x, f.x), ou(t, l.y, h.y, f.y)), s;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }
}
class f2 extends tr {
  constructor(t = new et(), e = new et(), s = new et()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = 'QuadraticBezierCurve3'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = s);
  }
  getPoint(t, e = new et()) {
    const s = e,
      l = this.v0,
      h = this.v1,
      f = this.v2;
    return s.set(ou(t, l.x, h.x, f.x), ou(t, l.y, h.y, f.y), ou(t, l.z, h.z, f.z)), s;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }
}
class uM extends tr {
  constructor(t = []) {
    super(), (this.isSplineCurve = !0), (this.type = 'SplineCurve'), (this.points = t);
  }
  getPoint(t, e = new Yt()) {
    const s = e,
      l = this.points,
      h = (l.length - 1) * t,
      f = Math.floor(h),
      m = h - f,
      _ = l[f === 0 ? f : f - 1],
      g = l[f],
      x = l[f > l.length - 2 ? l.length - 1 : f + 1],
      S = l[f > l.length - 3 ? l.length - 1 : f + 2];
    return s.set(rx(m, _.x, g.x, x.x, S.x), rx(m, _.y, g.y, x.y, S.y)), s;
  }
  copy(t) {
    super.copy(t), (this.points = []);
    for (let e = 0, s = t.points.length; e < s; e++) {
      const l = t.points[e];
      this.points.push(l.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, s = this.points.length; e < s; e++) {
      const l = this.points[e];
      t.points.push(l.toArray());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = []);
    for (let e = 0, s = t.points.length; e < s; e++) {
      const l = t.points[e];
      this.points.push(new Yt().fromArray(l));
    }
    return this;
  }
}
var A_ = Object.freeze({
  __proto__: null,
  ArcCurve: e2,
  CatmullRomCurve3: n2,
  CubicBezierCurve: oM,
  CubicBezierCurve3: u2,
  EllipseCurve: rg,
  LineCurve: lM,
  LineCurve3: h2,
  QuadraticBezierCurve: cM,
  QuadraticBezierCurve3: f2,
  SplineCurve: uM,
});
class d2 extends tr {
  constructor() {
    super(), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1);
  }
  add(t) {
    this.curves.push(t);
  }
  closePath() {
    const t = this.curves[0].getPoint(0),
      e = this.curves[this.curves.length - 1].getPoint(1);
    if (!t.equals(e)) {
      const s = t.isVector2 === !0 ? 'LineCurve' : 'LineCurve3';
      this.curves.push(new A_[s](e, t));
    }
    return this;
  }
  getPoint(t, e) {
    const s = t * this.getLength(),
      l = this.getCurveLengths();
    let h = 0;
    for (; h < l.length; ) {
      if (l[h] >= s) {
        const f = l[h] - s,
          m = this.curves[h],
          _ = m.getLength(),
          g = _ === 0 ? 0 : 1 - f / _;
        return m.getPointAt(g, e);
      }
      h++;
    }
    return null;
  }
  getLength() {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let s = 0, l = this.curves.length; s < l; s++)
      (e += this.curves[s].getLength()), t.push(e);
    return (this.cacheLengths = t), t;
  }
  getSpacedPoints(t = 40) {
    const e = [];
    for (let s = 0; s <= t; s++) e.push(this.getPoint(s / t));
    return this.autoClose && e.push(e[0]), e;
  }
  getPoints(t = 12) {
    const e = [];
    let s;
    for (let l = 0, h = this.curves; l < h.length; l++) {
      const f = h[l],
        m = f.isEllipseCurve
          ? t * 2
          : f.isLineCurve || f.isLineCurve3
            ? 1
            : f.isSplineCurve
              ? t * f.points.length
              : t,
        _ = f.getPoints(m);
      for (let g = 0; g < _.length; g++) {
        const x = _[g];
        (s && s.equals(x)) || (e.push(x), (s = x));
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  }
  copy(t) {
    super.copy(t), (this.curves = []);
    for (let e = 0, s = t.curves.length; e < s; e++) {
      const l = t.curves[e];
      this.curves.push(l.clone());
    }
    return (this.autoClose = t.autoClose), this;
  }
  toJSON() {
    const t = super.toJSON();
    (t.autoClose = this.autoClose), (t.curves = []);
    for (let e = 0, s = this.curves.length; e < s; e++) {
      const l = this.curves[e];
      t.curves.push(l.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
    for (let e = 0, s = t.curves.length; e < s; e++) {
      const l = t.curves[e];
      this.curves.push(new A_[l.type]().fromJSON(l));
    }
    return this;
  }
}
class sx extends d2 {
  constructor(t) {
    super(), (this.type = 'Path'), (this.currentPoint = new Yt()), t && this.setFromPoints(t);
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, s = t.length; e < s; e++) this.lineTo(t[e].x, t[e].y);
    return this;
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this;
  }
  lineTo(t, e) {
    const s = new lM(this.currentPoint.clone(), new Yt(t, e));
    return this.curves.push(s), this.currentPoint.set(t, e), this;
  }
  quadraticCurveTo(t, e, s, l) {
    const h = new cM(this.currentPoint.clone(), new Yt(t, e), new Yt(s, l));
    return this.curves.push(h), this.currentPoint.set(s, l), this;
  }
  bezierCurveTo(t, e, s, l, h, f) {
    const m = new oM(this.currentPoint.clone(), new Yt(t, e), new Yt(s, l), new Yt(h, f));
    return this.curves.push(m), this.currentPoint.set(h, f), this;
  }
  splineThru(t) {
    const e = [this.currentPoint.clone()].concat(t),
      s = new uM(e);
    return this.curves.push(s), this.currentPoint.copy(t[t.length - 1]), this;
  }
  arc(t, e, s, l, h, f) {
    const m = this.currentPoint.x,
      _ = this.currentPoint.y;
    return this.absarc(t + m, e + _, s, l, h, f), this;
  }
  absarc(t, e, s, l, h, f) {
    return this.absellipse(t, e, s, s, l, h, f), this;
  }
  ellipse(t, e, s, l, h, f, m, _) {
    const g = this.currentPoint.x,
      x = this.currentPoint.y;
    return this.absellipse(t + g, e + x, s, l, h, f, m, _), this;
  }
  absellipse(t, e, s, l, h, f, m, _) {
    const g = new rg(t, e, s, l, h, f, m, _);
    if (this.curves.length > 0) {
      const S = g.getPoint(0);
      S.equals(this.currentPoint) || this.lineTo(S.x, S.y);
    }
    this.curves.push(g);
    const x = g.getPoint(1);
    return this.currentPoint.copy(x), this;
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.currentPoint = this.currentPoint.toArray()), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
  }
}
class C_ extends sx {
  constructor(t) {
    super(t), (this.uuid = Yl()), (this.type = 'Shape'), (this.holes = []);
  }
  getPointsHoles(t) {
    const e = [];
    for (let s = 0, l = this.holes.length; s < l; s++) e[s] = this.holes[s].getPoints(t);
    return e;
  }
  extractPoints(t) {
    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
  }
  copy(t) {
    super.copy(t), (this.holes = []);
    for (let e = 0, s = t.holes.length; e < s; e++) {
      const l = t.holes[e];
      this.holes.push(l.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    (t.uuid = this.uuid), (t.holes = []);
    for (let e = 0, s = this.holes.length; e < s; e++) {
      const l = this.holes[e];
      t.holes.push(l.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
    for (let e = 0, s = t.holes.length; e < s; e++) {
      const l = t.holes[e];
      this.holes.push(new sx().fromJSON(l));
    }
    return this;
  }
}
function p2(a, t, e = 2) {
  const s = t && t.length,
    l = s ? t[0] * e : a.length;
  let h = hM(a, 0, l, e, !0);
  const f = [];
  if (!h || h.next === h.prev) return f;
  let m, _, g;
  if ((s && (h = y2(a, t, h, e)), a.length > 80 * e)) {
    (m = 1 / 0), (_ = 1 / 0);
    let x = -1 / 0,
      S = -1 / 0;
    for (let b = e; b < l; b += e) {
      const E = a[b],
        A = a[b + 1];
      E < m && (m = E), A < _ && (_ = A), E > x && (x = E), A > S && (S = A);
    }
    (g = Math.max(x - m, S - _)), (g = g !== 0 ? 32767 / g : 0);
  }
  return vu(h, f, e, m, _, g, 0), f;
}
function hM(a, t, e, s, l) {
  let h;
  if (l === L2(a, t, e, s) > 0)
    for (let f = t; f < e; f += s) h = ox((f / s) | 0, a[f], a[f + 1], h);
  else for (let f = e - s; f >= t; f -= s) h = ox((f / s) | 0, a[f], a[f + 1], h);
  return h && Wl(h, h.next) && (xu(h), (h = h.next)), h;
}
function To(a, t) {
  if (!a) return a;
  t || (t = a);
  let e = a,
    s;
  do
    if (((s = !1), !e.steiner && (Wl(e, e.next) || An(e.prev, e, e.next) === 0))) {
      if ((xu(e), (e = t = e.prev), e === e.next)) break;
      s = !0;
    } else e = e.next;
  while (s || e !== t);
  return t;
}
function vu(a, t, e, s, l, h, f) {
  if (!a) return;
  !f && h && E2(a, s, l, h);
  let m = a;
  for (; a.prev !== a.next; ) {
    const _ = a.prev,
      g = a.next;
    if (h ? _2(a, s, l, h) : m2(a)) {
      t.push(_.i, a.i, g.i), xu(a), (a = g.next), (m = g.next);
      continue;
    }
    if (((a = g), a === m)) {
      f
        ? f === 1
          ? ((a = g2(To(a), t)), vu(a, t, e, s, l, h, 2))
          : f === 2 && v2(a, t, e, s, l, h)
        : vu(To(a), t, e, s, l, h, 1);
      break;
    }
  }
}
function m2(a) {
  const t = a.prev,
    e = a,
    s = a.next;
  if (An(t, e, s) >= 0) return !1;
  const l = t.x,
    h = e.x,
    f = s.x,
    m = t.y,
    _ = e.y,
    g = s.y,
    x = Math.min(l, h, f),
    S = Math.min(m, _, g),
    b = Math.max(l, h, f),
    E = Math.max(m, _, g);
  let A = s.next;
  for (; A !== t; ) {
    if (
      A.x >= x &&
      A.x <= b &&
      A.y >= S &&
      A.y <= E &&
      ru(l, m, h, _, f, g, A.x, A.y) &&
      An(A.prev, A, A.next) >= 0
    )
      return !1;
    A = A.next;
  }
  return !0;
}
function _2(a, t, e, s) {
  const l = a.prev,
    h = a,
    f = a.next;
  if (An(l, h, f) >= 0) return !1;
  const m = l.x,
    _ = h.x,
    g = f.x,
    x = l.y,
    S = h.y,
    b = f.y,
    E = Math.min(m, _, g),
    A = Math.min(x, S, b),
    R = Math.max(m, _, g),
    T = Math.max(x, S, b),
    M = R_(E, A, t, e, s),
    z = R_(R, T, t, e, s);
  let P = a.prevZ,
    D = a.nextZ;
  for (; P && P.z >= M && D && D.z <= z; ) {
    if (
      (P.x >= E &&
        P.x <= R &&
        P.y >= A &&
        P.y <= T &&
        P !== l &&
        P !== f &&
        ru(m, x, _, S, g, b, P.x, P.y) &&
        An(P.prev, P, P.next) >= 0) ||
      ((P = P.prevZ),
      D.x >= E &&
        D.x <= R &&
        D.y >= A &&
        D.y <= T &&
        D !== l &&
        D !== f &&
        ru(m, x, _, S, g, b, D.x, D.y) &&
        An(D.prev, D, D.next) >= 0)
    )
      return !1;
    D = D.nextZ;
  }
  for (; P && P.z >= M; ) {
    if (
      P.x >= E &&
      P.x <= R &&
      P.y >= A &&
      P.y <= T &&
      P !== l &&
      P !== f &&
      ru(m, x, _, S, g, b, P.x, P.y) &&
      An(P.prev, P, P.next) >= 0
    )
      return !1;
    P = P.prevZ;
  }
  for (; D && D.z <= z; ) {
    if (
      D.x >= E &&
      D.x <= R &&
      D.y >= A &&
      D.y <= T &&
      D !== l &&
      D !== f &&
      ru(m, x, _, S, g, b, D.x, D.y) &&
      An(D.prev, D, D.next) >= 0
    )
      return !1;
    D = D.nextZ;
  }
  return !0;
}
function g2(a, t) {
  let e = a;
  do {
    const s = e.prev,
      l = e.next.next;
    !Wl(s, l) &&
      dM(s, e, e.next, l) &&
      yu(s, l) &&
      yu(l, s) &&
      (t.push(s.i, e.i, l.i), xu(e), xu(e.next), (e = a = l)),
      (e = e.next);
  } while (e !== a);
  return To(e);
}
function v2(a, t, e, s, l, h) {
  let f = a;
  do {
    let m = f.next.next;
    for (; m !== f.prev; ) {
      if (f.i !== m.i && A2(f, m)) {
        let _ = pM(f, m);
        (f = To(f, f.next)), (_ = To(_, _.next)), vu(f, t, e, s, l, h, 0), vu(_, t, e, s, l, h, 0);
        return;
      }
      m = m.next;
    }
    f = f.next;
  } while (f !== a);
}
function y2(a, t, e, s) {
  const l = [];
  for (let h = 0, f = t.length; h < f; h++) {
    const m = t[h] * s,
      _ = h < f - 1 ? t[h + 1] * s : a.length,
      g = hM(a, m, _, s, !1);
    g === g.next && (g.steiner = !0), l.push(w2(g));
  }
  l.sort(x2);
  for (let h = 0; h < l.length; h++) e = S2(l[h], e);
  return e;
}
function x2(a, t) {
  let e = a.x - t.x;
  if (e === 0 && ((e = a.y - t.y), e === 0)) {
    const s = (a.next.y - a.y) / (a.next.x - a.x),
      l = (t.next.y - t.y) / (t.next.x - t.x);
    e = s - l;
  }
  return e;
}
function S2(a, t) {
  const e = M2(a, t);
  if (!e) return t;
  const s = pM(e, a);
  return To(s, s.next), To(e, e.next);
}
function M2(a, t) {
  let e = t;
  const s = a.x,
    l = a.y;
  let h = -1 / 0,
    f;
  if (Wl(a, e)) return e;
  do {
    if (Wl(a, e.next)) return e.next;
    if (l <= e.y && l >= e.next.y && e.next.y !== e.y) {
      const S = e.x + ((l - e.y) * (e.next.x - e.x)) / (e.next.y - e.y);
      if (S <= s && S > h && ((h = S), (f = e.x < e.next.x ? e : e.next), S === s)) return f;
    }
    e = e.next;
  } while (e !== t);
  if (!f) return null;
  const m = f,
    _ = f.x,
    g = f.y;
  let x = 1 / 0;
  e = f;
  do {
    if (
      s >= e.x &&
      e.x >= _ &&
      s !== e.x &&
      fM(l < g ? s : h, l, _, g, l < g ? h : s, l, e.x, e.y)
    ) {
      const S = Math.abs(l - e.y) / (s - e.x);
      yu(e, a) &&
        (S < x || (S === x && (e.x > f.x || (e.x === f.x && b2(f, e))))) &&
        ((f = e), (x = S));
    }
    e = e.next;
  } while (e !== m);
  return f;
}
function b2(a, t) {
  return An(a.prev, a, t.prev) < 0 && An(t.next, a, a.next) < 0;
}
function E2(a, t, e, s) {
  let l = a;
  do
    l.z === 0 && (l.z = R_(l.x, l.y, t, e, s)),
      (l.prevZ = l.prev),
      (l.nextZ = l.next),
      (l = l.next);
  while (l !== a);
  (l.prevZ.nextZ = null), (l.prevZ = null), T2(l);
}
function T2(a) {
  let t,
    e = 1;
  do {
    let s = a,
      l;
    a = null;
    let h = null;
    for (t = 0; s; ) {
      t++;
      let f = s,
        m = 0;
      for (let g = 0; g < e && (m++, (f = f.nextZ), !!f); g++);
      let _ = e;
      for (; m > 0 || (_ > 0 && f); )
        m !== 0 && (_ === 0 || !f || s.z <= f.z)
          ? ((l = s), (s = s.nextZ), m--)
          : ((l = f), (f = f.nextZ), _--),
          h ? (h.nextZ = l) : (a = l),
          (l.prevZ = h),
          (h = l);
      s = f;
    }
    (h.nextZ = null), (e *= 2);
  } while (t > 1);
  return a;
}
function R_(a, t, e, s, l) {
  return (
    (a = ((a - e) * l) | 0),
    (t = ((t - s) * l) | 0),
    (a = (a | (a << 8)) & 16711935),
    (a = (a | (a << 4)) & 252645135),
    (a = (a | (a << 2)) & 858993459),
    (a = (a | (a << 1)) & 1431655765),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    a | (t << 1)
  );
}
function w2(a) {
  let t = a,
    e = a;
  do (t.x < e.x || (t.x === e.x && t.y < e.y)) && (e = t), (t = t.next);
  while (t !== a);
  return e;
}
function fM(a, t, e, s, l, h, f, m) {
  return (
    (l - f) * (t - m) >= (a - f) * (h - m) &&
    (a - f) * (s - m) >= (e - f) * (t - m) &&
    (e - f) * (h - m) >= (l - f) * (s - m)
  );
}
function ru(a, t, e, s, l, h, f, m) {
  return !(a === f && t === m) && fM(a, t, e, s, l, h, f, m);
}
function A2(a, t) {
  return (
    a.next.i !== t.i &&
    a.prev.i !== t.i &&
    !C2(a, t) &&
    ((yu(a, t) && yu(t, a) && R2(a, t) && (An(a.prev, a, t.prev) || An(a, t.prev, t))) ||
      (Wl(a, t) && An(a.prev, a, a.next) > 0 && An(t.prev, t, t.next) > 0))
  );
}
function An(a, t, e) {
  return (t.y - a.y) * (e.x - t.x) - (t.x - a.x) * (e.y - t.y);
}
function Wl(a, t) {
  return a.x === t.x && a.y === t.y;
}
function dM(a, t, e, s) {
  const l = pf(An(a, t, e)),
    h = pf(An(a, t, s)),
    f = pf(An(e, s, a)),
    m = pf(An(e, s, t));
  return !!(
    (l !== h && f !== m) ||
    (l === 0 && df(a, e, t)) ||
    (h === 0 && df(a, s, t)) ||
    (f === 0 && df(e, a, s)) ||
    (m === 0 && df(e, t, s))
  );
}
function df(a, t, e) {
  return (
    t.x <= Math.max(a.x, e.x) &&
    t.x >= Math.min(a.x, e.x) &&
    t.y <= Math.max(a.y, e.y) &&
    t.y >= Math.min(a.y, e.y)
  );
}
function pf(a) {
  return a > 0 ? 1 : a < 0 ? -1 : 0;
}
function C2(a, t) {
  let e = a;
  do {
    if (e.i !== a.i && e.next.i !== a.i && e.i !== t.i && e.next.i !== t.i && dM(e, e.next, a, t))
      return !0;
    e = e.next;
  } while (e !== a);
  return !1;
}
function yu(a, t) {
  return An(a.prev, a, a.next) < 0
    ? An(a, t, a.next) >= 0 && An(a, a.prev, t) >= 0
    : An(a, t, a.prev) < 0 || An(a, a.next, t) < 0;
}
function R2(a, t) {
  let e = a,
    s = !1;
  const l = (a.x + t.x) / 2,
    h = (a.y + t.y) / 2;
  do
    e.y > h != e.next.y > h &&
      e.next.y !== e.y &&
      l < ((e.next.x - e.x) * (h - e.y)) / (e.next.y - e.y) + e.x &&
      (s = !s),
      (e = e.next);
  while (e !== a);
  return s;
}
function pM(a, t) {
  const e = L_(a.i, a.x, a.y),
    s = L_(t.i, t.x, t.y),
    l = a.next,
    h = t.prev;
  return (
    (a.next = t),
    (t.prev = a),
    (e.next = l),
    (l.prev = e),
    (s.next = e),
    (e.prev = s),
    (h.next = s),
    (s.prev = h),
    s
  );
}
function ox(a, t, e, s) {
  const l = L_(a, t, e);
  return (
    s
      ? ((l.next = s.next), (l.prev = s), (s.next.prev = l), (s.next = l))
      : ((l.prev = l), (l.next = l)),
    l
  );
}
function xu(a) {
  (a.next.prev = a.prev),
    (a.prev.next = a.next),
    a.prevZ && (a.prevZ.nextZ = a.nextZ),
    a.nextZ && (a.nextZ.prevZ = a.prevZ);
}
function L_(a, t, e) {
  return { i: a, x: t, y: e, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
}
function L2(a, t, e, s) {
  let l = 0;
  for (let h = t, f = e - s; h < e; h += s) (l += (a[f] - a[h]) * (a[h + 1] + a[f + 1])), (f = h);
  return l;
}
class P2 {
  static triangulate(t, e, s = 2) {
    return p2(t, e, s);
  }
}
class Pl {
  static area(t) {
    const e = t.length;
    let s = 0;
    for (let l = e - 1, h = 0; h < e; l = h++) s += t[l].x * t[h].y - t[h].x * t[l].y;
    return s * 0.5;
  }
  static isClockWise(t) {
    return Pl.area(t) < 0;
  }
  static triangulateShape(t, e) {
    const s = [],
      l = [],
      h = [];
    lx(t), cx(s, t);
    let f = t.length;
    e.forEach(lx);
    for (let _ = 0; _ < e.length; _++) l.push(f), (f += e[_].length), cx(s, e[_]);
    const m = P2.triangulate(s, l);
    for (let _ = 0; _ < m.length; _ += 3) h.push(m.slice(_, _ + 3));
    return h;
  }
}
function lx(a) {
  const t = a.length;
  t > 2 && a[t - 1].equals(a[0]) && a.pop();
}
function cx(a, t) {
  for (let e = 0; e < t.length; e++) a.push(t[e].x), a.push(t[e].y);
}
class Ff extends $i {
  constructor(
    t = new C_([new Yt(0.5, 0.5), new Yt(-0.5, 0.5), new Yt(-0.5, -0.5), new Yt(0.5, -0.5)]),
    e = {},
  ) {
    super(),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = { shapes: t, options: e }),
      (t = Array.isArray(t) ? t : [t]);
    const s = this,
      l = [],
      h = [];
    for (let m = 0, _ = t.length; m < _; m++) {
      const g = t[m];
      f(g);
    }
    this.setAttribute('position', new vi(l, 3)),
      this.setAttribute('uv', new vi(h, 2)),
      this.computeVertexNormals();
    function f(m) {
      const _ = [],
        g = e.curveSegments !== void 0 ? e.curveSegments : 12,
        x = e.steps !== void 0 ? e.steps : 1,
        S = e.depth !== void 0 ? e.depth : 1;
      let b = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0,
        E = e.bevelThickness !== void 0 ? e.bevelThickness : 0.2,
        A = e.bevelSize !== void 0 ? e.bevelSize : E - 0.1,
        R = e.bevelOffset !== void 0 ? e.bevelOffset : 0,
        T = e.bevelSegments !== void 0 ? e.bevelSegments : 3;
      const M = e.extrudePath,
        z = e.UVGenerator !== void 0 ? e.UVGenerator : D2;
      let P,
        D = !1,
        W,
        Z,
        V,
        J;
      M &&
        ((P = M.getSpacedPoints(x)),
        (D = !0),
        (b = !1),
        (W = M.computeFrenetFrames(x, !1)),
        (Z = new et()),
        (V = new et()),
        (J = new et())),
        b || ((T = 0), (E = 0), (A = 0), (R = 0));
      const F = m.extractPoints(g);
      let I = F.shape;
      const j = F.holes;
      if (!Pl.isClockWise(I)) {
        I = I.reverse();
        for (let G = 0, Zt = j.length; G < Zt; G++) {
          const Bt = j[G];
          Pl.isClockWise(Bt) && (j[G] = Bt.reverse());
        }
      }
      function pt(G) {
        const Bt = 10000000000000001e-36;
        let Ut = G[0];
        for (let Lt = 1; Lt <= G.length; Lt++) {
          const le = Lt % G.length,
            kt = G[le],
            H = kt.x - Ut.x,
            O = kt.y - Ut.y,
            rt = H * H + O * O,
            wt = Math.max(Math.abs(kt.x), Math.abs(kt.y), Math.abs(Ut.x), Math.abs(Ut.y)),
            Dt = Bt * wt * wt;
          if (rt <= Dt) {
            G.splice(le, 1), Lt--;
            continue;
          }
          Ut = kt;
        }
      }
      pt(I), j.forEach(pt);
      const Mt = j.length,
        bt = I;
      for (let G = 0; G < Mt; G++) {
        const Zt = j[G];
        I = I.concat(Zt);
      }
      function X(G, Zt, Bt) {
        return (
          Zt || console.error('THREE.ExtrudeGeometry: vec does not exist'),
          G.clone().addScaledVector(Zt, Bt)
        );
      }
      const it = I.length;
      function K(G, Zt, Bt) {
        let Ut, Lt, le;
        const kt = G.x - Zt.x,
          H = G.y - Zt.y,
          O = Bt.x - G.x,
          rt = Bt.y - G.y,
          wt = kt * kt + H * H,
          Dt = kt * rt - H * O;
        if (Math.abs(Dt) > Number.EPSILON) {
          const Et = Math.sqrt(wt),
            Xt = Math.sqrt(O * O + rt * rt),
            Wt = Zt.x - H / Et,
            $t = Zt.y + kt / Et,
            ce = Bt.x - rt / Xt,
            Ht = Bt.y + O / Xt,
            re = ((ce - Wt) * rt - (Ht - $t) * O) / (kt * rt - H * O);
          (Ut = Wt + kt * re - G.x), (Lt = $t + H * re - G.y);
          const pe = Ut * Ut + Lt * Lt;
          if (pe <= 2) return new Yt(Ut, Lt);
          le = Math.sqrt(pe / 2);
        } else {
          let Et = !1;
          kt > Number.EPSILON
            ? O > Number.EPSILON && (Et = !0)
            : kt < -Number.EPSILON
              ? O < -Number.EPSILON && (Et = !0)
              : Math.sign(H) === Math.sign(rt) && (Et = !0),
            Et
              ? ((Ut = -H), (Lt = kt), (le = Math.sqrt(wt)))
              : ((Ut = kt), (Lt = H), (le = Math.sqrt(wt / 2)));
        }
        return new Yt(Ut / le, Lt / le);
      }
      const zt = [];
      for (let G = 0, Zt = bt.length, Bt = Zt - 1, Ut = G + 1; G < Zt; G++, Bt++, Ut++)
        Bt === Zt && (Bt = 0), Ut === Zt && (Ut = 0), (zt[G] = K(bt[G], bt[Bt], bt[Ut]));
      const N = [];
      let Q,
        gt = zt.concat();
      for (let G = 0, Zt = Mt; G < Zt; G++) {
        const Bt = j[G];
        Q = [];
        for (let Ut = 0, Lt = Bt.length, le = Lt - 1, kt = Ut + 1; Ut < Lt; Ut++, le++, kt++)
          le === Lt && (le = 0), kt === Lt && (kt = 0), (Q[Ut] = K(Bt[Ut], Bt[le], Bt[kt]));
        N.push(Q), (gt = gt.concat(Q));
      }
      let At;
      if (T === 0) At = Pl.triangulateShape(bt, j);
      else {
        const G = [],
          Zt = [];
        for (let Bt = 0; Bt < T; Bt++) {
          const Ut = Bt / T,
            Lt = E * Math.cos((Ut * Math.PI) / 2),
            le = A * Math.sin((Ut * Math.PI) / 2) + R;
          for (let kt = 0, H = bt.length; kt < H; kt++) {
            const O = X(bt[kt], zt[kt], le);
            fe(O.x, O.y, -Lt), Ut === 0 && G.push(O);
          }
          for (let kt = 0, H = Mt; kt < H; kt++) {
            const O = j[kt];
            Q = N[kt];
            const rt = [];
            for (let wt = 0, Dt = O.length; wt < Dt; wt++) {
              const Et = X(O[wt], Q[wt], le);
              fe(Et.x, Et.y, -Lt), Ut === 0 && rt.push(Et);
            }
            Ut === 0 && Zt.push(rt);
          }
        }
        At = Pl.triangulateShape(G, Zt);
      }
      const tt = At.length,
        st = A + R;
      for (let G = 0; G < it; G++) {
        const Zt = b ? X(I[G], gt[G], st) : I[G];
        D
          ? (V.copy(W.normals[0]).multiplyScalar(Zt.x),
            Z.copy(W.binormals[0]).multiplyScalar(Zt.y),
            J.copy(P[0]).add(V).add(Z),
            fe(J.x, J.y, J.z))
          : fe(Zt.x, Zt.y, 0);
      }
      for (let G = 1; G <= x; G++)
        for (let Zt = 0; Zt < it; Zt++) {
          const Bt = b ? X(I[Zt], gt[Zt], st) : I[Zt];
          D
            ? (V.copy(W.normals[G]).multiplyScalar(Bt.x),
              Z.copy(W.binormals[G]).multiplyScalar(Bt.y),
              J.copy(P[G]).add(V).add(Z),
              fe(J.x, J.y, J.z))
            : fe(Bt.x, Bt.y, (S / x) * G);
        }
      for (let G = T - 1; G >= 0; G--) {
        const Zt = G / T,
          Bt = E * Math.cos((Zt * Math.PI) / 2),
          Ut = A * Math.sin((Zt * Math.PI) / 2) + R;
        for (let Lt = 0, le = bt.length; Lt < le; Lt++) {
          const kt = X(bt[Lt], zt[Lt], Ut);
          fe(kt.x, kt.y, S + Bt);
        }
        for (let Lt = 0, le = j.length; Lt < le; Lt++) {
          const kt = j[Lt];
          Q = N[Lt];
          for (let H = 0, O = kt.length; H < O; H++) {
            const rt = X(kt[H], Q[H], Ut);
            D ? fe(rt.x, rt.y + P[x - 1].y, P[x - 1].x + Bt) : fe(rt.x, rt.y, S + Bt);
          }
        }
      }
      _t(), It();
      function _t() {
        const G = l.length / 3;
        if (b) {
          let Zt = 0,
            Bt = it * Zt;
          for (let Ut = 0; Ut < tt; Ut++) {
            const Lt = At[Ut];
            oe(Lt[2] + Bt, Lt[1] + Bt, Lt[0] + Bt);
          }
          (Zt = x + T * 2), (Bt = it * Zt);
          for (let Ut = 0; Ut < tt; Ut++) {
            const Lt = At[Ut];
            oe(Lt[0] + Bt, Lt[1] + Bt, Lt[2] + Bt);
          }
        } else {
          for (let Zt = 0; Zt < tt; Zt++) {
            const Bt = At[Zt];
            oe(Bt[2], Bt[1], Bt[0]);
          }
          for (let Zt = 0; Zt < tt; Zt++) {
            const Bt = At[Zt];
            oe(Bt[0] + it * x, Bt[1] + it * x, Bt[2] + it * x);
          }
        }
        s.addGroup(G, l.length / 3 - G, 0);
      }
      function It() {
        const G = l.length / 3;
        let Zt = 0;
        Gt(bt, Zt), (Zt += bt.length);
        for (let Bt = 0, Ut = j.length; Bt < Ut; Bt++) {
          const Lt = j[Bt];
          Gt(Lt, Zt), (Zt += Lt.length);
        }
        s.addGroup(G, l.length / 3 - G, 1);
      }
      function Gt(G, Zt) {
        let Bt = G.length;
        for (; --Bt >= 0; ) {
          const Ut = Bt;
          let Lt = Bt - 1;
          Lt < 0 && (Lt = G.length - 1);
          for (let le = 0, kt = x + T * 2; le < kt; le++) {
            const H = it * le,
              O = it * (le + 1),
              rt = Zt + Ut + H,
              wt = Zt + Lt + H,
              Dt = Zt + Lt + O,
              Et = Zt + Ut + O;
            Ne(rt, wt, Dt, Et);
          }
        }
      }
      function fe(G, Zt, Bt) {
        _.push(G), _.push(Zt), _.push(Bt);
      }
      function oe(G, Zt, Bt) {
        Te(G), Te(Zt), Te(Bt);
        const Ut = l.length / 3,
          Lt = z.generateTopUV(s, l, Ut - 3, Ut - 2, Ut - 1);
        ye(Lt[0]), ye(Lt[1]), ye(Lt[2]);
      }
      function Ne(G, Zt, Bt, Ut) {
        Te(G), Te(Zt), Te(Ut), Te(Zt), Te(Bt), Te(Ut);
        const Lt = l.length / 3,
          le = z.generateSideWallUV(s, l, Lt - 6, Lt - 3, Lt - 2, Lt - 1);
        ye(le[0]), ye(le[1]), ye(le[3]), ye(le[1]), ye(le[2]), ye(le[3]);
      }
      function Te(G) {
        l.push(_[G * 3 + 0]), l.push(_[G * 3 + 1]), l.push(_[G * 3 + 2]);
      }
      function ye(G) {
        h.push(G.x), h.push(G.y);
      }
    }
  }
  copy(t) {
    return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
  }
  toJSON() {
    const t = super.toJSON(),
      e = this.parameters.shapes,
      s = this.parameters.options;
    return O2(e, s, t);
  }
  static fromJSON(t, e) {
    const s = [];
    for (let h = 0, f = t.shapes.length; h < f; h++) {
      const m = e[t.shapes[h]];
      s.push(m);
    }
    const l = t.options.extrudePath;
    return (
      l !== void 0 && (t.options.extrudePath = new A_[l.type]().fromJSON(l)), new Ff(s, t.options)
    );
  }
}
const D2 = {
  generateTopUV: function (a, t, e, s, l) {
    const h = t[e * 3],
      f = t[e * 3 + 1],
      m = t[s * 3],
      _ = t[s * 3 + 1],
      g = t[l * 3],
      x = t[l * 3 + 1];
    return [new Yt(h, f), new Yt(m, _), new Yt(g, x)];
  },
  generateSideWallUV: function (a, t, e, s, l, h) {
    const f = t[e * 3],
      m = t[e * 3 + 1],
      _ = t[e * 3 + 2],
      g = t[s * 3],
      x = t[s * 3 + 1],
      S = t[s * 3 + 2],
      b = t[l * 3],
      E = t[l * 3 + 1],
      A = t[l * 3 + 2],
      R = t[h * 3],
      T = t[h * 3 + 1],
      M = t[h * 3 + 2];
    return Math.abs(m - x) < Math.abs(f - g)
      ? [new Yt(f, 1 - _), new Yt(g, 1 - S), new Yt(b, 1 - A), new Yt(R, 1 - M)]
      : [new Yt(m, 1 - _), new Yt(x, 1 - S), new Yt(E, 1 - A), new Yt(T, 1 - M)];
  },
};
function O2(a, t, e) {
  if (((e.shapes = []), Array.isArray(a)))
    for (let s = 0, l = a.length; s < l; s++) {
      const h = a[s];
      e.shapes.push(h.uuid);
    }
  else e.shapes.push(a.uuid);
  return (
    (e.options = Object.assign({}, t)),
    t.extrudePath !== void 0 && (e.options.extrudePath = t.extrudePath.toJSON()),
    e
  );
}
class qf extends $i {
  constructor(t = 1, e = 1, s = 1, l = 1) {
    super(),
      (this.type = 'PlaneGeometry'),
      (this.parameters = { width: t, height: e, widthSegments: s, heightSegments: l });
    const h = t / 2,
      f = e / 2,
      m = Math.floor(s),
      _ = Math.floor(l),
      g = m + 1,
      x = _ + 1,
      S = t / m,
      b = e / _,
      E = [],
      A = [],
      R = [],
      T = [];
    for (let M = 0; M < x; M++) {
      const z = M * b - f;
      for (let P = 0; P < g; P++) {
        const D = P * S - h;
        A.push(D, -z, 0), R.push(0, 0, 1), T.push(P / m), T.push(1 - M / _);
      }
    }
    for (let M = 0; M < _; M++)
      for (let z = 0; z < m; z++) {
        const P = z + g * M,
          D = z + g * (M + 1),
          W = z + 1 + g * (M + 1),
          Z = z + 1 + g * M;
        E.push(P, D, Z), E.push(D, W, Z);
      }
    this.setIndex(E),
      this.setAttribute('position', new vi(A, 3)),
      this.setAttribute('normal', new vi(R, 3)),
      this.setAttribute('uv', new vi(T, 2));
  }
  copy(t) {
    return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
  }
  static fromJSON(t) {
    return new qf(t.width, t.height, t.widthSegments, t.heightSegments);
  }
}
class Ps extends $i {
  constructor(t = 1, e = 32, s = 16, l = 0, h = Math.PI * 2, f = 0, m = Math.PI) {
    super(),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: s,
        phiStart: l,
        phiLength: h,
        thetaStart: f,
        thetaLength: m,
      }),
      (e = Math.max(3, Math.floor(e))),
      (s = Math.max(2, Math.floor(s)));
    const _ = Math.min(f + m, Math.PI);
    let g = 0;
    const x = [],
      S = new et(),
      b = new et(),
      E = [],
      A = [],
      R = [],
      T = [];
    for (let M = 0; M <= s; M++) {
      const z = [],
        P = M / s;
      let D = 0;
      M === 0 && f === 0 ? (D = 0.5 / e) : M === s && _ === Math.PI && (D = -0.5 / e);
      for (let W = 0; W <= e; W++) {
        const Z = W / e;
        (S.x = -t * Math.cos(l + Z * h) * Math.sin(f + P * m)),
          (S.y = t * Math.cos(f + P * m)),
          (S.z = t * Math.sin(l + Z * h) * Math.sin(f + P * m)),
          A.push(S.x, S.y, S.z),
          b.copy(S).normalize(),
          R.push(b.x, b.y, b.z),
          T.push(Z + D, 1 - P),
          z.push(g++);
      }
      x.push(z);
    }
    for (let M = 0; M < s; M++)
      for (let z = 0; z < e; z++) {
        const P = x[M][z + 1],
          D = x[M][z],
          W = x[M + 1][z],
          Z = x[M + 1][z + 1];
        (M !== 0 || f > 0) && E.push(P, D, Z), (M !== s - 1 || _ < Math.PI) && E.push(D, W, Z);
      }
    this.setIndex(E),
      this.setAttribute('position', new vi(A, 3)),
      this.setAttribute('normal', new vi(R, 3)),
      this.setAttribute('uv', new vi(T, 2));
  }
  copy(t) {
    return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
  }
  static fromJSON(t) {
    return new Ps(
      t.radius,
      t.widthSegments,
      t.heightSegments,
      t.phiStart,
      t.phiLength,
      t.thetaStart,
      t.thetaLength,
    );
  }
}
class po extends Kl {
  constructor(t) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = 'MeshPhongMaterial'),
      (this.color = new Qe(16777215)),
      (this.specular = new Qe(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Qe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = qS),
      (this.normalScale = new Yt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Qa()),
      (this.combine = Y_),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      this.specular.copy(t.specular),
      (this.shininess = t.shininess),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    );
  }
}
class U2 extends Kl {
  constructor(t) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = fA),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.depthPacking = t.depthPacking),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      this
    );
  }
}
class N2 extends Kl {
  constructor(t) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = 'MeshDistanceMaterial'),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      this
    );
  }
}
const ux = {
  enabled: !1,
  files: {},
  add: function (a, t) {
    this.enabled !== !1 && (this.files[a] = t);
  },
  get: function (a) {
    if (this.enabled !== !1) return this.files[a];
  },
  remove: function (a) {
    delete this.files[a];
  },
  clear: function () {
    this.files = {};
  },
};
class z2 {
  constructor(t, e, s) {
    const l = this;
    let h = !1,
      f = 0,
      m = 0,
      _;
    const g = [];
    (this.onStart = void 0),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = s),
      (this.itemStart = function (x) {
        m++, h === !1 && l.onStart !== void 0 && l.onStart(x, f, m), (h = !0);
      }),
      (this.itemEnd = function (x) {
        f++,
          l.onProgress !== void 0 && l.onProgress(x, f, m),
          f === m && ((h = !1), l.onLoad !== void 0 && l.onLoad());
      }),
      (this.itemError = function (x) {
        l.onError !== void 0 && l.onError(x);
      }),
      (this.resolveURL = function (x) {
        return _ ? _(x) : x;
      }),
      (this.setURLModifier = function (x) {
        return (_ = x), this;
      }),
      (this.addHandler = function (x, S) {
        return g.push(x, S), this;
      }),
      (this.removeHandler = function (x) {
        const S = g.indexOf(x);
        return S !== -1 && g.splice(S, 2), this;
      }),
      (this.getHandler = function (x) {
        for (let S = 0, b = g.length; S < b; S += 2) {
          const E = g[S],
            A = g[S + 1];
          if ((E.global && (E.lastIndex = 0), E.test(x))) return A;
        }
        return null;
      });
  }
}
const I2 = new z2();
class og {
  constructor(t) {
    (this.manager = t !== void 0 ? t : I2),
      (this.crossOrigin = 'anonymous'),
      (this.withCredentials = !1),
      (this.path = ''),
      (this.resourcePath = ''),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(t, e) {
    const s = this;
    return new Promise(function (l, h) {
      s.load(t, l, e, h);
    });
  }
  parse() {}
  setCrossOrigin(t) {
    return (this.crossOrigin = t), this;
  }
  setWithCredentials(t) {
    return (this.withCredentials = t), this;
  }
  setPath(t) {
    return (this.path = t), this;
  }
  setResourcePath(t) {
    return (this.resourcePath = t), this;
  }
  setRequestHeader(t) {
    return (this.requestHeader = t), this;
  }
}
og.DEFAULT_MATERIAL_NAME = '__DEFAULT';
class B2 extends og {
  constructor(t) {
    super(t);
  }
  load(t, e, s, l) {
    this.path !== void 0 && (t = this.path + t), (t = this.manager.resolveURL(t));
    const h = this,
      f = ux.get(t);
    if (f !== void 0)
      return (
        h.manager.itemStart(t),
        setTimeout(function () {
          e && e(f), h.manager.itemEnd(t);
        }, 0),
        f
      );
    const m = gu('img');
    function _() {
      x(), ux.add(t, this), e && e(this), h.manager.itemEnd(t);
    }
    function g(S) {
      x(), l && l(S), h.manager.itemError(t), h.manager.itemEnd(t);
    }
    function x() {
      m.removeEventListener('load', _, !1), m.removeEventListener('error', g, !1);
    }
    return (
      m.addEventListener('load', _, !1),
      m.addEventListener('error', g, !1),
      t.slice(0, 5) !== 'data:' &&
        this.crossOrigin !== void 0 &&
        (m.crossOrigin = this.crossOrigin),
      h.manager.itemStart(t),
      (m.src = t),
      m
    );
  }
}
class k2 extends og {
  constructor(t) {
    super(t);
  }
  load(t, e, s, l) {
    const h = new Ai(),
      f = new B2(this.manager);
    return (
      f.setCrossOrigin(this.crossOrigin),
      f.setPath(this.path),
      f.load(
        t,
        function (m) {
          (h.image = m), (h.needsUpdate = !0), e !== void 0 && e(h);
        },
        s,
        l,
      ),
      h
    );
  }
}
class mM extends ci {
  constructor(t, e = 1) {
    super(),
      (this.isLight = !0),
      (this.type = 'Light'),
      (this.color = new Qe(t)),
      (this.intensity = e);
  }
  dispose() {}
  copy(t, e) {
    return super.copy(t, e), this.color.copy(t.color), (this.intensity = t.intensity), this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.color = this.color.getHex()),
      (e.object.intensity = this.intensity),
      this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (e.object.distance = this.distance),
      this.angle !== void 0 && (e.object.angle = this.angle),
      this.decay !== void 0 && (e.object.decay = this.decay),
      this.penumbra !== void 0 && (e.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (e.object.target = this.target.uuid),
      e
    );
  }
}
const Em = new En(),
  hx = new et(),
  fx = new et();
class F2 {
  constructor(t) {
    (this.camera = t),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Yt(512, 512)),
      (this.mapType = Ka),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new En()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new ag()),
      (this._frameExtents = new Yt(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Un(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t) {
    const e = this.camera,
      s = this.matrix;
    hx.setFromMatrixPosition(t.matrixWorld),
      e.position.copy(hx),
      fx.setFromMatrixPosition(t.target.matrixWorld),
      e.lookAt(fx),
      e.updateMatrixWorld(),
      Em.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Em),
      s.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      s.multiply(Em);
  }
  getViewport(t) {
    return this._viewports[t];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t) {
    return (
      (this.camera = t.camera.clone()),
      (this.intensity = t.intensity),
      (this.bias = t.bias),
      (this.radius = t.radius),
      (this.autoUpdate = t.autoUpdate),
      (this.needsUpdate = t.needsUpdate),
      (this.normalBias = t.normalBias),
      (this.blurSamples = t.blurSamples),
      this.mapSize.copy(t.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = {};
    return (
      this.intensity !== 1 && (t.intensity = this.intensity),
      this.bias !== 0 && (t.bias = this.bias),
      this.normalBias !== 0 && (t.normalBias = this.normalBias),
      this.radius !== 1 && (t.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()),
      (t.camera = this.camera.toJSON(!1).object),
      delete t.camera.matrix,
      t
    );
  }
}
class _M extends aM {
  constructor(t = -1, e = 1, s = 1, l = -1, h = 0.1, f = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = t),
      (this.right = e),
      (this.top = s),
      (this.bottom = l),
      (this.near = h),
      (this.far = f),
      this.updateProjectionMatrix();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.left = t.left),
      (this.right = t.right),
      (this.top = t.top),
      (this.bottom = t.bottom),
      (this.near = t.near),
      (this.far = t.far),
      (this.zoom = t.zoom),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      this
    );
  }
  setViewOffset(t, e, s, l, h, f) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = s),
      (this.view.offsetY = l),
      (this.view.width = h),
      (this.view.height = f),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom),
      e = (this.top - this.bottom) / (2 * this.zoom),
      s = (this.right + this.left) / 2,
      l = (this.top + this.bottom) / 2;
    let h = s - t,
      f = s + t,
      m = l + e,
      _ = l - e;
    if (this.view !== null && this.view.enabled) {
      const g = (this.right - this.left) / this.view.fullWidth / this.zoom,
        x = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (h += g * this.view.offsetX),
        (f = h + g * this.view.width),
        (m -= x * this.view.offsetY),
        (_ = m - x * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(h, f, m, _, this.near, this.far, this.coordinateSystem),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.zoom = this.zoom),
      (e.object.left = this.left),
      (e.object.right = this.right),
      (e.object.top = this.top),
      (e.object.bottom = this.bottom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      e
    );
  }
}
class H2 extends F2 {
  constructor() {
    super(new _M(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class G2 extends mM {
  constructor(t, e) {
    super(t, e),
      (this.isDirectionalLight = !0),
      (this.type = 'DirectionalLight'),
      this.position.copy(ci.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new ci()),
      (this.shadow = new H2());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return super.copy(t), (this.target = t.target.clone()), (this.shadow = t.shadow.clone()), this;
  }
}
class V2 extends mM {
  constructor(t, e) {
    super(t, e), (this.isAmbientLight = !0), (this.type = 'AmbientLight');
  }
}
class W2 extends da {
  constructor(t = []) {
    super(), (this.isArrayCamera = !0), (this.isMultiViewCamera = !1), (this.cameras = t);
  }
}
class dx {
  constructor(t = 1, e = 0, s = 0) {
    (this.radius = t), (this.phi = e), (this.theta = s);
  }
  set(t, e, s) {
    return (this.radius = t), (this.phi = e), (this.theta = s), this;
  }
  copy(t) {
    return (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this;
  }
  makeSafe() {
    return (this.phi = Ve(this.phi, 1e-6, Math.PI - 1e-6)), this;
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  }
  setFromCartesianCoords(t, e, s) {
    return (
      (this.radius = Math.sqrt(t * t + e * e + s * s)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(t, s)), (this.phi = Math.acos(Ve(e / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Z2 extends Co {
  constructor(t, e = null) {
    super(),
      (this.object = t),
      (this.domElement = e),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect(t) {
    if (t === void 0) {
      console.warn('THREE.Controls: connect() now requires an element.');
      return;
    }
    this.domElement !== null && this.disconnect(), (this.domElement = t);
  }
  disconnect() {}
  dispose() {}
  update() {}
}
function px(a, t, e, s) {
  const l = X2(s);
  switch (e) {
    case VS:
      return a * t;
    case ZS:
      return ((a * t) / l.components) * l.byteLength;
    case $_:
      return ((a * t) / l.components) * l.byteLength;
    case XS:
      return ((a * t * 2) / l.components) * l.byteLength;
    case tg:
      return ((a * t * 2) / l.components) * l.byteLength;
    case WS:
      return ((a * t * 3) / l.components) * l.byteLength;
    case Pa:
      return ((a * t * 4) / l.components) * l.byteLength;
    case eg:
      return ((a * t * 4) / l.components) * l.byteLength;
    case Tf:
    case wf:
      return Math.floor((a + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case Af:
    case Cf:
      return Math.floor((a + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case $m:
    case e_:
      return (Math.max(a, 16) * Math.max(t, 8)) / 4;
    case Jm:
    case t_:
      return (Math.max(a, 8) * Math.max(t, 8)) / 2;
    case n_:
    case i_:
      return Math.floor((a + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case a_:
      return Math.floor((a + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case r_:
      return Math.floor((a + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case s_:
      return Math.floor((a + 4) / 5) * Math.floor((t + 3) / 4) * 16;
    case o_:
      return Math.floor((a + 4) / 5) * Math.floor((t + 4) / 5) * 16;
    case l_:
      return Math.floor((a + 5) / 6) * Math.floor((t + 4) / 5) * 16;
    case c_:
      return Math.floor((a + 5) / 6) * Math.floor((t + 5) / 6) * 16;
    case u_:
      return Math.floor((a + 7) / 8) * Math.floor((t + 4) / 5) * 16;
    case h_:
      return Math.floor((a + 7) / 8) * Math.floor((t + 5) / 6) * 16;
    case f_:
      return Math.floor((a + 7) / 8) * Math.floor((t + 7) / 8) * 16;
    case d_:
      return Math.floor((a + 9) / 10) * Math.floor((t + 4) / 5) * 16;
    case p_:
      return Math.floor((a + 9) / 10) * Math.floor((t + 5) / 6) * 16;
    case m_:
      return Math.floor((a + 9) / 10) * Math.floor((t + 7) / 8) * 16;
    case __:
      return Math.floor((a + 9) / 10) * Math.floor((t + 9) / 10) * 16;
    case g_:
      return Math.floor((a + 11) / 12) * Math.floor((t + 9) / 10) * 16;
    case v_:
      return Math.floor((a + 11) / 12) * Math.floor((t + 11) / 12) * 16;
    case Rf:
    case y_:
    case x_:
      return Math.ceil(a / 4) * Math.ceil(t / 4) * 16;
    case jS:
    case S_:
      return Math.ceil(a / 4) * Math.ceil(t / 4) * 8;
    case M_:
    case b_:
      return Math.ceil(a / 4) * Math.ceil(t / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${e} format.`);
}
function X2(a) {
  switch (a) {
    case Ka:
    case FS:
      return { byteLength: 1, components: 1 };
    case du:
    case HS:
    case Tu:
      return { byteLength: 2, components: 1 };
    case Q_:
    case J_:
      return { byteLength: 2, components: 4 };
    case bo:
    case K_:
    case Or:
      return { byteLength: 4, components: 1 };
    case GS:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${a}.`);
}
typeof __THREE_DEVTOOLS__ < 'u' &&
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: q_ } }));
typeof window < 'u' &&
  (window.__THREE__
    ? console.warn('WARNING: Multiple instances of Three.js being imported.')
    : (window.__THREE__ = q_));
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function gM() {
  let a = null,
    t = !1,
    e = null,
    s = null;
  function l(h, f) {
    e(h, f), (s = a.requestAnimationFrame(l));
  }
  return {
    start: function () {
      t !== !0 && e !== null && ((s = a.requestAnimationFrame(l)), (t = !0));
    },
    stop: function () {
      a.cancelAnimationFrame(s), (t = !1);
    },
    setAnimationLoop: function (h) {
      e = h;
    },
    setContext: function (h) {
      a = h;
    },
  };
}
function j2(a) {
  const t = new WeakMap();
  function e(m, _) {
    const g = m.array,
      x = m.usage,
      S = g.byteLength,
      b = a.createBuffer();
    a.bindBuffer(_, b), a.bufferData(_, g, x), m.onUploadCallback();
    let E;
    if (g instanceof Float32Array) E = a.FLOAT;
    else if (g instanceof Uint16Array)
      m.isFloat16BufferAttribute ? (E = a.HALF_FLOAT) : (E = a.UNSIGNED_SHORT);
    else if (g instanceof Int16Array) E = a.SHORT;
    else if (g instanceof Uint32Array) E = a.UNSIGNED_INT;
    else if (g instanceof Int32Array) E = a.INT;
    else if (g instanceof Int8Array) E = a.BYTE;
    else if (g instanceof Uint8Array) E = a.UNSIGNED_BYTE;
    else if (g instanceof Uint8ClampedArray) E = a.UNSIGNED_BYTE;
    else throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + g);
    return {
      buffer: b,
      type: E,
      bytesPerElement: g.BYTES_PER_ELEMENT,
      version: m.version,
      size: S,
    };
  }
  function s(m, _, g) {
    const x = _.array,
      S = _.updateRanges;
    if ((a.bindBuffer(g, m), S.length === 0)) a.bufferSubData(g, 0, x);
    else {
      S.sort((E, A) => E.start - A.start);
      let b = 0;
      for (let E = 1; E < S.length; E++) {
        const A = S[b],
          R = S[E];
        R.start <= A.start + A.count + 1
          ? (A.count = Math.max(A.count, R.start + R.count - A.start))
          : (++b, (S[b] = R));
      }
      S.length = b + 1;
      for (let E = 0, A = S.length; E < A; E++) {
        const R = S[E];
        a.bufferSubData(g, R.start * x.BYTES_PER_ELEMENT, x, R.start, R.count);
      }
      _.clearUpdateRanges();
    }
    _.onUploadCallback();
  }
  function l(m) {
    return m.isInterleavedBufferAttribute && (m = m.data), t.get(m);
  }
  function h(m) {
    m.isInterleavedBufferAttribute && (m = m.data);
    const _ = t.get(m);
    _ && (a.deleteBuffer(_.buffer), t.delete(m));
  }
  function f(m, _) {
    if ((m.isInterleavedBufferAttribute && (m = m.data), m.isGLBufferAttribute)) {
      const x = t.get(m);
      (!x || x.version < m.version) &&
        t.set(m, {
          buffer: m.buffer,
          type: m.type,
          bytesPerElement: m.elementSize,
          version: m.version,
        });
      return;
    }
    const g = t.get(m);
    if (g === void 0) t.set(m, e(m, _));
    else if (g.version < m.version) {
      if (g.size !== m.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        );
      s(g.buffer, m, _), (g.version = m.version);
    }
  }
  return { get: l, remove: h, update: f };
}
var q2 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  Y2 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  K2 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  Q2 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  J2 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  $2 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  tC = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  eC = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  nC = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  iC = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  aC = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  rC = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  sC = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  oC = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  lC = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  cC = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  uC = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  hC = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  fC = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  dC = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  pC = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  mC = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  _C = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  gC = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  vC = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  yC = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  xC = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  SC = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  MC = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  bC = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  EC = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
  TC = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  wC = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  AC = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  CC = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  RC = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  LC = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  PC = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  DC = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  OC = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  UC = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  NC = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  zC = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  IC = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  BC = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  kC = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  FC = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  HC = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  GC = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  VC = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  WC = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  ZC = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  XC = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  jC = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  qC = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  YC = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  KC = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  QC = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  JC = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  $C = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  tR = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  eR = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  nR = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  iR = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  aR = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  rR = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  sR = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  oR = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  lR = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  cR = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  uR = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  hR = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  fR = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  dR = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  pR = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  mR = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  _R = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  gR = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  vR = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  yR = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  xR = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  SR = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  MR = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  bR = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  ER = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  TR = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  wR = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  AR = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  CR = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  RR = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  LR = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  PR = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  DR = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  OR = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  UR = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  NR = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  zR = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  IR = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  BR = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  kR = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  FR = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  HR = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  GR = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  VR = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  WR = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  ZR = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  XR = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const jR = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  qR = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  YR = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  KR = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  QR = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  JR = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  $R = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  t3 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  e3 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  n3 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  i3 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  a3 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  r3 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  s3 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  o3 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  l3 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  c3 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  u3 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  h3 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  f3 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  d3 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  p3 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  m3 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  _3 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  g3 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  v3 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  y3 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  x3 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  S3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  M3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  b3 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  E3 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  T3 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  w3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Fe = {
    alphahash_fragment: q2,
    alphahash_pars_fragment: Y2,
    alphamap_fragment: K2,
    alphamap_pars_fragment: Q2,
    alphatest_fragment: J2,
    alphatest_pars_fragment: $2,
    aomap_fragment: tC,
    aomap_pars_fragment: eC,
    batching_pars_vertex: nC,
    batching_vertex: iC,
    begin_vertex: aC,
    beginnormal_vertex: rC,
    bsdfs: sC,
    iridescence_fragment: oC,
    bumpmap_pars_fragment: lC,
    clipping_planes_fragment: cC,
    clipping_planes_pars_fragment: uC,
    clipping_planes_pars_vertex: hC,
    clipping_planes_vertex: fC,
    color_fragment: dC,
    color_pars_fragment: pC,
    color_pars_vertex: mC,
    color_vertex: _C,
    common: gC,
    cube_uv_reflection_fragment: vC,
    defaultnormal_vertex: yC,
    displacementmap_pars_vertex: xC,
    displacementmap_vertex: SC,
    emissivemap_fragment: MC,
    emissivemap_pars_fragment: bC,
    colorspace_fragment: EC,
    colorspace_pars_fragment: TC,
    envmap_fragment: wC,
    envmap_common_pars_fragment: AC,
    envmap_pars_fragment: CC,
    envmap_pars_vertex: RC,
    envmap_physical_pars_fragment: FC,
    envmap_vertex: LC,
    fog_vertex: PC,
    fog_pars_vertex: DC,
    fog_fragment: OC,
    fog_pars_fragment: UC,
    gradientmap_pars_fragment: NC,
    lightmap_pars_fragment: zC,
    lights_lambert_fragment: IC,
    lights_lambert_pars_fragment: BC,
    lights_pars_begin: kC,
    lights_toon_fragment: HC,
    lights_toon_pars_fragment: GC,
    lights_phong_fragment: VC,
    lights_phong_pars_fragment: WC,
    lights_physical_fragment: ZC,
    lights_physical_pars_fragment: XC,
    lights_fragment_begin: jC,
    lights_fragment_maps: qC,
    lights_fragment_end: YC,
    logdepthbuf_fragment: KC,
    logdepthbuf_pars_fragment: QC,
    logdepthbuf_pars_vertex: JC,
    logdepthbuf_vertex: $C,
    map_fragment: tR,
    map_pars_fragment: eR,
    map_particle_fragment: nR,
    map_particle_pars_fragment: iR,
    metalnessmap_fragment: aR,
    metalnessmap_pars_fragment: rR,
    morphinstance_vertex: sR,
    morphcolor_vertex: oR,
    morphnormal_vertex: lR,
    morphtarget_pars_vertex: cR,
    morphtarget_vertex: uR,
    normal_fragment_begin: hR,
    normal_fragment_maps: fR,
    normal_pars_fragment: dR,
    normal_pars_vertex: pR,
    normal_vertex: mR,
    normalmap_pars_fragment: _R,
    clearcoat_normal_fragment_begin: gR,
    clearcoat_normal_fragment_maps: vR,
    clearcoat_pars_fragment: yR,
    iridescence_pars_fragment: xR,
    opaque_fragment: SR,
    packing: MR,
    premultiplied_alpha_fragment: bR,
    project_vertex: ER,
    dithering_fragment: TR,
    dithering_pars_fragment: wR,
    roughnessmap_fragment: AR,
    roughnessmap_pars_fragment: CR,
    shadowmap_pars_fragment: RR,
    shadowmap_pars_vertex: LR,
    shadowmap_vertex: PR,
    shadowmask_pars_fragment: DR,
    skinbase_vertex: OR,
    skinning_pars_vertex: UR,
    skinning_vertex: NR,
    skinnormal_vertex: zR,
    specularmap_fragment: IR,
    specularmap_pars_fragment: BR,
    tonemapping_fragment: kR,
    tonemapping_pars_fragment: FR,
    transmission_fragment: HR,
    transmission_pars_fragment: GR,
    uv_pars_fragment: VR,
    uv_pars_vertex: WR,
    uv_vertex: ZR,
    worldpos_vertex: XR,
    background_vert: jR,
    background_frag: qR,
    backgroundCube_vert: YR,
    backgroundCube_frag: KR,
    cube_vert: QR,
    cube_frag: JR,
    depth_vert: $R,
    depth_frag: t3,
    distanceRGBA_vert: e3,
    distanceRGBA_frag: n3,
    equirect_vert: i3,
    equirect_frag: a3,
    linedashed_vert: r3,
    linedashed_frag: s3,
    meshbasic_vert: o3,
    meshbasic_frag: l3,
    meshlambert_vert: c3,
    meshlambert_frag: u3,
    meshmatcap_vert: h3,
    meshmatcap_frag: f3,
    meshnormal_vert: d3,
    meshnormal_frag: p3,
    meshphong_vert: m3,
    meshphong_frag: _3,
    meshphysical_vert: g3,
    meshphysical_frag: v3,
    meshtoon_vert: y3,
    meshtoon_frag: x3,
    points_vert: S3,
    points_frag: M3,
    shadow_vert: b3,
    shadow_frag: E3,
    sprite_vert: T3,
    sprite_frag: w3,
  },
  ee = {
    common: {
      diffuse: { value: new Qe(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Be() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Be() },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Be() } },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new Be() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Be() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Be() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Be() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Be() },
      normalScale: { value: new Yt(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Be() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Be() } },
    metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Be() } },
    roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Be() } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Qe(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: { direction: {}, color: {} } },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
      rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Qe(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Be() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Be() },
    },
    sprite: {
      diffuse: { value: new Qe(16777215) },
      opacity: { value: 1 },
      center: { value: new Yt(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Be() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Be() },
      alphaTest: { value: 0 },
    },
  },
  Xa = {
    basic: {
      uniforms: wi([ee.common, ee.specularmap, ee.envmap, ee.aomap, ee.lightmap, ee.fog]),
      vertexShader: Fe.meshbasic_vert,
      fragmentShader: Fe.meshbasic_frag,
    },
    lambert: {
      uniforms: wi([
        ee.common,
        ee.specularmap,
        ee.envmap,
        ee.aomap,
        ee.lightmap,
        ee.emissivemap,
        ee.bumpmap,
        ee.normalmap,
        ee.displacementmap,
        ee.fog,
        ee.lights,
        { emissive: { value: new Qe(0) } },
      ]),
      vertexShader: Fe.meshlambert_vert,
      fragmentShader: Fe.meshlambert_frag,
    },
    phong: {
      uniforms: wi([
        ee.common,
        ee.specularmap,
        ee.envmap,
        ee.aomap,
        ee.lightmap,
        ee.emissivemap,
        ee.bumpmap,
        ee.normalmap,
        ee.displacementmap,
        ee.fog,
        ee.lights,
        {
          emissive: { value: new Qe(0) },
          specular: { value: new Qe(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Fe.meshphong_vert,
      fragmentShader: Fe.meshphong_frag,
    },
    standard: {
      uniforms: wi([
        ee.common,
        ee.envmap,
        ee.aomap,
        ee.lightmap,
        ee.emissivemap,
        ee.bumpmap,
        ee.normalmap,
        ee.displacementmap,
        ee.roughnessmap,
        ee.metalnessmap,
        ee.fog,
        ee.lights,
        {
          emissive: { value: new Qe(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Fe.meshphysical_vert,
      fragmentShader: Fe.meshphysical_frag,
    },
    toon: {
      uniforms: wi([
        ee.common,
        ee.aomap,
        ee.lightmap,
        ee.emissivemap,
        ee.bumpmap,
        ee.normalmap,
        ee.displacementmap,
        ee.gradientmap,
        ee.fog,
        ee.lights,
        { emissive: { value: new Qe(0) } },
      ]),
      vertexShader: Fe.meshtoon_vert,
      fragmentShader: Fe.meshtoon_frag,
    },
    matcap: {
      uniforms: wi([
        ee.common,
        ee.bumpmap,
        ee.normalmap,
        ee.displacementmap,
        ee.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Fe.meshmatcap_vert,
      fragmentShader: Fe.meshmatcap_frag,
    },
    points: {
      uniforms: wi([ee.points, ee.fog]),
      vertexShader: Fe.points_vert,
      fragmentShader: Fe.points_frag,
    },
    dashed: {
      uniforms: wi([
        ee.common,
        ee.fog,
        { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } },
      ]),
      vertexShader: Fe.linedashed_vert,
      fragmentShader: Fe.linedashed_frag,
    },
    depth: {
      uniforms: wi([ee.common, ee.displacementmap]),
      vertexShader: Fe.depth_vert,
      fragmentShader: Fe.depth_frag,
    },
    normal: {
      uniforms: wi([
        ee.common,
        ee.bumpmap,
        ee.normalmap,
        ee.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Fe.meshnormal_vert,
      fragmentShader: Fe.meshnormal_frag,
    },
    sprite: {
      uniforms: wi([ee.sprite, ee.fog]),
      vertexShader: Fe.sprite_vert,
      fragmentShader: Fe.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Be() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Fe.background_vert,
      fragmentShader: Fe.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new Be() },
      },
      vertexShader: Fe.backgroundCube_vert,
      fragmentShader: Fe.backgroundCube_frag,
    },
    cube: {
      uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
      vertexShader: Fe.cube_vert,
      fragmentShader: Fe.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Fe.equirect_vert,
      fragmentShader: Fe.equirect_frag,
    },
    distanceRGBA: {
      uniforms: wi([
        ee.common,
        ee.displacementmap,
        {
          referencePosition: { value: new et() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Fe.distanceRGBA_vert,
      fragmentShader: Fe.distanceRGBA_frag,
    },
    shadow: {
      uniforms: wi([ee.lights, ee.fog, { color: { value: new Qe(0) }, opacity: { value: 1 } }]),
      vertexShader: Fe.shadow_vert,
      fragmentShader: Fe.shadow_frag,
    },
  };
Xa.physical = {
  uniforms: wi([
    Xa.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Be() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Be() },
      clearcoatNormalScale: { value: new Yt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Be() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Be() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Be() },
      sheen: { value: 0 },
      sheenColor: { value: new Qe(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Be() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Be() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Be() },
      transmissionSamplerSize: { value: new Yt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Be() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Qe(0) },
      specularColor: { value: new Qe(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Be() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Be() },
      anisotropyVector: { value: new Yt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Be() },
    },
  ]),
  vertexShader: Fe.meshphysical_vert,
  fragmentShader: Fe.meshphysical_frag,
};
const mf = { r: 0, b: 0, g: 0 },
  mo = new Qa(),
  A3 = new En();
function C3(a, t, e, s, l, h, f) {
  const m = new Qe(0);
  let _ = h === !0 ? 0 : 1,
    g,
    x,
    S = null,
    b = 0,
    E = null;
  function A(P) {
    let D = P.isScene === !0 ? P.background : null;
    return D && D.isTexture && (D = (P.backgroundBlurriness > 0 ? e : t).get(D)), D;
  }
  function R(P) {
    let D = !1;
    const W = A(P);
    W === null ? M(m, _) : W && W.isColor && (M(W, 1), (D = !0));
    const Z = a.xr.getEnvironmentBlendMode();
    Z === 'additive'
      ? s.buffers.color.setClear(0, 0, 0, 1, f)
      : Z === 'alpha-blend' && s.buffers.color.setClear(0, 0, 0, 0, f),
      (a.autoClear || D) &&
        (s.buffers.depth.setTest(!0),
        s.buffers.depth.setMask(!0),
        s.buffers.color.setMask(!0),
        a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil));
  }
  function T(P, D) {
    const W = A(D);
    W && (W.isCubeTexture || W.mapping === Xf)
      ? (x === void 0 &&
          ((x = new bn(
            new Nr(1, 1, 1),
            new zs({
              name: 'BackgroundCubeMaterial',
              uniforms: Vl(Xa.backgroundCube.uniforms),
              vertexShader: Xa.backgroundCube.vertexShader,
              fragmentShader: Xa.backgroundCube.fragmentShader,
              side: Ni,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            }),
          )),
          x.geometry.deleteAttribute('normal'),
          x.geometry.deleteAttribute('uv'),
          (x.onBeforeRender = function (Z, V, J) {
            this.matrixWorld.copyPosition(J.matrixWorld);
          }),
          Object.defineProperty(x.material, 'envMap', {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          l.update(x)),
        mo.copy(D.backgroundRotation),
        (mo.x *= -1),
        (mo.y *= -1),
        (mo.z *= -1),
        W.isCubeTexture && W.isRenderTargetTexture === !1 && ((mo.y *= -1), (mo.z *= -1)),
        (x.material.uniforms.envMap.value = W),
        (x.material.uniforms.flipEnvMap.value =
          W.isCubeTexture && W.isRenderTargetTexture === !1 ? -1 : 1),
        (x.material.uniforms.backgroundBlurriness.value = D.backgroundBlurriness),
        (x.material.uniforms.backgroundIntensity.value = D.backgroundIntensity),
        x.material.uniforms.backgroundRotation.value.setFromMatrix4(A3.makeRotationFromEuler(mo)),
        (x.material.toneMapped = en.getTransfer(W.colorSpace) !== dn),
        (S !== W || b !== W.version || E !== a.toneMapping) &&
          ((x.material.needsUpdate = !0), (S = W), (b = W.version), (E = a.toneMapping)),
        x.layers.enableAll(),
        P.unshift(x, x.geometry, x.material, 0, 0, null))
      : W &&
        W.isTexture &&
        (g === void 0 &&
          ((g = new bn(
            new qf(2, 2),
            new zs({
              name: 'BackgroundMaterial',
              uniforms: Vl(Xa.background.uniforms),
              vertexShader: Xa.background.vertexShader,
              fragmentShader: Xa.background.fragmentShader,
              side: Ns,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            }),
          )),
          g.geometry.deleteAttribute('normal'),
          Object.defineProperty(g.material, 'map', {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          l.update(g)),
        (g.material.uniforms.t2D.value = W),
        (g.material.uniforms.backgroundIntensity.value = D.backgroundIntensity),
        (g.material.toneMapped = en.getTransfer(W.colorSpace) !== dn),
        W.matrixAutoUpdate === !0 && W.updateMatrix(),
        g.material.uniforms.uvTransform.value.copy(W.matrix),
        (S !== W || b !== W.version || E !== a.toneMapping) &&
          ((g.material.needsUpdate = !0), (S = W), (b = W.version), (E = a.toneMapping)),
        g.layers.enableAll(),
        P.unshift(g, g.geometry, g.material, 0, 0, null));
  }
  function M(P, D) {
    P.getRGB(mf, iM(a)), s.buffers.color.setClear(mf.r, mf.g, mf.b, D, f);
  }
  function z() {
    x !== void 0 && (x.geometry.dispose(), x.material.dispose(), (x = void 0)),
      g !== void 0 && (g.geometry.dispose(), g.material.dispose(), (g = void 0));
  }
  return {
    getClearColor: function () {
      return m;
    },
    setClearColor: function (P, D = 1) {
      m.set(P), (_ = D), M(m, _);
    },
    getClearAlpha: function () {
      return _;
    },
    setClearAlpha: function (P) {
      (_ = P), M(m, _);
    },
    render: R,
    addToRenderList: T,
    dispose: z,
  };
}
function R3(a, t) {
  const e = a.getParameter(a.MAX_VERTEX_ATTRIBS),
    s = {},
    l = b(null);
  let h = l,
    f = !1;
  function m(I, j, ft, pt, Mt) {
    let bt = !1;
    const X = S(pt, ft, j);
    h !== X && ((h = X), g(h.object)),
      (bt = E(I, pt, ft, Mt)),
      bt && A(I, pt, ft, Mt),
      Mt !== null && t.update(Mt, a.ELEMENT_ARRAY_BUFFER),
      (bt || f) &&
        ((f = !1),
        D(I, j, ft, pt),
        Mt !== null && a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, t.get(Mt).buffer));
  }
  function _() {
    return a.createVertexArray();
  }
  function g(I) {
    return a.bindVertexArray(I);
  }
  function x(I) {
    return a.deleteVertexArray(I);
  }
  function S(I, j, ft) {
    const pt = ft.wireframe === !0;
    let Mt = s[I.id];
    Mt === void 0 && ((Mt = {}), (s[I.id] = Mt));
    let bt = Mt[j.id];
    bt === void 0 && ((bt = {}), (Mt[j.id] = bt));
    let X = bt[pt];
    return X === void 0 && ((X = b(_())), (bt[pt] = X)), X;
  }
  function b(I) {
    const j = [],
      ft = [],
      pt = [];
    for (let Mt = 0; Mt < e; Mt++) (j[Mt] = 0), (ft[Mt] = 0), (pt[Mt] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: j,
      enabledAttributes: ft,
      attributeDivisors: pt,
      object: I,
      attributes: {},
      index: null,
    };
  }
  function E(I, j, ft, pt) {
    const Mt = h.attributes,
      bt = j.attributes;
    let X = 0;
    const it = ft.getAttributes();
    for (const K in it)
      if (it[K].location >= 0) {
        const N = Mt[K];
        let Q = bt[K];
        if (
          (Q === void 0 &&
            (K === 'instanceMatrix' && I.instanceMatrix && (Q = I.instanceMatrix),
            K === 'instanceColor' && I.instanceColor && (Q = I.instanceColor)),
          N === void 0 || N.attribute !== Q || (Q && N.data !== Q.data))
        )
          return !0;
        X++;
      }
    return h.attributesNum !== X || h.index !== pt;
  }
  function A(I, j, ft, pt) {
    const Mt = {},
      bt = j.attributes;
    let X = 0;
    const it = ft.getAttributes();
    for (const K in it)
      if (it[K].location >= 0) {
        let N = bt[K];
        N === void 0 &&
          (K === 'instanceMatrix' && I.instanceMatrix && (N = I.instanceMatrix),
          K === 'instanceColor' && I.instanceColor && (N = I.instanceColor));
        const Q = {};
        (Q.attribute = N), N && N.data && (Q.data = N.data), (Mt[K] = Q), X++;
      }
    (h.attributes = Mt), (h.attributesNum = X), (h.index = pt);
  }
  function R() {
    const I = h.newAttributes;
    for (let j = 0, ft = I.length; j < ft; j++) I[j] = 0;
  }
  function T(I) {
    M(I, 0);
  }
  function M(I, j) {
    const ft = h.newAttributes,
      pt = h.enabledAttributes,
      Mt = h.attributeDivisors;
    (ft[I] = 1),
      pt[I] === 0 && (a.enableVertexAttribArray(I), (pt[I] = 1)),
      Mt[I] !== j && (a.vertexAttribDivisor(I, j), (Mt[I] = j));
  }
  function z() {
    const I = h.newAttributes,
      j = h.enabledAttributes;
    for (let ft = 0, pt = j.length; ft < pt; ft++)
      j[ft] !== I[ft] && (a.disableVertexAttribArray(ft), (j[ft] = 0));
  }
  function P(I, j, ft, pt, Mt, bt, X) {
    X === !0
      ? a.vertexAttribIPointer(I, j, ft, Mt, bt)
      : a.vertexAttribPointer(I, j, ft, pt, Mt, bt);
  }
  function D(I, j, ft, pt) {
    R();
    const Mt = pt.attributes,
      bt = ft.getAttributes(),
      X = j.defaultAttributeValues;
    for (const it in bt) {
      const K = bt[it];
      if (K.location >= 0) {
        let zt = Mt[it];
        if (
          (zt === void 0 &&
            (it === 'instanceMatrix' && I.instanceMatrix && (zt = I.instanceMatrix),
            it === 'instanceColor' && I.instanceColor && (zt = I.instanceColor)),
          zt !== void 0)
        ) {
          const N = zt.normalized,
            Q = zt.itemSize,
            gt = t.get(zt);
          if (gt === void 0) continue;
          const At = gt.buffer,
            tt = gt.type,
            st = gt.bytesPerElement,
            _t = tt === a.INT || tt === a.UNSIGNED_INT || zt.gpuType === K_;
          if (zt.isInterleavedBufferAttribute) {
            const It = zt.data,
              Gt = It.stride,
              fe = zt.offset;
            if (It.isInstancedInterleavedBuffer) {
              for (let oe = 0; oe < K.locationSize; oe++) M(K.location + oe, It.meshPerAttribute);
              I.isInstancedMesh !== !0 &&
                pt._maxInstanceCount === void 0 &&
                (pt._maxInstanceCount = It.meshPerAttribute * It.count);
            } else for (let oe = 0; oe < K.locationSize; oe++) T(K.location + oe);
            a.bindBuffer(a.ARRAY_BUFFER, At);
            for (let oe = 0; oe < K.locationSize; oe++)
              P(
                K.location + oe,
                Q / K.locationSize,
                tt,
                N,
                Gt * st,
                (fe + (Q / K.locationSize) * oe) * st,
                _t,
              );
          } else {
            if (zt.isInstancedBufferAttribute) {
              for (let It = 0; It < K.locationSize; It++) M(K.location + It, zt.meshPerAttribute);
              I.isInstancedMesh !== !0 &&
                pt._maxInstanceCount === void 0 &&
                (pt._maxInstanceCount = zt.meshPerAttribute * zt.count);
            } else for (let It = 0; It < K.locationSize; It++) T(K.location + It);
            a.bindBuffer(a.ARRAY_BUFFER, At);
            for (let It = 0; It < K.locationSize; It++)
              P(
                K.location + It,
                Q / K.locationSize,
                tt,
                N,
                Q * st,
                (Q / K.locationSize) * It * st,
                _t,
              );
          }
        } else if (X !== void 0) {
          const N = X[it];
          if (N !== void 0)
            switch (N.length) {
              case 2:
                a.vertexAttrib2fv(K.location, N);
                break;
              case 3:
                a.vertexAttrib3fv(K.location, N);
                break;
              case 4:
                a.vertexAttrib4fv(K.location, N);
                break;
              default:
                a.vertexAttrib1fv(K.location, N);
            }
        }
      }
    }
    z();
  }
  function W() {
    J();
    for (const I in s) {
      const j = s[I];
      for (const ft in j) {
        const pt = j[ft];
        for (const Mt in pt) x(pt[Mt].object), delete pt[Mt];
        delete j[ft];
      }
      delete s[I];
    }
  }
  function Z(I) {
    if (s[I.id] === void 0) return;
    const j = s[I.id];
    for (const ft in j) {
      const pt = j[ft];
      for (const Mt in pt) x(pt[Mt].object), delete pt[Mt];
      delete j[ft];
    }
    delete s[I.id];
  }
  function V(I) {
    for (const j in s) {
      const ft = s[j];
      if (ft[I.id] === void 0) continue;
      const pt = ft[I.id];
      for (const Mt in pt) x(pt[Mt].object), delete pt[Mt];
      delete ft[I.id];
    }
  }
  function J() {
    F(), (f = !0), h !== l && ((h = l), g(h.object));
  }
  function F() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: m,
    reset: J,
    resetDefaultState: F,
    dispose: W,
    releaseStatesOfGeometry: Z,
    releaseStatesOfProgram: V,
    initAttributes: R,
    enableAttribute: T,
    disableUnusedAttributes: z,
  };
}
function L3(a, t, e) {
  let s;
  function l(g) {
    s = g;
  }
  function h(g, x) {
    a.drawArrays(s, g, x), e.update(x, s, 1);
  }
  function f(g, x, S) {
    S !== 0 && (a.drawArraysInstanced(s, g, x, S), e.update(x, s, S));
  }
  function m(g, x, S) {
    if (S === 0) return;
    t.get('WEBGL_multi_draw').multiDrawArraysWEBGL(s, g, 0, x, 0, S);
    let E = 0;
    for (let A = 0; A < S; A++) E += x[A];
    e.update(E, s, 1);
  }
  function _(g, x, S, b) {
    if (S === 0) return;
    const E = t.get('WEBGL_multi_draw');
    if (E === null) for (let A = 0; A < g.length; A++) f(g[A], x[A], b[A]);
    else {
      E.multiDrawArraysInstancedWEBGL(s, g, 0, x, 0, b, 0, S);
      let A = 0;
      for (let R = 0; R < S; R++) A += x[R] * b[R];
      e.update(A, s, 1);
    }
  }
  (this.setMode = l),
    (this.render = h),
    (this.renderInstances = f),
    (this.renderMultiDraw = m),
    (this.renderMultiDrawInstances = _);
}
function P3(a, t, e, s) {
  let l;
  function h() {
    if (l !== void 0) return l;
    if (t.has('EXT_texture_filter_anisotropic') === !0) {
      const V = t.get('EXT_texture_filter_anisotropic');
      l = a.getParameter(V.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else l = 0;
    return l;
  }
  function f(V) {
    return !(V !== Pa && s.convert(V) !== a.getParameter(a.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function m(V) {
    const J = V === Tu && (t.has('EXT_color_buffer_half_float') || t.has('EXT_color_buffer_float'));
    return !(
      V !== Ka &&
      s.convert(V) !== a.getParameter(a.IMPLEMENTATION_COLOR_READ_TYPE) &&
      V !== Or &&
      !J
    );
  }
  function _(V) {
    if (V === 'highp') {
      if (
        a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision > 0 &&
        a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision > 0
      )
        return 'highp';
      V = 'mediump';
    }
    return V === 'mediump' &&
      a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision > 0 &&
      a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision > 0
      ? 'mediump'
      : 'lowp';
  }
  let g = e.precision !== void 0 ? e.precision : 'highp';
  const x = _(g);
  x !== g &&
    (console.warn('THREE.WebGLRenderer:', g, 'not supported, using', x, 'instead.'), (g = x));
  const S = e.logarithmicDepthBuffer === !0,
    b = e.reverseDepthBuffer === !0 && t.has('EXT_clip_control'),
    E = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
    A = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    R = a.getParameter(a.MAX_TEXTURE_SIZE),
    T = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),
    M = a.getParameter(a.MAX_VERTEX_ATTRIBS),
    z = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),
    P = a.getParameter(a.MAX_VARYING_VECTORS),
    D = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),
    W = A > 0,
    Z = a.getParameter(a.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: h,
    getMaxPrecision: _,
    textureFormatReadable: f,
    textureTypeReadable: m,
    precision: g,
    logarithmicDepthBuffer: S,
    reverseDepthBuffer: b,
    maxTextures: E,
    maxVertexTextures: A,
    maxTextureSize: R,
    maxCubemapSize: T,
    maxAttributes: M,
    maxVertexUniforms: z,
    maxVaryings: P,
    maxFragmentUniforms: D,
    vertexTextures: W,
    maxSamples: Z,
  };
}
function D3(a) {
  const t = this;
  let e = null,
    s = 0,
    l = !1,
    h = !1;
  const f = new Ls(),
    m = new Be(),
    _ = { value: null, needsUpdate: !1 };
  (this.uniform = _),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (S, b) {
      const E = S.length !== 0 || b || s !== 0 || l;
      return (l = b), (s = S.length), E;
    }),
    (this.beginShadows = function () {
      (h = !0), x(null);
    }),
    (this.endShadows = function () {
      h = !1;
    }),
    (this.setGlobalState = function (S, b) {
      e = x(S, b, 0);
    }),
    (this.setState = function (S, b, E) {
      const A = S.clippingPlanes,
        R = S.clipIntersection,
        T = S.clipShadows,
        M = a.get(S);
      if (!l || A === null || A.length === 0 || (h && !T)) h ? x(null) : g();
      else {
        const z = h ? 0 : s,
          P = z * 4;
        let D = M.clippingState || null;
        (_.value = D), (D = x(A, b, P, E));
        for (let W = 0; W !== P; ++W) D[W] = e[W];
        (M.clippingState = D),
          (this.numIntersection = R ? this.numPlanes : 0),
          (this.numPlanes += z);
      }
    });
  function g() {
    _.value !== e && ((_.value = e), (_.needsUpdate = s > 0)),
      (t.numPlanes = s),
      (t.numIntersection = 0);
  }
  function x(S, b, E, A) {
    const R = S !== null ? S.length : 0;
    let T = null;
    if (R !== 0) {
      if (((T = _.value), A !== !0 || T === null)) {
        const M = E + R * 4,
          z = b.matrixWorldInverse;
        m.getNormalMatrix(z), (T === null || T.length < M) && (T = new Float32Array(M));
        for (let P = 0, D = E; P !== R; ++P, D += 4)
          f.copy(S[P]).applyMatrix4(z, m), f.normal.toArray(T, D), (T[D + 3] = f.constant);
      }
      (_.value = T), (_.needsUpdate = !0);
    }
    return (t.numPlanes = R), (t.numIntersection = 0), T;
  }
}
function O3(a) {
  let t = new WeakMap();
  function e(f, m) {
    return m === qm ? (f.mapping = Fl) : m === Ym && (f.mapping = Hl), f;
  }
  function s(f) {
    if (f && f.isTexture) {
      const m = f.mapping;
      if (m === qm || m === Ym)
        if (t.has(f)) {
          const _ = t.get(f).texture;
          return e(_, f.mapping);
        } else {
          const _ = f.image;
          if (_ && _.height > 0) {
            const g = new KA(_.height);
            return (
              g.fromEquirectangularTexture(a, f),
              t.set(f, g),
              f.addEventListener('dispose', l),
              e(g.texture, f.mapping)
            );
          } else return null;
        }
    }
    return f;
  }
  function l(f) {
    const m = f.target;
    m.removeEventListener('dispose', l);
    const _ = t.get(m);
    _ !== void 0 && (t.delete(m), _.dispose());
  }
  function h() {
    t = new WeakMap();
  }
  return { get: s, dispose: h };
}
const Dl = 4,
  mx = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  xo = 20,
  Tm = new _M(),
  _x = new Qe();
let wm = null,
  Am = 0,
  Cm = 0,
  Rm = !1;
const go = (1 + Math.sqrt(5)) / 2,
  Al = 1 / go,
  gx = [
    new et(-go, Al, 0),
    new et(go, Al, 0),
    new et(-Al, 0, go),
    new et(Al, 0, go),
    new et(0, go, -Al),
    new et(0, go, Al),
    new et(-1, 1, -1),
    new et(1, 1, -1),
    new et(-1, 1, 1),
    new et(1, 1, 1),
  ],
  U3 = new et();
class vx {
  constructor(t) {
    (this._renderer = t),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(t, e = 0, s = 0.1, l = 100, h = {}) {
    const { size: f = 256, position: m = U3 } = h;
    (wm = this._renderer.getRenderTarget()),
      (Am = this._renderer.getActiveCubeFace()),
      (Cm = this._renderer.getActiveMipmapLevel()),
      (Rm = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(f);
    const _ = this._allocateTargets();
    return (
      (_.depthBuffer = !0),
      this._sceneToCubeUV(t, s, l, _, m),
      e > 0 && this._blur(_, 0, 0, e),
      this._applyPMREM(_),
      this._cleanup(_),
      _
    );
  }
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e);
  }
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Sx()), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = xx()), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(t) {
    (this._lodMax = Math.floor(Math.log2(t))), (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose();
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(wm, Am, Cm),
      (this._renderer.xr.enabled = Rm),
      (t.scissorTest = !1),
      _f(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t, e) {
    t.mapping === Fl || t.mapping === Hl
      ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width)
      : this._setSize(t.image.width / 4),
      (wm = this._renderer.getRenderTarget()),
      (Am = this._renderer.getActiveCubeFace()),
      (Cm = this._renderer.getActiveMipmapLevel()),
      (Rm = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const s = e || this._allocateTargets();
    return this._textureToCubeUV(t, s), this._applyPMREM(s), this._cleanup(s), s;
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112),
      e = 4 * this._cubeSize,
      s = {
        magFilter: ja,
        minFilter: ja,
        generateMipmaps: !1,
        type: Tu,
        format: Pa,
        colorSpace: Gl,
        depthBuffer: !1,
      },
      l = yx(t, e, s);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== t ||
      this._pingPongRenderTarget.height !== e
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = yx(t, e, s));
      const { _lodMax: h } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = N3(h)),
        (this._blurMaterial = z3(h, t, e));
    }
    return l;
  }
  _compileMaterial(t) {
    const e = new bn(this._lodPlanes[0], t);
    this._renderer.compile(e, Tm);
  }
  _sceneToCubeUV(t, e, s, l, h) {
    const _ = new da(90, 1, e, s),
      g = [1, -1, 1, 1, 1, 1],
      x = [1, 1, 1, -1, -1, -1],
      S = this._renderer,
      b = S.autoClear,
      E = S.toneMapping;
    S.getClearColor(_x), (S.toneMapping = Us), (S.autoClear = !1);
    const A = new tM({ name: 'PMREM.Background', side: Ni, depthWrite: !1, depthTest: !1 }),
      R = new bn(new Nr(), A);
    let T = !1;
    const M = t.background;
    M
      ? M.isColor && (A.color.copy(M), (t.background = null), (T = !0))
      : (A.color.copy(_x), (T = !0));
    for (let z = 0; z < 6; z++) {
      const P = z % 3;
      P === 0
        ? (_.up.set(0, g[z], 0), _.position.set(h.x, h.y, h.z), _.lookAt(h.x + x[z], h.y, h.z))
        : P === 1
          ? (_.up.set(0, 0, g[z]), _.position.set(h.x, h.y, h.z), _.lookAt(h.x, h.y + x[z], h.z))
          : (_.up.set(0, g[z], 0), _.position.set(h.x, h.y, h.z), _.lookAt(h.x, h.y, h.z + x[z]));
      const D = this._cubeSize;
      _f(l, P * D, z > 2 ? D : 0, D, D), S.setRenderTarget(l), T && S.render(R, _), S.render(t, _);
    }
    R.geometry.dispose(),
      R.material.dispose(),
      (S.toneMapping = E),
      (S.autoClear = b),
      (t.background = M);
  }
  _textureToCubeUV(t, e) {
    const s = this._renderer,
      l = t.mapping === Fl || t.mapping === Hl;
    l
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Sx()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = xx());
    const h = l ? this._cubemapMaterial : this._equirectMaterial,
      f = new bn(this._lodPlanes[0], h),
      m = h.uniforms;
    m.envMap.value = t;
    const _ = this._cubeSize;
    _f(e, 0, 0, 3 * _, 2 * _), s.setRenderTarget(e), s.render(f, Tm);
  }
  _applyPMREM(t) {
    const e = this._renderer,
      s = e.autoClear;
    e.autoClear = !1;
    const l = this._lodPlanes.length;
    for (let h = 1; h < l; h++) {
      const f = Math.sqrt(
          this._sigmas[h] * this._sigmas[h] - this._sigmas[h - 1] * this._sigmas[h - 1],
        ),
        m = gx[(l - h - 1) % gx.length];
      this._blur(t, h - 1, h, f, m);
    }
    e.autoClear = s;
  }
  _blur(t, e, s, l, h) {
    const f = this._pingPongRenderTarget;
    this._halfBlur(t, f, e, s, l, 'latitudinal', h),
      this._halfBlur(f, t, s, s, l, 'longitudinal', h);
  }
  _halfBlur(t, e, s, l, h, f, m) {
    const _ = this._renderer,
      g = this._blurMaterial;
    f !== 'latitudinal' &&
      f !== 'longitudinal' &&
      console.error('blur direction must be either latitudinal or longitudinal!');
    const x = 3,
      S = new bn(this._lodPlanes[l], g),
      b = g.uniforms,
      E = this._sizeLods[s] - 1,
      A = isFinite(h) ? Math.PI / (2 * E) : (2 * Math.PI) / (2 * xo - 1),
      R = h / A,
      T = isFinite(h) ? 1 + Math.floor(x * R) : xo;
    T > xo &&
      console.warn(
        `sigmaRadians, ${h}, is too large and will clip, as it requested ${T} samples when the maximum is set to ${xo}`,
      );
    const M = [];
    let z = 0;
    for (let V = 0; V < xo; ++V) {
      const J = V / R,
        F = Math.exp((-J * J) / 2);
      M.push(F), V === 0 ? (z += F) : V < T && (z += 2 * F);
    }
    for (let V = 0; V < M.length; V++) M[V] = M[V] / z;
    (b.envMap.value = t.texture),
      (b.samples.value = T),
      (b.weights.value = M),
      (b.latitudinal.value = f === 'latitudinal'),
      m && (b.poleAxis.value = m);
    const { _lodMax: P } = this;
    (b.dTheta.value = A), (b.mipInt.value = P - s);
    const D = this._sizeLods[l],
      W = 3 * D * (l > P - Dl ? l - P + Dl : 0),
      Z = 4 * (this._cubeSize - D);
    _f(e, W, Z, 3 * D, 2 * D), _.setRenderTarget(e), _.render(S, Tm);
  }
}
function N3(a) {
  const t = [],
    e = [],
    s = [];
  let l = a;
  const h = a - Dl + 1 + mx.length;
  for (let f = 0; f < h; f++) {
    const m = Math.pow(2, l);
    e.push(m);
    let _ = 1 / m;
    f > a - Dl ? (_ = mx[f - a + Dl - 1]) : f === 0 && (_ = 0), s.push(_);
    const g = 1 / (m - 2),
      x = -g,
      S = 1 + g,
      b = [x, x, S, x, S, S, x, x, S, S, x, S],
      E = 6,
      A = 6,
      R = 3,
      T = 2,
      M = 1,
      z = new Float32Array(R * A * E),
      P = new Float32Array(T * A * E),
      D = new Float32Array(M * A * E);
    for (let Z = 0; Z < E; Z++) {
      const V = ((Z % 3) * 2) / 3 - 1,
        J = Z > 2 ? 0 : -1,
        F = [
          V,
          J,
          0,
          V + 2 / 3,
          J,
          0,
          V + 2 / 3,
          J + 1,
          0,
          V,
          J,
          0,
          V + 2 / 3,
          J + 1,
          0,
          V,
          J + 1,
          0,
        ];
      z.set(F, R * A * Z), P.set(b, T * A * Z);
      const I = [Z, Z, Z, Z, Z, Z];
      D.set(I, M * A * Z);
    }
    const W = new $i();
    W.setAttribute('position', new ma(z, R)),
      W.setAttribute('uv', new ma(P, T)),
      W.setAttribute('faceIndex', new ma(D, M)),
      t.push(W),
      l > Dl && l--;
  }
  return { lodPlanes: t, sizeLods: e, sigmas: s };
}
function yx(a, t, e) {
  const s = new Eo(a, t, e);
  return (s.texture.mapping = Xf), (s.texture.name = 'PMREM.cubeUv'), (s.scissorTest = !0), s;
}
function _f(a, t, e, s, l) {
  a.viewport.set(t, e, s, l), a.scissor.set(t, e, s, l);
}
function z3(a, t, e) {
  const s = new Float32Array(xo),
    l = new et(0, 1, 0);
  return new zs({
    name: 'SphericalGaussianBlur',
    defines: {
      n: xo,
      CUBEUV_TEXEL_WIDTH: 1 / t,
      CUBEUV_TEXEL_HEIGHT: 1 / e,
      CUBEUV_MAX_MIP: `${a}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: s },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: l },
    },
    vertexShader: lg(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Os,
    depthTest: !1,
    depthWrite: !1,
  });
}
function xx() {
  return new zs({
    name: 'EquirectangularToCubeUV',
    uniforms: { envMap: { value: null } },
    vertexShader: lg(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Os,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Sx() {
  return new zs({
    name: 'CubemapToCubeUV',
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: lg(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Os,
    depthTest: !1,
    depthWrite: !1,
  });
}
function lg() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function I3(a) {
  let t = new WeakMap(),
    e = null;
  function s(m) {
    if (m && m.isTexture) {
      const _ = m.mapping,
        g = _ === qm || _ === Ym,
        x = _ === Fl || _ === Hl;
      if (g || x) {
        let S = t.get(m);
        const b = S !== void 0 ? S.texture.pmremVersion : 0;
        if (m.isRenderTargetTexture && m.pmremVersion !== b)
          return (
            e === null && (e = new vx(a)),
            (S = g ? e.fromEquirectangular(m, S) : e.fromCubemap(m, S)),
            (S.texture.pmremVersion = m.pmremVersion),
            t.set(m, S),
            S.texture
          );
        if (S !== void 0) return S.texture;
        {
          const E = m.image;
          return (g && E && E.height > 0) || (x && E && l(E))
            ? (e === null && (e = new vx(a)),
              (S = g ? e.fromEquirectangular(m) : e.fromCubemap(m)),
              (S.texture.pmremVersion = m.pmremVersion),
              t.set(m, S),
              m.addEventListener('dispose', h),
              S.texture)
            : null;
        }
      }
    }
    return m;
  }
  function l(m) {
    let _ = 0;
    const g = 6;
    for (let x = 0; x < g; x++) m[x] !== void 0 && _++;
    return _ === g;
  }
  function h(m) {
    const _ = m.target;
    _.removeEventListener('dispose', h);
    const g = t.get(_);
    g !== void 0 && (t.delete(_), g.dispose());
  }
  function f() {
    (t = new WeakMap()), e !== null && (e.dispose(), (e = null));
  }
  return { get: s, dispose: f };
}
function B3(a) {
  const t = {};
  function e(s) {
    if (t[s] !== void 0) return t[s];
    let l;
    switch (s) {
      case 'WEBGL_depth_texture':
        l =
          a.getExtension('WEBGL_depth_texture') ||
          a.getExtension('MOZ_WEBGL_depth_texture') ||
          a.getExtension('WEBKIT_WEBGL_depth_texture');
        break;
      case 'EXT_texture_filter_anisotropic':
        l =
          a.getExtension('EXT_texture_filter_anisotropic') ||
          a.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          a.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        break;
      case 'WEBGL_compressed_texture_s3tc':
        l =
          a.getExtension('WEBGL_compressed_texture_s3tc') ||
          a.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          a.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        break;
      case 'WEBGL_compressed_texture_pvrtc':
        l =
          a.getExtension('WEBGL_compressed_texture_pvrtc') ||
          a.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        break;
      default:
        l = a.getExtension(s);
    }
    return (t[s] = l), l;
  }
  return {
    has: function (s) {
      return e(s) !== null;
    },
    init: function () {
      e('EXT_color_buffer_float'),
        e('WEBGL_clip_cull_distance'),
        e('OES_texture_float_linear'),
        e('EXT_color_buffer_half_float'),
        e('WEBGL_multisampled_render_to_texture'),
        e('WEBGL_render_shared_exponent');
    },
    get: function (s) {
      const l = e(s);
      return l === null && Pf('THREE.WebGLRenderer: ' + s + ' extension not supported.'), l;
    },
  };
}
function k3(a, t, e, s) {
  const l = {},
    h = new WeakMap();
  function f(S) {
    const b = S.target;
    b.index !== null && t.remove(b.index);
    for (const A in b.attributes) t.remove(b.attributes[A]);
    b.removeEventListener('dispose', f), delete l[b.id];
    const E = h.get(b);
    E && (t.remove(E), h.delete(b)),
      s.releaseStatesOfGeometry(b),
      b.isInstancedBufferGeometry === !0 && delete b._maxInstanceCount,
      e.memory.geometries--;
  }
  function m(S, b) {
    return (
      l[b.id] === !0 || (b.addEventListener('dispose', f), (l[b.id] = !0), e.memory.geometries++), b
    );
  }
  function _(S) {
    const b = S.attributes;
    for (const E in b) t.update(b[E], a.ARRAY_BUFFER);
  }
  function g(S) {
    const b = [],
      E = S.index,
      A = S.attributes.position;
    let R = 0;
    if (E !== null) {
      const z = E.array;
      R = E.version;
      for (let P = 0, D = z.length; P < D; P += 3) {
        const W = z[P + 0],
          Z = z[P + 1],
          V = z[P + 2];
        b.push(W, Z, Z, V, V, W);
      }
    } else if (A !== void 0) {
      const z = A.array;
      R = A.version;
      for (let P = 0, D = z.length / 3 - 1; P < D; P += 3) {
        const W = P + 0,
          Z = P + 1,
          V = P + 2;
        b.push(W, Z, Z, V, V, W);
      }
    } else return;
    const T = new (KS(b) ? nM : eM)(b, 1);
    T.version = R;
    const M = h.get(S);
    M && t.remove(M), h.set(S, T);
  }
  function x(S) {
    const b = h.get(S);
    if (b) {
      const E = S.index;
      E !== null && b.version < E.version && g(S);
    } else g(S);
    return h.get(S);
  }
  return { get: m, update: _, getWireframeAttribute: x };
}
function F3(a, t, e) {
  let s;
  function l(b) {
    s = b;
  }
  let h, f;
  function m(b) {
    (h = b.type), (f = b.bytesPerElement);
  }
  function _(b, E) {
    a.drawElements(s, E, h, b * f), e.update(E, s, 1);
  }
  function g(b, E, A) {
    A !== 0 && (a.drawElementsInstanced(s, E, h, b * f, A), e.update(E, s, A));
  }
  function x(b, E, A) {
    if (A === 0) return;
    t.get('WEBGL_multi_draw').multiDrawElementsWEBGL(s, E, 0, h, b, 0, A);
    let T = 0;
    for (let M = 0; M < A; M++) T += E[M];
    e.update(T, s, 1);
  }
  function S(b, E, A, R) {
    if (A === 0) return;
    const T = t.get('WEBGL_multi_draw');
    if (T === null) for (let M = 0; M < b.length; M++) g(b[M] / f, E[M], R[M]);
    else {
      T.multiDrawElementsInstancedWEBGL(s, E, 0, h, b, 0, R, 0, A);
      let M = 0;
      for (let z = 0; z < A; z++) M += E[z] * R[z];
      e.update(M, s, 1);
    }
  }
  (this.setMode = l),
    (this.setIndex = m),
    (this.render = _),
    (this.renderInstances = g),
    (this.renderMultiDraw = x),
    (this.renderMultiDrawInstances = S);
}
function H3(a) {
  const t = { geometries: 0, textures: 0 },
    e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function s(h, f, m) {
    switch ((e.calls++, f)) {
      case a.TRIANGLES:
        e.triangles += m * (h / 3);
        break;
      case a.LINES:
        e.lines += m * (h / 2);
        break;
      case a.LINE_STRIP:
        e.lines += m * (h - 1);
        break;
      case a.LINE_LOOP:
        e.lines += m * h;
        break;
      case a.POINTS:
        e.points += m * h;
        break;
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', f);
        break;
    }
  }
  function l() {
    (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
  }
  return { memory: t, render: e, programs: null, autoReset: !0, reset: l, update: s };
}
function G3(a, t, e) {
  const s = new WeakMap(),
    l = new Un();
  function h(f, m, _) {
    const g = f.morphTargetInfluences,
      x = m.morphAttributes.position || m.morphAttributes.normal || m.morphAttributes.color,
      S = x !== void 0 ? x.length : 0;
    let b = s.get(m);
    if (b === void 0 || b.count !== S) {
      let I = function () {
        J.dispose(), s.delete(m), m.removeEventListener('dispose', I);
      };
      var E = I;
      b !== void 0 && b.texture.dispose();
      const A = m.morphAttributes.position !== void 0,
        R = m.morphAttributes.normal !== void 0,
        T = m.morphAttributes.color !== void 0,
        M = m.morphAttributes.position || [],
        z = m.morphAttributes.normal || [],
        P = m.morphAttributes.color || [];
      let D = 0;
      A === !0 && (D = 1), R === !0 && (D = 2), T === !0 && (D = 3);
      let W = m.attributes.position.count * D,
        Z = 1;
      W > t.maxTextureSize && ((Z = Math.ceil(W / t.maxTextureSize)), (W = t.maxTextureSize));
      const V = new Float32Array(W * Z * 4 * S),
        J = new QS(V, W, Z, S);
      (J.type = Or), (J.needsUpdate = !0);
      const F = D * 4;
      for (let j = 0; j < S; j++) {
        const ft = M[j],
          pt = z[j],
          Mt = P[j],
          bt = W * Z * 4 * j;
        for (let X = 0; X < ft.count; X++) {
          const it = X * F;
          A === !0 &&
            (l.fromBufferAttribute(ft, X),
            (V[bt + it + 0] = l.x),
            (V[bt + it + 1] = l.y),
            (V[bt + it + 2] = l.z),
            (V[bt + it + 3] = 0)),
            R === !0 &&
              (l.fromBufferAttribute(pt, X),
              (V[bt + it + 4] = l.x),
              (V[bt + it + 5] = l.y),
              (V[bt + it + 6] = l.z),
              (V[bt + it + 7] = 0)),
            T === !0 &&
              (l.fromBufferAttribute(Mt, X),
              (V[bt + it + 8] = l.x),
              (V[bt + it + 9] = l.y),
              (V[bt + it + 10] = l.z),
              (V[bt + it + 11] = Mt.itemSize === 4 ? l.w : 1));
        }
      }
      (b = { count: S, texture: J, size: new Yt(W, Z) }),
        s.set(m, b),
        m.addEventListener('dispose', I);
    }
    if (f.isInstancedMesh === !0 && f.morphTexture !== null)
      _.getUniforms().setValue(a, 'morphTexture', f.morphTexture, e);
    else {
      let A = 0;
      for (let T = 0; T < g.length; T++) A += g[T];
      const R = m.morphTargetsRelative ? 1 : 1 - A;
      _.getUniforms().setValue(a, 'morphTargetBaseInfluence', R),
        _.getUniforms().setValue(a, 'morphTargetInfluences', g);
    }
    _.getUniforms().setValue(a, 'morphTargetsTexture', b.texture, e),
      _.getUniforms().setValue(a, 'morphTargetsTextureSize', b.size);
  }
  return { update: h };
}
function V3(a, t, e, s) {
  let l = new WeakMap();
  function h(_) {
    const g = s.render.frame,
      x = _.geometry,
      S = t.get(_, x);
    if (
      (l.get(S) !== g && (t.update(S), l.set(S, g)),
      _.isInstancedMesh &&
        (_.hasEventListener('dispose', m) === !1 && _.addEventListener('dispose', m),
        l.get(_) !== g &&
          (e.update(_.instanceMatrix, a.ARRAY_BUFFER),
          _.instanceColor !== null && e.update(_.instanceColor, a.ARRAY_BUFFER),
          l.set(_, g))),
      _.isSkinnedMesh)
    ) {
      const b = _.skeleton;
      l.get(b) !== g && (b.update(), l.set(b, g));
    }
    return S;
  }
  function f() {
    l = new WeakMap();
  }
  function m(_) {
    const g = _.target;
    g.removeEventListener('dispose', m),
      e.remove(g.instanceMatrix),
      g.instanceColor !== null && e.remove(g.instanceColor);
  }
  return { update: h, dispose: f };
}
const vM = new Ai(),
  Mx = new sM(1, 1),
  yM = new QS(),
  xM = new OA(),
  SM = new rM(),
  bx = [],
  Ex = [],
  Tx = new Float32Array(16),
  wx = new Float32Array(9),
  Ax = new Float32Array(4);
function Ql(a, t, e) {
  const s = a[0];
  if (s <= 0 || s > 0) return a;
  const l = t * e;
  let h = bx[l];
  if ((h === void 0 && ((h = new Float32Array(l)), (bx[l] = h)), t !== 0)) {
    s.toArray(h, 0);
    for (let f = 1, m = 0; f !== t; ++f) (m += e), a[f].toArray(h, m);
  }
  return h;
}
function qn(a, t) {
  if (a.length !== t.length) return !1;
  for (let e = 0, s = a.length; e < s; e++) if (a[e] !== t[e]) return !1;
  return !0;
}
function Yn(a, t) {
  for (let e = 0, s = t.length; e < s; e++) a[e] = t[e];
}
function Yf(a, t) {
  let e = Ex[t];
  e === void 0 && ((e = new Int32Array(t)), (Ex[t] = e));
  for (let s = 0; s !== t; ++s) e[s] = a.allocateTextureUnit();
  return e;
}
function W3(a, t) {
  const e = this.cache;
  e[0] !== t && (a.uniform1f(this.addr, t), (e[0] = t));
}
function Z3(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (a.uniform2f(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
  else {
    if (qn(e, t)) return;
    a.uniform2fv(this.addr, t), Yn(e, t);
  }
}
function X3(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (a.uniform3f(this.addr, t.x, t.y, t.z), (e[0] = t.x), (e[1] = t.y), (e[2] = t.z));
  else if (t.r !== void 0)
    (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) &&
      (a.uniform3f(this.addr, t.r, t.g, t.b), (e[0] = t.r), (e[1] = t.g), (e[2] = t.b));
  else {
    if (qn(e, t)) return;
    a.uniform3fv(this.addr, t), Yn(e, t);
  }
}
function j3(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (a.uniform4f(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w));
  else {
    if (qn(e, t)) return;
    a.uniform4fv(this.addr, t), Yn(e, t);
  }
}
function q3(a, t) {
  const e = this.cache,
    s = t.elements;
  if (s === void 0) {
    if (qn(e, t)) return;
    a.uniformMatrix2fv(this.addr, !1, t), Yn(e, t);
  } else {
    if (qn(e, s)) return;
    Ax.set(s), a.uniformMatrix2fv(this.addr, !1, Ax), Yn(e, s);
  }
}
function Y3(a, t) {
  const e = this.cache,
    s = t.elements;
  if (s === void 0) {
    if (qn(e, t)) return;
    a.uniformMatrix3fv(this.addr, !1, t), Yn(e, t);
  } else {
    if (qn(e, s)) return;
    wx.set(s), a.uniformMatrix3fv(this.addr, !1, wx), Yn(e, s);
  }
}
function K3(a, t) {
  const e = this.cache,
    s = t.elements;
  if (s === void 0) {
    if (qn(e, t)) return;
    a.uniformMatrix4fv(this.addr, !1, t), Yn(e, t);
  } else {
    if (qn(e, s)) return;
    Tx.set(s), a.uniformMatrix4fv(this.addr, !1, Tx), Yn(e, s);
  }
}
function Q3(a, t) {
  const e = this.cache;
  e[0] !== t && (a.uniform1i(this.addr, t), (e[0] = t));
}
function J3(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (a.uniform2i(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
  else {
    if (qn(e, t)) return;
    a.uniform2iv(this.addr, t), Yn(e, t);
  }
}
function $3(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (a.uniform3i(this.addr, t.x, t.y, t.z), (e[0] = t.x), (e[1] = t.y), (e[2] = t.z));
  else {
    if (qn(e, t)) return;
    a.uniform3iv(this.addr, t), Yn(e, t);
  }
}
function tL(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (a.uniform4i(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w));
  else {
    if (qn(e, t)) return;
    a.uniform4iv(this.addr, t), Yn(e, t);
  }
}
function eL(a, t) {
  const e = this.cache;
  e[0] !== t && (a.uniform1ui(this.addr, t), (e[0] = t));
}
function nL(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (a.uniform2ui(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
  else {
    if (qn(e, t)) return;
    a.uniform2uiv(this.addr, t), Yn(e, t);
  }
}
function iL(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (a.uniform3ui(this.addr, t.x, t.y, t.z), (e[0] = t.x), (e[1] = t.y), (e[2] = t.z));
  else {
    if (qn(e, t)) return;
    a.uniform3uiv(this.addr, t), Yn(e, t);
  }
}
function aL(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (a.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w));
  else {
    if (qn(e, t)) return;
    a.uniform4uiv(this.addr, t), Yn(e, t);
  }
}
function rL(a, t, e) {
  const s = this.cache,
    l = e.allocateTextureUnit();
  s[0] !== l && (a.uniform1i(this.addr, l), (s[0] = l));
  let h;
  this.type === a.SAMPLER_2D_SHADOW ? ((Mx.compareFunction = YS), (h = Mx)) : (h = vM),
    e.setTexture2D(t || h, l);
}
function sL(a, t, e) {
  const s = this.cache,
    l = e.allocateTextureUnit();
  s[0] !== l && (a.uniform1i(this.addr, l), (s[0] = l)), e.setTexture3D(t || xM, l);
}
function oL(a, t, e) {
  const s = this.cache,
    l = e.allocateTextureUnit();
  s[0] !== l && (a.uniform1i(this.addr, l), (s[0] = l)), e.setTextureCube(t || SM, l);
}
function lL(a, t, e) {
  const s = this.cache,
    l = e.allocateTextureUnit();
  s[0] !== l && (a.uniform1i(this.addr, l), (s[0] = l)), e.setTexture2DArray(t || yM, l);
}
function cL(a) {
  switch (a) {
    case 5126:
      return W3;
    case 35664:
      return Z3;
    case 35665:
      return X3;
    case 35666:
      return j3;
    case 35674:
      return q3;
    case 35675:
      return Y3;
    case 35676:
      return K3;
    case 5124:
    case 35670:
      return Q3;
    case 35667:
    case 35671:
      return J3;
    case 35668:
    case 35672:
      return $3;
    case 35669:
    case 35673:
      return tL;
    case 5125:
      return eL;
    case 36294:
      return nL;
    case 36295:
      return iL;
    case 36296:
      return aL;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return rL;
    case 35679:
    case 36299:
    case 36307:
      return sL;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return oL;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return lL;
  }
}
function uL(a, t) {
  a.uniform1fv(this.addr, t);
}
function hL(a, t) {
  const e = Ql(t, this.size, 2);
  a.uniform2fv(this.addr, e);
}
function fL(a, t) {
  const e = Ql(t, this.size, 3);
  a.uniform3fv(this.addr, e);
}
function dL(a, t) {
  const e = Ql(t, this.size, 4);
  a.uniform4fv(this.addr, e);
}
function pL(a, t) {
  const e = Ql(t, this.size, 4);
  a.uniformMatrix2fv(this.addr, !1, e);
}
function mL(a, t) {
  const e = Ql(t, this.size, 9);
  a.uniformMatrix3fv(this.addr, !1, e);
}
function _L(a, t) {
  const e = Ql(t, this.size, 16);
  a.uniformMatrix4fv(this.addr, !1, e);
}
function gL(a, t) {
  a.uniform1iv(this.addr, t);
}
function vL(a, t) {
  a.uniform2iv(this.addr, t);
}
function yL(a, t) {
  a.uniform3iv(this.addr, t);
}
function xL(a, t) {
  a.uniform4iv(this.addr, t);
}
function SL(a, t) {
  a.uniform1uiv(this.addr, t);
}
function ML(a, t) {
  a.uniform2uiv(this.addr, t);
}
function bL(a, t) {
  a.uniform3uiv(this.addr, t);
}
function EL(a, t) {
  a.uniform4uiv(this.addr, t);
}
function TL(a, t, e) {
  const s = this.cache,
    l = t.length,
    h = Yf(e, l);
  qn(s, h) || (a.uniform1iv(this.addr, h), Yn(s, h));
  for (let f = 0; f !== l; ++f) e.setTexture2D(t[f] || vM, h[f]);
}
function wL(a, t, e) {
  const s = this.cache,
    l = t.length,
    h = Yf(e, l);
  qn(s, h) || (a.uniform1iv(this.addr, h), Yn(s, h));
  for (let f = 0; f !== l; ++f) e.setTexture3D(t[f] || xM, h[f]);
}
function AL(a, t, e) {
  const s = this.cache,
    l = t.length,
    h = Yf(e, l);
  qn(s, h) || (a.uniform1iv(this.addr, h), Yn(s, h));
  for (let f = 0; f !== l; ++f) e.setTextureCube(t[f] || SM, h[f]);
}
function CL(a, t, e) {
  const s = this.cache,
    l = t.length,
    h = Yf(e, l);
  qn(s, h) || (a.uniform1iv(this.addr, h), Yn(s, h));
  for (let f = 0; f !== l; ++f) e.setTexture2DArray(t[f] || yM, h[f]);
}
function RL(a) {
  switch (a) {
    case 5126:
      return uL;
    case 35664:
      return hL;
    case 35665:
      return fL;
    case 35666:
      return dL;
    case 35674:
      return pL;
    case 35675:
      return mL;
    case 35676:
      return _L;
    case 5124:
    case 35670:
      return gL;
    case 35667:
    case 35671:
      return vL;
    case 35668:
    case 35672:
      return yL;
    case 35669:
    case 35673:
      return xL;
    case 5125:
      return SL;
    case 36294:
      return ML;
    case 36295:
      return bL;
    case 36296:
      return EL;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return TL;
    case 35679:
    case 36299:
    case 36307:
      return wL;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return AL;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return CL;
  }
}
class LL {
  constructor(t, e, s) {
    (this.id = t),
      (this.addr = s),
      (this.cache = []),
      (this.type = e.type),
      (this.setValue = cL(e.type));
  }
}
class PL {
  constructor(t, e, s) {
    (this.id = t),
      (this.addr = s),
      (this.cache = []),
      (this.type = e.type),
      (this.size = e.size),
      (this.setValue = RL(e.type));
  }
}
class DL {
  constructor(t) {
    (this.id = t), (this.seq = []), (this.map = {});
  }
  setValue(t, e, s) {
    const l = this.seq;
    for (let h = 0, f = l.length; h !== f; ++h) {
      const m = l[h];
      m.setValue(t, e[m.id], s);
    }
  }
}
const Lm = /(\w+)(\])?(\[|\.)?/g;
function Cx(a, t) {
  a.seq.push(t), (a.map[t.id] = t);
}
function OL(a, t, e) {
  const s = a.name,
    l = s.length;
  for (Lm.lastIndex = 0; ; ) {
    const h = Lm.exec(s),
      f = Lm.lastIndex;
    let m = h[1];
    const _ = h[2] === ']',
      g = h[3];
    if ((_ && (m = m | 0), g === void 0 || (g === '[' && f + 2 === l))) {
      Cx(e, g === void 0 ? new LL(m, a, t) : new PL(m, a, t));
      break;
    } else {
      let S = e.map[m];
      S === void 0 && ((S = new DL(m)), Cx(e, S)), (e = S);
    }
  }
}
class Df {
  constructor(t, e) {
    (this.seq = []), (this.map = {});
    const s = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let l = 0; l < s; ++l) {
      const h = t.getActiveUniform(e, l),
        f = t.getUniformLocation(e, h.name);
      OL(h, f, this);
    }
  }
  setValue(t, e, s, l) {
    const h = this.map[e];
    h !== void 0 && h.setValue(t, s, l);
  }
  setOptional(t, e, s) {
    const l = e[s];
    l !== void 0 && this.setValue(t, s, l);
  }
  static upload(t, e, s, l) {
    for (let h = 0, f = e.length; h !== f; ++h) {
      const m = e[h],
        _ = s[m.id];
      _.needsUpdate !== !1 && m.setValue(t, _.value, l);
    }
  }
  static seqWithValue(t, e) {
    const s = [];
    for (let l = 0, h = t.length; l !== h; ++l) {
      const f = t[l];
      f.id in e && s.push(f);
    }
    return s;
  }
}
function Rx(a, t, e) {
  const s = a.createShader(t);
  return a.shaderSource(s, e), a.compileShader(s), s;
}
const UL = 37297;
let NL = 0;
function zL(a, t) {
  const e = a.split(`
`),
    s = [],
    l = Math.max(t - 6, 0),
    h = Math.min(t + 6, e.length);
  for (let f = l; f < h; f++) {
    const m = f + 1;
    s.push(`${m === t ? '>' : ' '} ${m}: ${e[f]}`);
  }
  return s.join(`
`);
}
const Lx = new Be();
function IL(a) {
  en._getMatrix(Lx, en.workingColorSpace, a);
  const t = `mat3( ${Lx.elements.map((e) => e.toFixed(4))} )`;
  switch (en.getTransfer(a)) {
    case If:
      return [t, 'LinearTransferOETF'];
    case dn:
      return [t, 'sRGBTransferOETF'];
    default:
      return (
        console.warn('THREE.WebGLProgram: Unsupported color space: ', a), [t, 'LinearTransferOETF']
      );
  }
}
function Px(a, t, e) {
  const s = a.getShaderParameter(t, a.COMPILE_STATUS),
    l = a.getShaderInfoLog(t).trim();
  if (s && l === '') return '';
  const h = /ERROR: 0:(\d+)/.exec(l);
  if (h) {
    const f = parseInt(h[1]);
    return (
      e.toUpperCase() +
      `

` +
      l +
      `

` +
      zL(a.getShaderSource(t), f)
    );
  } else return l;
}
function BL(a, t) {
  const e = IL(t);
  return [
    `vec4 ${a}( vec4 value ) {`,
    `	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,
    '}',
  ].join(`
`);
}
function kL(a, t) {
  let e;
  switch (t) {
    case aA:
      e = 'Linear';
      break;
    case rA:
      e = 'Reinhard';
      break;
    case sA:
      e = 'Cineon';
      break;
    case oA:
      e = 'ACESFilmic';
      break;
    case cA:
      e = 'AgX';
      break;
    case uA:
      e = 'Neutral';
      break;
    case lA:
      e = 'Custom';
      break;
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', t), (e = 'Linear');
  }
  return 'vec3 ' + a + '( vec3 color ) { return ' + e + 'ToneMapping( color ); }';
}
const gf = new et();
function FL() {
  en.getLuminanceCoefficients(gf);
  const a = gf.x.toFixed(4),
    t = gf.y.toFixed(4),
    e = gf.z.toFixed(4);
  return [
    'float luminance( const in vec3 rgb ) {',
    `	const vec3 weights = vec3( ${a}, ${t}, ${e} );`,
    '	return dot( weights, rgb );',
    '}',
  ].join(`
`);
}
function HL(a) {
  return [
    a.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
    a.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
  ].filter(su).join(`
`);
}
function GL(a) {
  const t = [];
  for (const e in a) {
    const s = a[e];
    s !== !1 && t.push('#define ' + e + ' ' + s);
  }
  return t.join(`
`);
}
function VL(a, t) {
  const e = {},
    s = a.getProgramParameter(t, a.ACTIVE_ATTRIBUTES);
  for (let l = 0; l < s; l++) {
    const h = a.getActiveAttrib(t, l),
      f = h.name;
    let m = 1;
    h.type === a.FLOAT_MAT2 && (m = 2),
      h.type === a.FLOAT_MAT3 && (m = 3),
      h.type === a.FLOAT_MAT4 && (m = 4),
      (e[f] = { type: h.type, location: a.getAttribLocation(t, f), locationSize: m });
  }
  return e;
}
function su(a) {
  return a !== '';
}
function Dx(a, t) {
  const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return a
    .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, e)
    .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function Ox(a, t) {
  return a
    .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
    .replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
const WL = /^[ \t]*#include +<([\w\d./]+)>/gm;
function P_(a) {
  return a.replace(WL, XL);
}
const ZL = new Map();
function XL(a, t) {
  let e = Fe[t];
  if (e === void 0) {
    const s = ZL.get(t);
    if (s !== void 0)
      (e = Fe[s]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          t,
          s,
        );
    else throw new Error('Can not resolve #include <' + t + '>');
  }
  return P_(e);
}
const jL =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Ux(a) {
  return a.replace(jL, qL);
}
function qL(a, t, e, s) {
  let l = '';
  for (let h = parseInt(t); h < parseInt(e); h++)
    l += s.replace(/\[\s*i\s*\]/g, '[ ' + h + ' ]').replace(/UNROLLED_LOOP_INDEX/g, h);
  return l;
}
function Nx(a) {
  let t = `precision ${a.precision} float;
	precision ${a.precision} int;
	precision ${a.precision} sampler2D;
	precision ${a.precision} samplerCube;
	precision ${a.precision} sampler3D;
	precision ${a.precision} sampler2DArray;
	precision ${a.precision} sampler2DShadow;
	precision ${a.precision} samplerCubeShadow;
	precision ${a.precision} sampler2DArrayShadow;
	precision ${a.precision} isampler2D;
	precision ${a.precision} isampler3D;
	precision ${a.precision} isamplerCube;
	precision ${a.precision} isampler2DArray;
	precision ${a.precision} usampler2D;
	precision ${a.precision} usampler3D;
	precision ${a.precision} usamplerCube;
	precision ${a.precision} usampler2DArray;
	`;
  return (
    a.precision === 'highp'
      ? (t += `
#define HIGH_PRECISION`)
      : a.precision === 'mediump'
        ? (t += `
#define MEDIUM_PRECISION`)
        : a.precision === 'lowp' &&
          (t += `
#define LOW_PRECISION`),
    t
  );
}
function YL(a) {
  let t = 'SHADOWMAP_TYPE_BASIC';
  return (
    a.shadowMapType === BS
      ? (t = 'SHADOWMAP_TYPE_PCF')
      : a.shadowMapType === Iw
        ? (t = 'SHADOWMAP_TYPE_PCF_SOFT')
        : a.shadowMapType === Pr && (t = 'SHADOWMAP_TYPE_VSM'),
    t
  );
}
function KL(a) {
  let t = 'ENVMAP_TYPE_CUBE';
  if (a.envMap)
    switch (a.envMapMode) {
      case Fl:
      case Hl:
        t = 'ENVMAP_TYPE_CUBE';
        break;
      case Xf:
        t = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  return t;
}
function QL(a) {
  let t = 'ENVMAP_MODE_REFLECTION';
  if (a.envMap)
    switch (a.envMapMode) {
      case Hl:
        t = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  return t;
}
function JL(a) {
  let t = 'ENVMAP_BLENDING_NONE';
  if (a.envMap)
    switch (a.combine) {
      case Y_:
        t = 'ENVMAP_BLENDING_MULTIPLY';
        break;
      case nA:
        t = 'ENVMAP_BLENDING_MIX';
        break;
      case iA:
        t = 'ENVMAP_BLENDING_ADD';
        break;
    }
  return t;
}
function $L(a) {
  const t = a.envMapCubeUVHeight;
  if (t === null) return null;
  const e = Math.log2(t) - 2,
    s = 1 / t;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: s, maxMip: e };
}
function tP(a, t, e, s) {
  const l = a.getContext(),
    h = e.defines;
  let f = e.vertexShader,
    m = e.fragmentShader;
  const _ = YL(e),
    g = KL(e),
    x = QL(e),
    S = JL(e),
    b = $L(e),
    E = HL(e),
    A = GL(h),
    R = l.createProgram();
  let T,
    M,
    z = e.glslVersion
      ? '#version ' +
        e.glslVersion +
        `
`
      : '';
  e.isRawShaderMaterial
    ? ((T = [
        '#define SHADER_TYPE ' + e.shaderType,
        '#define SHADER_NAME ' + e.shaderName,
        A,
      ].filter(su).join(`
`)),
      T.length > 0 &&
        (T += `
`),
      (M = ['#define SHADER_TYPE ' + e.shaderType, '#define SHADER_NAME ' + e.shaderName, A].filter(
        su,
      ).join(`
`)),
      M.length > 0 &&
        (M += `
`))
    : ((T = [
        Nx(e),
        '#define SHADER_TYPE ' + e.shaderType,
        '#define SHADER_NAME ' + e.shaderName,
        A,
        e.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
        e.batching ? '#define USE_BATCHING' : '',
        e.batchingColor ? '#define USE_BATCHING_COLOR' : '',
        e.instancing ? '#define USE_INSTANCING' : '',
        e.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
        e.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
        e.useFog && e.fog ? '#define USE_FOG' : '',
        e.useFog && e.fogExp2 ? '#define FOG_EXP2' : '',
        e.map ? '#define USE_MAP' : '',
        e.envMap ? '#define USE_ENVMAP' : '',
        e.envMap ? '#define ' + x : '',
        e.lightMap ? '#define USE_LIGHTMAP' : '',
        e.aoMap ? '#define USE_AOMAP' : '',
        e.bumpMap ? '#define USE_BUMPMAP' : '',
        e.normalMap ? '#define USE_NORMALMAP' : '',
        e.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        e.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        e.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
        e.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        e.anisotropy ? '#define USE_ANISOTROPY' : '',
        e.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        e.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        e.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        e.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        e.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        e.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        e.specularMap ? '#define USE_SPECULARMAP' : '',
        e.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        e.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        e.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        e.metalnessMap ? '#define USE_METALNESSMAP' : '',
        e.alphaMap ? '#define USE_ALPHAMAP' : '',
        e.alphaHash ? '#define USE_ALPHAHASH' : '',
        e.transmission ? '#define USE_TRANSMISSION' : '',
        e.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        e.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        e.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        e.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        e.mapUv ? '#define MAP_UV ' + e.mapUv : '',
        e.alphaMapUv ? '#define ALPHAMAP_UV ' + e.alphaMapUv : '',
        e.lightMapUv ? '#define LIGHTMAP_UV ' + e.lightMapUv : '',
        e.aoMapUv ? '#define AOMAP_UV ' + e.aoMapUv : '',
        e.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + e.emissiveMapUv : '',
        e.bumpMapUv ? '#define BUMPMAP_UV ' + e.bumpMapUv : '',
        e.normalMapUv ? '#define NORMALMAP_UV ' + e.normalMapUv : '',
        e.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + e.displacementMapUv : '',
        e.metalnessMapUv ? '#define METALNESSMAP_UV ' + e.metalnessMapUv : '',
        e.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + e.roughnessMapUv : '',
        e.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + e.anisotropyMapUv : '',
        e.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + e.clearcoatMapUv : '',
        e.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + e.clearcoatNormalMapUv : '',
        e.clearcoatRoughnessMapUv
          ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + e.clearcoatRoughnessMapUv
          : '',
        e.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + e.iridescenceMapUv : '',
        e.iridescenceThicknessMapUv
          ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + e.iridescenceThicknessMapUv
          : '',
        e.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + e.sheenColorMapUv : '',
        e.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + e.sheenRoughnessMapUv : '',
        e.specularMapUv ? '#define SPECULARMAP_UV ' + e.specularMapUv : '',
        e.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + e.specularColorMapUv : '',
        e.specularIntensityMapUv
          ? '#define SPECULAR_INTENSITYMAP_UV ' + e.specularIntensityMapUv
          : '',
        e.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + e.transmissionMapUv : '',
        e.thicknessMapUv ? '#define THICKNESSMAP_UV ' + e.thicknessMapUv : '',
        e.vertexTangents && e.flatShading === !1 ? '#define USE_TANGENT' : '',
        e.vertexColors ? '#define USE_COLOR' : '',
        e.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        e.vertexUv1s ? '#define USE_UV1' : '',
        e.vertexUv2s ? '#define USE_UV2' : '',
        e.vertexUv3s ? '#define USE_UV3' : '',
        e.pointsUvs ? '#define USE_POINTS_UV' : '',
        e.flatShading ? '#define FLAT_SHADED' : '',
        e.skinning ? '#define USE_SKINNING' : '',
        e.morphTargets ? '#define USE_MORPHTARGETS' : '',
        e.morphNormals && e.flatShading === !1 ? '#define USE_MORPHNORMALS' : '',
        e.morphColors ? '#define USE_MORPHCOLORS' : '',
        e.morphTargetsCount > 0
          ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + e.morphTextureStride
          : '',
        e.morphTargetsCount > 0 ? '#define MORPHTARGETS_COUNT ' + e.morphTargetsCount : '',
        e.doubleSided ? '#define DOUBLE_SIDED' : '',
        e.flipSided ? '#define FLIP_SIDED' : '',
        e.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        e.shadowMapEnabled ? '#define ' + _ : '',
        e.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        e.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        e.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        e.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        '#ifdef USE_INSTANCING',
        '	attribute mat4 instanceMatrix;',
        '#endif',
        '#ifdef USE_INSTANCING_COLOR',
        '	attribute vec3 instanceColor;',
        '#endif',
        '#ifdef USE_INSTANCING_MORPH',
        '	uniform sampler2D morphTexture;',
        '#endif',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_UV1',
        '	attribute vec2 uv1;',
        '#endif',
        '#ifdef USE_UV2',
        '	attribute vec2 uv2;',
        '#endif',
        '#ifdef USE_UV3',
        '	attribute vec2 uv3;',
        '#endif',
        '#ifdef USE_TANGENT',
        '	attribute vec4 tangent;',
        '#endif',
        '#if defined( USE_COLOR_ALPHA )',
        '	attribute vec4 color;',
        '#elif defined( USE_COLOR )',
        '	attribute vec3 color;',
        '#endif',
        '#ifdef USE_SKINNING',
        '	attribute vec4 skinIndex;',
        '	attribute vec4 skinWeight;',
        '#endif',
        `
`,
      ].filter(su).join(`
`)),
      (M = [
        Nx(e),
        '#define SHADER_TYPE ' + e.shaderType,
        '#define SHADER_NAME ' + e.shaderName,
        A,
        e.useFog && e.fog ? '#define USE_FOG' : '',
        e.useFog && e.fogExp2 ? '#define FOG_EXP2' : '',
        e.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
        e.map ? '#define USE_MAP' : '',
        e.matcap ? '#define USE_MATCAP' : '',
        e.envMap ? '#define USE_ENVMAP' : '',
        e.envMap ? '#define ' + g : '',
        e.envMap ? '#define ' + x : '',
        e.envMap ? '#define ' + S : '',
        b ? '#define CUBEUV_TEXEL_WIDTH ' + b.texelWidth : '',
        b ? '#define CUBEUV_TEXEL_HEIGHT ' + b.texelHeight : '',
        b ? '#define CUBEUV_MAX_MIP ' + b.maxMip + '.0' : '',
        e.lightMap ? '#define USE_LIGHTMAP' : '',
        e.aoMap ? '#define USE_AOMAP' : '',
        e.bumpMap ? '#define USE_BUMPMAP' : '',
        e.normalMap ? '#define USE_NORMALMAP' : '',
        e.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        e.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        e.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        e.anisotropy ? '#define USE_ANISOTROPY' : '',
        e.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        e.clearcoat ? '#define USE_CLEARCOAT' : '',
        e.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        e.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        e.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        e.dispersion ? '#define USE_DISPERSION' : '',
        e.iridescence ? '#define USE_IRIDESCENCE' : '',
        e.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        e.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        e.specularMap ? '#define USE_SPECULARMAP' : '',
        e.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        e.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        e.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        e.metalnessMap ? '#define USE_METALNESSMAP' : '',
        e.alphaMap ? '#define USE_ALPHAMAP' : '',
        e.alphaTest ? '#define USE_ALPHATEST' : '',
        e.alphaHash ? '#define USE_ALPHAHASH' : '',
        e.sheen ? '#define USE_SHEEN' : '',
        e.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        e.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        e.transmission ? '#define USE_TRANSMISSION' : '',
        e.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        e.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        e.vertexTangents && e.flatShading === !1 ? '#define USE_TANGENT' : '',
        e.vertexColors || e.instancingColor || e.batchingColor ? '#define USE_COLOR' : '',
        e.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        e.vertexUv1s ? '#define USE_UV1' : '',
        e.vertexUv2s ? '#define USE_UV2' : '',
        e.vertexUv3s ? '#define USE_UV3' : '',
        e.pointsUvs ? '#define USE_POINTS_UV' : '',
        e.gradientMap ? '#define USE_GRADIENTMAP' : '',
        e.flatShading ? '#define FLAT_SHADED' : '',
        e.doubleSided ? '#define DOUBLE_SIDED' : '',
        e.flipSided ? '#define FLIP_SIDED' : '',
        e.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        e.shadowMapEnabled ? '#define ' + _ : '',
        e.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        e.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        e.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
        e.decodeVideoTextureEmissive ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE' : '',
        e.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        e.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        e.toneMapping !== Us ? '#define TONE_MAPPING' : '',
        e.toneMapping !== Us ? Fe.tonemapping_pars_fragment : '',
        e.toneMapping !== Us ? kL('toneMapping', e.toneMapping) : '',
        e.dithering ? '#define DITHERING' : '',
        e.opaque ? '#define OPAQUE' : '',
        Fe.colorspace_pars_fragment,
        BL('linearToOutputTexel', e.outputColorSpace),
        FL(),
        e.useDepthPacking ? '#define DEPTH_PACKING ' + e.depthPacking : '',
        `
`,
      ].filter(su).join(`
`))),
    (f = P_(f)),
    (f = Dx(f, e)),
    (f = Ox(f, e)),
    (m = P_(m)),
    (m = Dx(m, e)),
    (m = Ox(m, e)),
    (f = Ux(f)),
    (m = Ux(m)),
    e.isRawShaderMaterial !== !0 &&
      ((z = `#version 300 es
`),
      (T =
        [E, '#define attribute in', '#define varying out', '#define texture2D texture'].join(`
`) +
        `
` +
        T),
      (M =
        [
          '#define varying in',
          e.glslVersion === By ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
          e.glslVersion === By ? '' : '#define gl_FragColor pc_fragColor',
          '#define gl_FragDepthEXT gl_FragDepth',
          '#define texture2D texture',
          '#define textureCube texture',
          '#define texture2DProj textureProj',
          '#define texture2DLodEXT textureLod',
          '#define texture2DProjLodEXT textureProjLod',
          '#define textureCubeLodEXT textureLod',
          '#define texture2DGradEXT textureGrad',
          '#define texture2DProjGradEXT textureProjGrad',
          '#define textureCubeGradEXT textureGrad',
        ].join(`
`) +
        `
` +
        M));
  const P = z + T + f,
    D = z + M + m,
    W = Rx(l, l.VERTEX_SHADER, P),
    Z = Rx(l, l.FRAGMENT_SHADER, D);
  l.attachShader(R, W),
    l.attachShader(R, Z),
    e.index0AttributeName !== void 0
      ? l.bindAttribLocation(R, 0, e.index0AttributeName)
      : e.morphTargets === !0 && l.bindAttribLocation(R, 0, 'position'),
    l.linkProgram(R);
  function V(j) {
    if (a.debug.checkShaderErrors) {
      const ft = l.getProgramInfoLog(R).trim(),
        pt = l.getShaderInfoLog(W).trim(),
        Mt = l.getShaderInfoLog(Z).trim();
      let bt = !0,
        X = !0;
      if (l.getProgramParameter(R, l.LINK_STATUS) === !1)
        if (((bt = !1), typeof a.debug.onShaderError == 'function'))
          a.debug.onShaderError(l, R, W, Z);
        else {
          const it = Px(l, W, 'vertex'),
            K = Px(l, Z, 'fragment');
          console.error(
            'THREE.WebGLProgram: Shader Error ' +
              l.getError() +
              ' - VALIDATE_STATUS ' +
              l.getProgramParameter(R, l.VALIDATE_STATUS) +
              `

Material Name: ` +
              j.name +
              `
Material Type: ` +
              j.type +
              `

Program Info Log: ` +
              ft +
              `
` +
              it +
              `
` +
              K,
          );
        }
      else
        ft !== ''
          ? console.warn('THREE.WebGLProgram: Program Info Log:', ft)
          : (pt === '' || Mt === '') && (X = !1);
      X &&
        (j.diagnostics = {
          runnable: bt,
          programLog: ft,
          vertexShader: { log: pt, prefix: T },
          fragmentShader: { log: Mt, prefix: M },
        });
    }
    l.deleteShader(W), l.deleteShader(Z), (J = new Df(l, R)), (F = VL(l, R));
  }
  let J;
  this.getUniforms = function () {
    return J === void 0 && V(this), J;
  };
  let F;
  this.getAttributes = function () {
    return F === void 0 && V(this), F;
  };
  let I = e.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return I === !1 && (I = l.getProgramParameter(R, UL)), I;
    }),
    (this.destroy = function () {
      s.releaseStatesOfProgram(this), l.deleteProgram(R), (this.program = void 0);
    }),
    (this.type = e.shaderType),
    (this.name = e.shaderName),
    (this.id = NL++),
    (this.cacheKey = t),
    (this.usedTimes = 1),
    (this.program = R),
    (this.vertexShader = W),
    (this.fragmentShader = Z),
    this
  );
}
let eP = 0;
class nP {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(t) {
    const e = t.vertexShader,
      s = t.fragmentShader,
      l = this._getShaderStage(e),
      h = this._getShaderStage(s),
      f = this._getShaderCacheForMaterial(t);
    return (
      f.has(l) === !1 && (f.add(l), l.usedTimes++),
      f.has(h) === !1 && (f.add(h), h.usedTimes++),
      this
    );
  }
  remove(t) {
    const e = this.materialCache.get(t);
    for (const s of e) s.usedTimes--, s.usedTimes === 0 && this.shaderCache.delete(s.code);
    return this.materialCache.delete(t), this;
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id;
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache;
    let s = e.get(t);
    return s === void 0 && ((s = new Set()), e.set(t, s)), s;
  }
  _getShaderStage(t) {
    const e = this.shaderCache;
    let s = e.get(t);
    return s === void 0 && ((s = new iP(t)), e.set(t, s)), s;
  }
}
class iP {
  constructor(t) {
    (this.id = eP++), (this.code = t), (this.usedTimes = 0);
  }
}
function aP(a, t, e, s, l, h, f) {
  const m = new JS(),
    _ = new nP(),
    g = new Set(),
    x = [],
    S = l.logarithmicDepthBuffer,
    b = l.vertexTextures;
  let E = l.precision;
  const A = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite',
  };
  function R(F) {
    return g.add(F), F === 0 ? 'uv' : `uv${F}`;
  }
  function T(F, I, j, ft, pt) {
    const Mt = ft.fog,
      bt = pt.geometry,
      X = F.isMeshStandardMaterial ? ft.environment : null,
      it = (F.isMeshStandardMaterial ? e : t).get(F.envMap || X),
      K = it && it.mapping === Xf ? it.image.height : null,
      zt = A[F.type];
    F.precision !== null &&
      ((E = l.getMaxPrecision(F.precision)),
      E !== F.precision &&
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          F.precision,
          'not supported, using',
          E,
          'instead.',
        ));
    const N = bt.morphAttributes.position || bt.morphAttributes.normal || bt.morphAttributes.color,
      Q = N !== void 0 ? N.length : 0;
    let gt = 0;
    bt.morphAttributes.position !== void 0 && (gt = 1),
      bt.morphAttributes.normal !== void 0 && (gt = 2),
      bt.morphAttributes.color !== void 0 && (gt = 3);
    let At, tt, st, _t;
    if (zt) {
      const Ye = Xa[zt];
      (At = Ye.vertexShader), (tt = Ye.fragmentShader);
    } else
      (At = F.vertexShader),
        (tt = F.fragmentShader),
        _.update(F),
        (st = _.getVertexShaderID(F)),
        (_t = _.getFragmentShaderID(F));
    const It = a.getRenderTarget(),
      Gt = a.state.buffers.depth.getReversed(),
      fe = pt.isInstancedMesh === !0,
      oe = pt.isBatchedMesh === !0,
      Ne = !!F.map,
      Te = !!F.matcap,
      ye = !!it,
      G = !!F.aoMap,
      Zt = !!F.lightMap,
      Bt = !!F.bumpMap,
      Ut = !!F.normalMap,
      Lt = !!F.displacementMap,
      le = !!F.emissiveMap,
      kt = !!F.metalnessMap,
      H = !!F.roughnessMap,
      O = F.anisotropy > 0,
      rt = F.clearcoat > 0,
      wt = F.dispersion > 0,
      Dt = F.iridescence > 0,
      Et = F.sheen > 0,
      Xt = F.transmission > 0,
      Wt = O && !!F.anisotropyMap,
      $t = rt && !!F.clearcoatMap,
      ce = rt && !!F.clearcoatNormalMap,
      Ht = rt && !!F.clearcoatRoughnessMap,
      re = Dt && !!F.iridescenceMap,
      pe = Dt && !!F.iridescenceThicknessMap,
      Se = Et && !!F.sheenColorMap,
      Qt = Et && !!F.sheenRoughnessMap,
      Oe = !!F.specularMap,
      Me = !!F.specularColorMap,
      Je = !!F.specularIntensityMap,
      nt = Xt && !!F.transmissionMap,
      qt = Xt && !!F.thicknessMap,
      Ct = !!F.gradientMap,
      Ot = !!F.alphaMap,
      ae = F.alphaTest > 0,
      te = !!F.alphaHash,
      Pe = !!F.extensions;
    let cn = Us;
    F.toneMapped && (It === null || It.isXRRenderTarget === !0) && (cn = a.toneMapping);
    const Rn = {
      shaderID: zt,
      shaderType: F.type,
      shaderName: F.name,
      vertexShader: At,
      fragmentShader: tt,
      defines: F.defines,
      customVertexShaderID: st,
      customFragmentShaderID: _t,
      isRawShaderMaterial: F.isRawShaderMaterial === !0,
      glslVersion: F.glslVersion,
      precision: E,
      batching: oe,
      batchingColor: oe && pt._colorsTexture !== null,
      instancing: fe,
      instancingColor: fe && pt.instanceColor !== null,
      instancingMorph: fe && pt.morphTexture !== null,
      supportsVertexTextures: b,
      outputColorSpace:
        It === null ? a.outputColorSpace : It.isXRRenderTarget === !0 ? It.texture.colorSpace : Gl,
      alphaToCoverage: !!F.alphaToCoverage,
      map: Ne,
      matcap: Te,
      envMap: ye,
      envMapMode: ye && it.mapping,
      envMapCubeUVHeight: K,
      aoMap: G,
      lightMap: Zt,
      bumpMap: Bt,
      normalMap: Ut,
      displacementMap: b && Lt,
      emissiveMap: le,
      normalMapObjectSpace: Ut && F.normalMapType === pA,
      normalMapTangentSpace: Ut && F.normalMapType === qS,
      metalnessMap: kt,
      roughnessMap: H,
      anisotropy: O,
      anisotropyMap: Wt,
      clearcoat: rt,
      clearcoatMap: $t,
      clearcoatNormalMap: ce,
      clearcoatRoughnessMap: Ht,
      dispersion: wt,
      iridescence: Dt,
      iridescenceMap: re,
      iridescenceThicknessMap: pe,
      sheen: Et,
      sheenColorMap: Se,
      sheenRoughnessMap: Qt,
      specularMap: Oe,
      specularColorMap: Me,
      specularIntensityMap: Je,
      transmission: Xt,
      transmissionMap: nt,
      thicknessMap: qt,
      gradientMap: Ct,
      opaque: F.transparent === !1 && F.blending === zl && F.alphaToCoverage === !1,
      alphaMap: Ot,
      alphaTest: ae,
      alphaHash: te,
      combine: F.combine,
      mapUv: Ne && R(F.map.channel),
      aoMapUv: G && R(F.aoMap.channel),
      lightMapUv: Zt && R(F.lightMap.channel),
      bumpMapUv: Bt && R(F.bumpMap.channel),
      normalMapUv: Ut && R(F.normalMap.channel),
      displacementMapUv: Lt && R(F.displacementMap.channel),
      emissiveMapUv: le && R(F.emissiveMap.channel),
      metalnessMapUv: kt && R(F.metalnessMap.channel),
      roughnessMapUv: H && R(F.roughnessMap.channel),
      anisotropyMapUv: Wt && R(F.anisotropyMap.channel),
      clearcoatMapUv: $t && R(F.clearcoatMap.channel),
      clearcoatNormalMapUv: ce && R(F.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ht && R(F.clearcoatRoughnessMap.channel),
      iridescenceMapUv: re && R(F.iridescenceMap.channel),
      iridescenceThicknessMapUv: pe && R(F.iridescenceThicknessMap.channel),
      sheenColorMapUv: Se && R(F.sheenColorMap.channel),
      sheenRoughnessMapUv: Qt && R(F.sheenRoughnessMap.channel),
      specularMapUv: Oe && R(F.specularMap.channel),
      specularColorMapUv: Me && R(F.specularColorMap.channel),
      specularIntensityMapUv: Je && R(F.specularIntensityMap.channel),
      transmissionMapUv: nt && R(F.transmissionMap.channel),
      thicknessMapUv: qt && R(F.thicknessMap.channel),
      alphaMapUv: Ot && R(F.alphaMap.channel),
      vertexTangents: !!bt.attributes.tangent && (Ut || O),
      vertexColors: F.vertexColors,
      vertexAlphas:
        F.vertexColors === !0 && !!bt.attributes.color && bt.attributes.color.itemSize === 4,
      pointsUvs: pt.isPoints === !0 && !!bt.attributes.uv && (Ne || Ot),
      fog: !!Mt,
      useFog: F.fog === !0,
      fogExp2: !!Mt && Mt.isFogExp2,
      flatShading: F.flatShading === !0,
      sizeAttenuation: F.sizeAttenuation === !0,
      logarithmicDepthBuffer: S,
      reverseDepthBuffer: Gt,
      skinning: pt.isSkinnedMesh === !0,
      morphTargets: bt.morphAttributes.position !== void 0,
      morphNormals: bt.morphAttributes.normal !== void 0,
      morphColors: bt.morphAttributes.color !== void 0,
      morphTargetsCount: Q,
      morphTextureStride: gt,
      numDirLights: I.directional.length,
      numPointLights: I.point.length,
      numSpotLights: I.spot.length,
      numSpotLightMaps: I.spotLightMap.length,
      numRectAreaLights: I.rectArea.length,
      numHemiLights: I.hemi.length,
      numDirLightShadows: I.directionalShadowMap.length,
      numPointLightShadows: I.pointShadowMap.length,
      numSpotLightShadows: I.spotShadowMap.length,
      numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps,
      numLightProbes: I.numLightProbes,
      numClippingPlanes: f.numPlanes,
      numClipIntersection: f.numIntersection,
      dithering: F.dithering,
      shadowMapEnabled: a.shadowMap.enabled && j.length > 0,
      shadowMapType: a.shadowMap.type,
      toneMapping: cn,
      decodeVideoTexture:
        Ne && F.map.isVideoTexture === !0 && en.getTransfer(F.map.colorSpace) === dn,
      decodeVideoTextureEmissive:
        le &&
        F.emissiveMap.isVideoTexture === !0 &&
        en.getTransfer(F.emissiveMap.colorSpace) === dn,
      premultipliedAlpha: F.premultipliedAlpha,
      doubleSided: F.side === Dr,
      flipSided: F.side === Ni,
      useDepthPacking: F.depthPacking >= 0,
      depthPacking: F.depthPacking || 0,
      index0AttributeName: F.index0AttributeName,
      extensionClipCullDistance:
        Pe && F.extensions.clipCullDistance === !0 && s.has('WEBGL_clip_cull_distance'),
      extensionMultiDraw:
        ((Pe && F.extensions.multiDraw === !0) || oe) && s.has('WEBGL_multi_draw'),
      rendererExtensionParallelShaderCompile: s.has('KHR_parallel_shader_compile'),
      customProgramCacheKey: F.customProgramCacheKey(),
    };
    return (
      (Rn.vertexUv1s = g.has(1)),
      (Rn.vertexUv2s = g.has(2)),
      (Rn.vertexUv3s = g.has(3)),
      g.clear(),
      Rn
    );
  }
  function M(F) {
    const I = [];
    if (
      (F.shaderID
        ? I.push(F.shaderID)
        : (I.push(F.customVertexShaderID), I.push(F.customFragmentShaderID)),
      F.defines !== void 0)
    )
      for (const j in F.defines) I.push(j), I.push(F.defines[j]);
    return (
      F.isRawShaderMaterial === !1 && (z(I, F), P(I, F), I.push(a.outputColorSpace)),
      I.push(F.customProgramCacheKey),
      I.join()
    );
  }
  function z(F, I) {
    F.push(I.precision),
      F.push(I.outputColorSpace),
      F.push(I.envMapMode),
      F.push(I.envMapCubeUVHeight),
      F.push(I.mapUv),
      F.push(I.alphaMapUv),
      F.push(I.lightMapUv),
      F.push(I.aoMapUv),
      F.push(I.bumpMapUv),
      F.push(I.normalMapUv),
      F.push(I.displacementMapUv),
      F.push(I.emissiveMapUv),
      F.push(I.metalnessMapUv),
      F.push(I.roughnessMapUv),
      F.push(I.anisotropyMapUv),
      F.push(I.clearcoatMapUv),
      F.push(I.clearcoatNormalMapUv),
      F.push(I.clearcoatRoughnessMapUv),
      F.push(I.iridescenceMapUv),
      F.push(I.iridescenceThicknessMapUv),
      F.push(I.sheenColorMapUv),
      F.push(I.sheenRoughnessMapUv),
      F.push(I.specularMapUv),
      F.push(I.specularColorMapUv),
      F.push(I.specularIntensityMapUv),
      F.push(I.transmissionMapUv),
      F.push(I.thicknessMapUv),
      F.push(I.combine),
      F.push(I.fogExp2),
      F.push(I.sizeAttenuation),
      F.push(I.morphTargetsCount),
      F.push(I.morphAttributeCount),
      F.push(I.numDirLights),
      F.push(I.numPointLights),
      F.push(I.numSpotLights),
      F.push(I.numSpotLightMaps),
      F.push(I.numHemiLights),
      F.push(I.numRectAreaLights),
      F.push(I.numDirLightShadows),
      F.push(I.numPointLightShadows),
      F.push(I.numSpotLightShadows),
      F.push(I.numSpotLightShadowsWithMaps),
      F.push(I.numLightProbes),
      F.push(I.shadowMapType),
      F.push(I.toneMapping),
      F.push(I.numClippingPlanes),
      F.push(I.numClipIntersection),
      F.push(I.depthPacking);
  }
  function P(F, I) {
    m.disableAll(),
      I.supportsVertexTextures && m.enable(0),
      I.instancing && m.enable(1),
      I.instancingColor && m.enable(2),
      I.instancingMorph && m.enable(3),
      I.matcap && m.enable(4),
      I.envMap && m.enable(5),
      I.normalMapObjectSpace && m.enable(6),
      I.normalMapTangentSpace && m.enable(7),
      I.clearcoat && m.enable(8),
      I.iridescence && m.enable(9),
      I.alphaTest && m.enable(10),
      I.vertexColors && m.enable(11),
      I.vertexAlphas && m.enable(12),
      I.vertexUv1s && m.enable(13),
      I.vertexUv2s && m.enable(14),
      I.vertexUv3s && m.enable(15),
      I.vertexTangents && m.enable(16),
      I.anisotropy && m.enable(17),
      I.alphaHash && m.enable(18),
      I.batching && m.enable(19),
      I.dispersion && m.enable(20),
      I.batchingColor && m.enable(21),
      F.push(m.mask),
      m.disableAll(),
      I.fog && m.enable(0),
      I.useFog && m.enable(1),
      I.flatShading && m.enable(2),
      I.logarithmicDepthBuffer && m.enable(3),
      I.reverseDepthBuffer && m.enable(4),
      I.skinning && m.enable(5),
      I.morphTargets && m.enable(6),
      I.morphNormals && m.enable(7),
      I.morphColors && m.enable(8),
      I.premultipliedAlpha && m.enable(9),
      I.shadowMapEnabled && m.enable(10),
      I.doubleSided && m.enable(11),
      I.flipSided && m.enable(12),
      I.useDepthPacking && m.enable(13),
      I.dithering && m.enable(14),
      I.transmission && m.enable(15),
      I.sheen && m.enable(16),
      I.opaque && m.enable(17),
      I.pointsUvs && m.enable(18),
      I.decodeVideoTexture && m.enable(19),
      I.decodeVideoTextureEmissive && m.enable(20),
      I.alphaToCoverage && m.enable(21),
      F.push(m.mask);
  }
  function D(F) {
    const I = A[F.type];
    let j;
    if (I) {
      const ft = Xa[I];
      j = XA.clone(ft.uniforms);
    } else j = F.uniforms;
    return j;
  }
  function W(F, I) {
    let j;
    for (let ft = 0, pt = x.length; ft < pt; ft++) {
      const Mt = x[ft];
      if (Mt.cacheKey === I) {
        (j = Mt), ++j.usedTimes;
        break;
      }
    }
    return j === void 0 && ((j = new tP(a, I, F, h)), x.push(j)), j;
  }
  function Z(F) {
    if (--F.usedTimes === 0) {
      const I = x.indexOf(F);
      (x[I] = x[x.length - 1]), x.pop(), F.destroy();
    }
  }
  function V(F) {
    _.remove(F);
  }
  function J() {
    _.dispose();
  }
  return {
    getParameters: T,
    getProgramCacheKey: M,
    getUniforms: D,
    acquireProgram: W,
    releaseProgram: Z,
    releaseShaderCache: V,
    programs: x,
    dispose: J,
  };
}
function rP() {
  let a = new WeakMap();
  function t(f) {
    return a.has(f);
  }
  function e(f) {
    let m = a.get(f);
    return m === void 0 && ((m = {}), a.set(f, m)), m;
  }
  function s(f) {
    a.delete(f);
  }
  function l(f, m, _) {
    a.get(f)[m] = _;
  }
  function h() {
    a = new WeakMap();
  }
  return { has: t, get: e, remove: s, update: l, dispose: h };
}
function sP(a, t) {
  return a.groupOrder !== t.groupOrder
    ? a.groupOrder - t.groupOrder
    : a.renderOrder !== t.renderOrder
      ? a.renderOrder - t.renderOrder
      : a.material.id !== t.material.id
        ? a.material.id - t.material.id
        : a.z !== t.z
          ? a.z - t.z
          : a.id - t.id;
}
function zx(a, t) {
  return a.groupOrder !== t.groupOrder
    ? a.groupOrder - t.groupOrder
    : a.renderOrder !== t.renderOrder
      ? a.renderOrder - t.renderOrder
      : a.z !== t.z
        ? t.z - a.z
        : a.id - t.id;
}
function Ix() {
  const a = [];
  let t = 0;
  const e = [],
    s = [],
    l = [];
  function h() {
    (t = 0), (e.length = 0), (s.length = 0), (l.length = 0);
  }
  function f(S, b, E, A, R, T) {
    let M = a[t];
    return (
      M === void 0
        ? ((M = {
            id: S.id,
            object: S,
            geometry: b,
            material: E,
            groupOrder: A,
            renderOrder: S.renderOrder,
            z: R,
            group: T,
          }),
          (a[t] = M))
        : ((M.id = S.id),
          (M.object = S),
          (M.geometry = b),
          (M.material = E),
          (M.groupOrder = A),
          (M.renderOrder = S.renderOrder),
          (M.z = R),
          (M.group = T)),
      t++,
      M
    );
  }
  function m(S, b, E, A, R, T) {
    const M = f(S, b, E, A, R, T);
    E.transmission > 0 ? s.push(M) : E.transparent === !0 ? l.push(M) : e.push(M);
  }
  function _(S, b, E, A, R, T) {
    const M = f(S, b, E, A, R, T);
    E.transmission > 0 ? s.unshift(M) : E.transparent === !0 ? l.unshift(M) : e.unshift(M);
  }
  function g(S, b) {
    e.length > 1 && e.sort(S || sP),
      s.length > 1 && s.sort(b || zx),
      l.length > 1 && l.sort(b || zx);
  }
  function x() {
    for (let S = t, b = a.length; S < b; S++) {
      const E = a[S];
      if (E.id === null) break;
      (E.id = null), (E.object = null), (E.geometry = null), (E.material = null), (E.group = null);
    }
  }
  return {
    opaque: e,
    transmissive: s,
    transparent: l,
    init: h,
    push: m,
    unshift: _,
    finish: x,
    sort: g,
  };
}
function oP() {
  let a = new WeakMap();
  function t(s, l) {
    const h = a.get(s);
    let f;
    return (
      h === void 0
        ? ((f = new Ix()), a.set(s, [f]))
        : l >= h.length
          ? ((f = new Ix()), h.push(f))
          : (f = h[l]),
      f
    );
  }
  function e() {
    a = new WeakMap();
  }
  return { get: t, dispose: e };
}
function lP() {
  const a = {};
  return {
    get: function (t) {
      if (a[t.id] !== void 0) return a[t.id];
      let e;
      switch (t.type) {
        case 'DirectionalLight':
          e = { direction: new et(), color: new Qe() };
          break;
        case 'SpotLight':
          e = {
            position: new et(),
            direction: new et(),
            color: new Qe(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case 'PointLight':
          e = { position: new et(), color: new Qe(), distance: 0, decay: 0 };
          break;
        case 'HemisphereLight':
          e = { direction: new et(), skyColor: new Qe(), groundColor: new Qe() };
          break;
        case 'RectAreaLight':
          e = { color: new Qe(), position: new et(), halfWidth: new et(), halfHeight: new et() };
          break;
      }
      return (a[t.id] = e), e;
    },
  };
}
function cP() {
  const a = {};
  return {
    get: function (t) {
      if (a[t.id] !== void 0) return a[t.id];
      let e;
      switch (t.type) {
        case 'DirectionalLight':
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Yt(),
          };
          break;
        case 'SpotLight':
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Yt(),
          };
          break;
        case 'PointLight':
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Yt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (a[t.id] = e), e;
    },
  };
}
let uP = 0;
function hP(a, t) {
  return (t.castShadow ? 2 : 0) - (a.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (a.map ? 1 : 0);
}
function fP(a) {
  const t = new lP(),
    e = cP(),
    s = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let g = 0; g < 9; g++) s.probe.push(new et());
  const l = new et(),
    h = new En(),
    f = new En();
  function m(g) {
    let x = 0,
      S = 0,
      b = 0;
    for (let F = 0; F < 9; F++) s.probe[F].set(0, 0, 0);
    let E = 0,
      A = 0,
      R = 0,
      T = 0,
      M = 0,
      z = 0,
      P = 0,
      D = 0,
      W = 0,
      Z = 0,
      V = 0;
    g.sort(hP);
    for (let F = 0, I = g.length; F < I; F++) {
      const j = g[F],
        ft = j.color,
        pt = j.intensity,
        Mt = j.distance,
        bt = j.shadow && j.shadow.map ? j.shadow.map.texture : null;
      if (j.isAmbientLight) (x += ft.r * pt), (S += ft.g * pt), (b += ft.b * pt);
      else if (j.isLightProbe) {
        for (let X = 0; X < 9; X++) s.probe[X].addScaledVector(j.sh.coefficients[X], pt);
        V++;
      } else if (j.isDirectionalLight) {
        const X = t.get(j);
        if ((X.color.copy(j.color).multiplyScalar(j.intensity), j.castShadow)) {
          const it = j.shadow,
            K = e.get(j);
          (K.shadowIntensity = it.intensity),
            (K.shadowBias = it.bias),
            (K.shadowNormalBias = it.normalBias),
            (K.shadowRadius = it.radius),
            (K.shadowMapSize = it.mapSize),
            (s.directionalShadow[E] = K),
            (s.directionalShadowMap[E] = bt),
            (s.directionalShadowMatrix[E] = j.shadow.matrix),
            z++;
        }
        (s.directional[E] = X), E++;
      } else if (j.isSpotLight) {
        const X = t.get(j);
        X.position.setFromMatrixPosition(j.matrixWorld),
          X.color.copy(ft).multiplyScalar(pt),
          (X.distance = Mt),
          (X.coneCos = Math.cos(j.angle)),
          (X.penumbraCos = Math.cos(j.angle * (1 - j.penumbra))),
          (X.decay = j.decay),
          (s.spot[R] = X);
        const it = j.shadow;
        if (
          (j.map && ((s.spotLightMap[W] = j.map), W++, it.updateMatrices(j), j.castShadow && Z++),
          (s.spotLightMatrix[R] = it.matrix),
          j.castShadow)
        ) {
          const K = e.get(j);
          (K.shadowIntensity = it.intensity),
            (K.shadowBias = it.bias),
            (K.shadowNormalBias = it.normalBias),
            (K.shadowRadius = it.radius),
            (K.shadowMapSize = it.mapSize),
            (s.spotShadow[R] = K),
            (s.spotShadowMap[R] = bt),
            D++;
        }
        R++;
      } else if (j.isRectAreaLight) {
        const X = t.get(j);
        X.color.copy(ft).multiplyScalar(pt),
          X.halfWidth.set(j.width * 0.5, 0, 0),
          X.halfHeight.set(0, j.height * 0.5, 0),
          (s.rectArea[T] = X),
          T++;
      } else if (j.isPointLight) {
        const X = t.get(j);
        if (
          (X.color.copy(j.color).multiplyScalar(j.intensity),
          (X.distance = j.distance),
          (X.decay = j.decay),
          j.castShadow)
        ) {
          const it = j.shadow,
            K = e.get(j);
          (K.shadowIntensity = it.intensity),
            (K.shadowBias = it.bias),
            (K.shadowNormalBias = it.normalBias),
            (K.shadowRadius = it.radius),
            (K.shadowMapSize = it.mapSize),
            (K.shadowCameraNear = it.camera.near),
            (K.shadowCameraFar = it.camera.far),
            (s.pointShadow[A] = K),
            (s.pointShadowMap[A] = bt),
            (s.pointShadowMatrix[A] = j.shadow.matrix),
            P++;
        }
        (s.point[A] = X), A++;
      } else if (j.isHemisphereLight) {
        const X = t.get(j);
        X.skyColor.copy(j.color).multiplyScalar(pt),
          X.groundColor.copy(j.groundColor).multiplyScalar(pt),
          (s.hemi[M] = X),
          M++;
      }
    }
    T > 0 &&
      (a.has('OES_texture_float_linear') === !0
        ? ((s.rectAreaLTC1 = ee.LTC_FLOAT_1), (s.rectAreaLTC2 = ee.LTC_FLOAT_2))
        : ((s.rectAreaLTC1 = ee.LTC_HALF_1), (s.rectAreaLTC2 = ee.LTC_HALF_2))),
      (s.ambient[0] = x),
      (s.ambient[1] = S),
      (s.ambient[2] = b);
    const J = s.hash;
    (J.directionalLength !== E ||
      J.pointLength !== A ||
      J.spotLength !== R ||
      J.rectAreaLength !== T ||
      J.hemiLength !== M ||
      J.numDirectionalShadows !== z ||
      J.numPointShadows !== P ||
      J.numSpotShadows !== D ||
      J.numSpotMaps !== W ||
      J.numLightProbes !== V) &&
      ((s.directional.length = E),
      (s.spot.length = R),
      (s.rectArea.length = T),
      (s.point.length = A),
      (s.hemi.length = M),
      (s.directionalShadow.length = z),
      (s.directionalShadowMap.length = z),
      (s.pointShadow.length = P),
      (s.pointShadowMap.length = P),
      (s.spotShadow.length = D),
      (s.spotShadowMap.length = D),
      (s.directionalShadowMatrix.length = z),
      (s.pointShadowMatrix.length = P),
      (s.spotLightMatrix.length = D + W - Z),
      (s.spotLightMap.length = W),
      (s.numSpotLightShadowsWithMaps = Z),
      (s.numLightProbes = V),
      (J.directionalLength = E),
      (J.pointLength = A),
      (J.spotLength = R),
      (J.rectAreaLength = T),
      (J.hemiLength = M),
      (J.numDirectionalShadows = z),
      (J.numPointShadows = P),
      (J.numSpotShadows = D),
      (J.numSpotMaps = W),
      (J.numLightProbes = V),
      (s.version = uP++));
  }
  function _(g, x) {
    let S = 0,
      b = 0,
      E = 0,
      A = 0,
      R = 0;
    const T = x.matrixWorldInverse;
    for (let M = 0, z = g.length; M < z; M++) {
      const P = g[M];
      if (P.isDirectionalLight) {
        const D = s.directional[S];
        D.direction.setFromMatrixPosition(P.matrixWorld),
          l.setFromMatrixPosition(P.target.matrixWorld),
          D.direction.sub(l),
          D.direction.transformDirection(T),
          S++;
      } else if (P.isSpotLight) {
        const D = s.spot[E];
        D.position.setFromMatrixPosition(P.matrixWorld),
          D.position.applyMatrix4(T),
          D.direction.setFromMatrixPosition(P.matrixWorld),
          l.setFromMatrixPosition(P.target.matrixWorld),
          D.direction.sub(l),
          D.direction.transformDirection(T),
          E++;
      } else if (P.isRectAreaLight) {
        const D = s.rectArea[A];
        D.position.setFromMatrixPosition(P.matrixWorld),
          D.position.applyMatrix4(T),
          f.identity(),
          h.copy(P.matrixWorld),
          h.premultiply(T),
          f.extractRotation(h),
          D.halfWidth.set(P.width * 0.5, 0, 0),
          D.halfHeight.set(0, P.height * 0.5, 0),
          D.halfWidth.applyMatrix4(f),
          D.halfHeight.applyMatrix4(f),
          A++;
      } else if (P.isPointLight) {
        const D = s.point[b];
        D.position.setFromMatrixPosition(P.matrixWorld), D.position.applyMatrix4(T), b++;
      } else if (P.isHemisphereLight) {
        const D = s.hemi[R];
        D.direction.setFromMatrixPosition(P.matrixWorld), D.direction.transformDirection(T), R++;
      }
    }
  }
  return { setup: m, setupView: _, state: s };
}
function Bx(a) {
  const t = new fP(a),
    e = [],
    s = [];
  function l(x) {
    (g.camera = x), (e.length = 0), (s.length = 0);
  }
  function h(x) {
    e.push(x);
  }
  function f(x) {
    s.push(x);
  }
  function m() {
    t.setup(e);
  }
  function _(x) {
    t.setupView(e, x);
  }
  const g = {
    lightsArray: e,
    shadowsArray: s,
    camera: null,
    lights: t,
    transmissionRenderTarget: {},
  };
  return { init: l, state: g, setupLights: m, setupLightsView: _, pushLight: h, pushShadow: f };
}
function dP(a) {
  let t = new WeakMap();
  function e(l, h = 0) {
    const f = t.get(l);
    let m;
    return (
      f === void 0
        ? ((m = new Bx(a)), t.set(l, [m]))
        : h >= f.length
          ? ((m = new Bx(a)), f.push(m))
          : (m = f[h]),
      m
    );
  }
  function s() {
    t = new WeakMap();
  }
  return { get: e, dispose: s };
}
const pP = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  mP = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function _P(a, t, e) {
  let s = new ag();
  const l = new Yt(),
    h = new Yt(),
    f = new Un(),
    m = new U2({ depthPacking: dA }),
    _ = new N2(),
    g = {},
    x = e.maxTextureSize,
    S = { [Ns]: Ni, [Ni]: Ns, [Dr]: Dr },
    b = new zs({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Yt() },
        radius: { value: 4 },
      },
      vertexShader: pP,
      fragmentShader: mP,
    }),
    E = b.clone();
  E.defines.HORIZONTAL_PASS = 1;
  const A = new $i();
  A.setAttribute('position', new ma(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const R = new bn(A, b),
    T = this;
  (this.enabled = !1), (this.autoUpdate = !0), (this.needsUpdate = !1), (this.type = BS);
  let M = this.type;
  this.render = function (Z, V, J) {
    if (T.enabled === !1 || (T.autoUpdate === !1 && T.needsUpdate === !1) || Z.length === 0) return;
    const F = a.getRenderTarget(),
      I = a.getActiveCubeFace(),
      j = a.getActiveMipmapLevel(),
      ft = a.state;
    ft.setBlending(Os),
      ft.buffers.color.setClear(1, 1, 1, 1),
      ft.buffers.depth.setTest(!0),
      ft.setScissorTest(!1);
    const pt = M !== Pr && this.type === Pr,
      Mt = M === Pr && this.type !== Pr;
    for (let bt = 0, X = Z.length; bt < X; bt++) {
      const it = Z[bt],
        K = it.shadow;
      if (K === void 0) {
        console.warn('THREE.WebGLShadowMap:', it, 'has no shadow.');
        continue;
      }
      if (K.autoUpdate === !1 && K.needsUpdate === !1) continue;
      l.copy(K.mapSize);
      const zt = K.getFrameExtents();
      if (
        (l.multiply(zt),
        h.copy(K.mapSize),
        (l.x > x || l.y > x) &&
          (l.x > x && ((h.x = Math.floor(x / zt.x)), (l.x = h.x * zt.x), (K.mapSize.x = h.x)),
          l.y > x && ((h.y = Math.floor(x / zt.y)), (l.y = h.y * zt.y), (K.mapSize.y = h.y))),
        K.map === null || pt === !0 || Mt === !0)
      ) {
        const Q = this.type !== Pr ? { minFilter: Da, magFilter: Da } : {};
        K.map !== null && K.map.dispose(),
          (K.map = new Eo(l.x, l.y, Q)),
          (K.map.texture.name = it.name + '.shadowMap'),
          K.camera.updateProjectionMatrix();
      }
      a.setRenderTarget(K.map), a.clear();
      const N = K.getViewportCount();
      for (let Q = 0; Q < N; Q++) {
        const gt = K.getViewport(Q);
        f.set(h.x * gt.x, h.y * gt.y, h.x * gt.z, h.y * gt.w),
          ft.viewport(f),
          K.updateMatrices(it, Q),
          (s = K.getFrustum()),
          D(V, J, K.camera, it, this.type);
      }
      K.isPointLightShadow !== !0 && this.type === Pr && z(K, J), (K.needsUpdate = !1);
    }
    (M = this.type), (T.needsUpdate = !1), a.setRenderTarget(F, I, j);
  };
  function z(Z, V) {
    const J = t.update(R);
    b.defines.VSM_SAMPLES !== Z.blurSamples &&
      ((b.defines.VSM_SAMPLES = Z.blurSamples),
      (E.defines.VSM_SAMPLES = Z.blurSamples),
      (b.needsUpdate = !0),
      (E.needsUpdate = !0)),
      Z.mapPass === null && (Z.mapPass = new Eo(l.x, l.y)),
      (b.uniforms.shadow_pass.value = Z.map.texture),
      (b.uniforms.resolution.value = Z.mapSize),
      (b.uniforms.radius.value = Z.radius),
      a.setRenderTarget(Z.mapPass),
      a.clear(),
      a.renderBufferDirect(V, null, J, b, R, null),
      (E.uniforms.shadow_pass.value = Z.mapPass.texture),
      (E.uniforms.resolution.value = Z.mapSize),
      (E.uniforms.radius.value = Z.radius),
      a.setRenderTarget(Z.map),
      a.clear(),
      a.renderBufferDirect(V, null, J, E, R, null);
  }
  function P(Z, V, J, F) {
    let I = null;
    const j = J.isPointLight === !0 ? Z.customDistanceMaterial : Z.customDepthMaterial;
    if (j !== void 0) I = j;
    else if (
      ((I = J.isPointLight === !0 ? _ : m),
      (a.localClippingEnabled &&
        V.clipShadows === !0 &&
        Array.isArray(V.clippingPlanes) &&
        V.clippingPlanes.length !== 0) ||
        (V.displacementMap && V.displacementScale !== 0) ||
        (V.alphaMap && V.alphaTest > 0) ||
        (V.map && V.alphaTest > 0) ||
        V.alphaToCoverage === !0)
    ) {
      const ft = I.uuid,
        pt = V.uuid;
      let Mt = g[ft];
      Mt === void 0 && ((Mt = {}), (g[ft] = Mt));
      let bt = Mt[pt];
      bt === void 0 && ((bt = I.clone()), (Mt[pt] = bt), V.addEventListener('dispose', W)),
        (I = bt);
    }
    if (
      ((I.visible = V.visible),
      (I.wireframe = V.wireframe),
      F === Pr
        ? (I.side = V.shadowSide !== null ? V.shadowSide : V.side)
        : (I.side = V.shadowSide !== null ? V.shadowSide : S[V.side]),
      (I.alphaMap = V.alphaMap),
      (I.alphaTest = V.alphaToCoverage === !0 ? 0.5 : V.alphaTest),
      (I.map = V.map),
      (I.clipShadows = V.clipShadows),
      (I.clippingPlanes = V.clippingPlanes),
      (I.clipIntersection = V.clipIntersection),
      (I.displacementMap = V.displacementMap),
      (I.displacementScale = V.displacementScale),
      (I.displacementBias = V.displacementBias),
      (I.wireframeLinewidth = V.wireframeLinewidth),
      (I.linewidth = V.linewidth),
      J.isPointLight === !0 && I.isMeshDistanceMaterial === !0)
    ) {
      const ft = a.properties.get(I);
      ft.light = J;
    }
    return I;
  }
  function D(Z, V, J, F, I) {
    if (Z.visible === !1) return;
    if (
      Z.layers.test(V.layers) &&
      (Z.isMesh || Z.isLine || Z.isPoints) &&
      (Z.castShadow || (Z.receiveShadow && I === Pr)) &&
      (!Z.frustumCulled || s.intersectsObject(Z))
    ) {
      Z.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse, Z.matrixWorld);
      const pt = t.update(Z),
        Mt = Z.material;
      if (Array.isArray(Mt)) {
        const bt = pt.groups;
        for (let X = 0, it = bt.length; X < it; X++) {
          const K = bt[X],
            zt = Mt[K.materialIndex];
          if (zt && zt.visible) {
            const N = P(Z, zt, F, I);
            Z.onBeforeShadow(a, Z, V, J, pt, N, K),
              a.renderBufferDirect(J, null, pt, N, Z, K),
              Z.onAfterShadow(a, Z, V, J, pt, N, K);
          }
        }
      } else if (Mt.visible) {
        const bt = P(Z, Mt, F, I);
        Z.onBeforeShadow(a, Z, V, J, pt, bt, null),
          a.renderBufferDirect(J, null, pt, bt, Z, null),
          Z.onAfterShadow(a, Z, V, J, pt, bt, null);
      }
    }
    const ft = Z.children;
    for (let pt = 0, Mt = ft.length; pt < Mt; pt++) D(ft[pt], V, J, F, I);
  }
  function W(Z) {
    Z.target.removeEventListener('dispose', W);
    for (const J in g) {
      const F = g[J],
        I = Z.target.uuid;
      I in F && (F[I].dispose(), delete F[I]);
    }
  }
}
const gP = { [Hm]: Gm, [Vm]: Xm, [Wm]: jm, [kl]: Zm, [Gm]: Hm, [Xm]: Vm, [jm]: Wm, [Zm]: kl };
function vP(a, t) {
  function e() {
    let nt = !1;
    const qt = new Un();
    let Ct = null;
    const Ot = new Un(0, 0, 0, 0);
    return {
      setMask: function (ae) {
        Ct !== ae && !nt && (a.colorMask(ae, ae, ae, ae), (Ct = ae));
      },
      setLocked: function (ae) {
        nt = ae;
      },
      setClear: function (ae, te, Pe, cn, Rn) {
        Rn === !0 && ((ae *= cn), (te *= cn), (Pe *= cn)),
          qt.set(ae, te, Pe, cn),
          Ot.equals(qt) === !1 && (a.clearColor(ae, te, Pe, cn), Ot.copy(qt));
      },
      reset: function () {
        (nt = !1), (Ct = null), Ot.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let nt = !1,
      qt = !1,
      Ct = null,
      Ot = null,
      ae = null;
    return {
      setReversed: function (te) {
        if (qt !== te) {
          const Pe = t.get('EXT_clip_control');
          te
            ? Pe.clipControlEXT(Pe.LOWER_LEFT_EXT, Pe.ZERO_TO_ONE_EXT)
            : Pe.clipControlEXT(Pe.LOWER_LEFT_EXT, Pe.NEGATIVE_ONE_TO_ONE_EXT),
            (qt = te);
          const cn = ae;
          (ae = null), this.setClear(cn);
        }
      },
      getReversed: function () {
        return qt;
      },
      setTest: function (te) {
        te ? It(a.DEPTH_TEST) : Gt(a.DEPTH_TEST);
      },
      setMask: function (te) {
        Ct !== te && !nt && (a.depthMask(te), (Ct = te));
      },
      setFunc: function (te) {
        if ((qt && (te = gP[te]), Ot !== te)) {
          switch (te) {
            case Hm:
              a.depthFunc(a.NEVER);
              break;
            case Gm:
              a.depthFunc(a.ALWAYS);
              break;
            case Vm:
              a.depthFunc(a.LESS);
              break;
            case kl:
              a.depthFunc(a.LEQUAL);
              break;
            case Wm:
              a.depthFunc(a.EQUAL);
              break;
            case Zm:
              a.depthFunc(a.GEQUAL);
              break;
            case Xm:
              a.depthFunc(a.GREATER);
              break;
            case jm:
              a.depthFunc(a.NOTEQUAL);
              break;
            default:
              a.depthFunc(a.LEQUAL);
          }
          Ot = te;
        }
      },
      setLocked: function (te) {
        nt = te;
      },
      setClear: function (te) {
        ae !== te && (qt && (te = 1 - te), a.clearDepth(te), (ae = te));
      },
      reset: function () {
        (nt = !1), (Ct = null), (Ot = null), (ae = null), (qt = !1);
      },
    };
  }
  function l() {
    let nt = !1,
      qt = null,
      Ct = null,
      Ot = null,
      ae = null,
      te = null,
      Pe = null,
      cn = null,
      Rn = null;
    return {
      setTest: function (Ye) {
        nt || (Ye ? It(a.STENCIL_TEST) : Gt(a.STENCIL_TEST));
      },
      setMask: function (Ye) {
        qt !== Ye && !nt && (a.stencilMask(Ye), (qt = Ye));
      },
      setFunc: function (Ye, ii, kn) {
        (Ct !== Ye || Ot !== ii || ae !== kn) &&
          (a.stencilFunc(Ye, ii, kn), (Ct = Ye), (Ot = ii), (ae = kn));
      },
      setOp: function (Ye, ii, kn) {
        (te !== Ye || Pe !== ii || cn !== kn) &&
          (a.stencilOp(Ye, ii, kn), (te = Ye), (Pe = ii), (cn = kn));
      },
      setLocked: function (Ye) {
        nt = Ye;
      },
      setClear: function (Ye) {
        Rn !== Ye && (a.clearStencil(Ye), (Rn = Ye));
      },
      reset: function () {
        (nt = !1),
          (qt = null),
          (Ct = null),
          (Ot = null),
          (ae = null),
          (te = null),
          (Pe = null),
          (cn = null),
          (Rn = null);
      },
    };
  }
  const h = new e(),
    f = new s(),
    m = new l(),
    _ = new WeakMap(),
    g = new WeakMap();
  let x = {},
    S = {},
    b = new WeakMap(),
    E = [],
    A = null,
    R = !1,
    T = null,
    M = null,
    z = null,
    P = null,
    D = null,
    W = null,
    Z = null,
    V = new Qe(0, 0, 0),
    J = 0,
    F = !1,
    I = null,
    j = null,
    ft = null,
    pt = null,
    Mt = null;
  const bt = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let X = !1,
    it = 0;
  const K = a.getParameter(a.VERSION);
  K.indexOf('WebGL') !== -1
    ? ((it = parseFloat(/^WebGL (\d)/.exec(K)[1])), (X = it >= 1))
    : K.indexOf('OpenGL ES') !== -1 &&
      ((it = parseFloat(/^OpenGL ES (\d)/.exec(K)[1])), (X = it >= 2));
  let zt = null,
    N = {};
  const Q = a.getParameter(a.SCISSOR_BOX),
    gt = a.getParameter(a.VIEWPORT),
    At = new Un().fromArray(Q),
    tt = new Un().fromArray(gt);
  function st(nt, qt, Ct, Ot) {
    const ae = new Uint8Array(4),
      te = a.createTexture();
    a.bindTexture(nt, te),
      a.texParameteri(nt, a.TEXTURE_MIN_FILTER, a.NEAREST),
      a.texParameteri(nt, a.TEXTURE_MAG_FILTER, a.NEAREST);
    for (let Pe = 0; Pe < Ct; Pe++)
      nt === a.TEXTURE_3D || nt === a.TEXTURE_2D_ARRAY
        ? a.texImage3D(qt, 0, a.RGBA, 1, 1, Ot, 0, a.RGBA, a.UNSIGNED_BYTE, ae)
        : a.texImage2D(qt + Pe, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, ae);
    return te;
  }
  const _t = {};
  (_t[a.TEXTURE_2D] = st(a.TEXTURE_2D, a.TEXTURE_2D, 1)),
    (_t[a.TEXTURE_CUBE_MAP] = st(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
    (_t[a.TEXTURE_2D_ARRAY] = st(a.TEXTURE_2D_ARRAY, a.TEXTURE_2D_ARRAY, 1, 1)),
    (_t[a.TEXTURE_3D] = st(a.TEXTURE_3D, a.TEXTURE_3D, 1, 1)),
    h.setClear(0, 0, 0, 1),
    f.setClear(1),
    m.setClear(0),
    It(a.DEPTH_TEST),
    f.setFunc(kl),
    Bt(!1),
    Ut(Oy),
    It(a.CULL_FACE),
    G(Os);
  function It(nt) {
    x[nt] !== !0 && (a.enable(nt), (x[nt] = !0));
  }
  function Gt(nt) {
    x[nt] !== !1 && (a.disable(nt), (x[nt] = !1));
  }
  function fe(nt, qt) {
    return S[nt] !== qt
      ? (a.bindFramebuffer(nt, qt),
        (S[nt] = qt),
        nt === a.DRAW_FRAMEBUFFER && (S[a.FRAMEBUFFER] = qt),
        nt === a.FRAMEBUFFER && (S[a.DRAW_FRAMEBUFFER] = qt),
        !0)
      : !1;
  }
  function oe(nt, qt) {
    let Ct = E,
      Ot = !1;
    if (nt) {
      (Ct = b.get(qt)), Ct === void 0 && ((Ct = []), b.set(qt, Ct));
      const ae = nt.textures;
      if (Ct.length !== ae.length || Ct[0] !== a.COLOR_ATTACHMENT0) {
        for (let te = 0, Pe = ae.length; te < Pe; te++) Ct[te] = a.COLOR_ATTACHMENT0 + te;
        (Ct.length = ae.length), (Ot = !0);
      }
    } else Ct[0] !== a.BACK && ((Ct[0] = a.BACK), (Ot = !0));
    Ot && a.drawBuffers(Ct);
  }
  function Ne(nt) {
    return A !== nt ? (a.useProgram(nt), (A = nt), !0) : !1;
  }
  const Te = { [yo]: a.FUNC_ADD, [kw]: a.FUNC_SUBTRACT, [Fw]: a.FUNC_REVERSE_SUBTRACT };
  (Te[Hw] = a.MIN), (Te[Gw] = a.MAX);
  const ye = {
    [Vw]: a.ZERO,
    [Ww]: a.ONE,
    [Zw]: a.SRC_COLOR,
    [km]: a.SRC_ALPHA,
    [Qw]: a.SRC_ALPHA_SATURATE,
    [Yw]: a.DST_COLOR,
    [jw]: a.DST_ALPHA,
    [Xw]: a.ONE_MINUS_SRC_COLOR,
    [Fm]: a.ONE_MINUS_SRC_ALPHA,
    [Kw]: a.ONE_MINUS_DST_COLOR,
    [qw]: a.ONE_MINUS_DST_ALPHA,
    [Jw]: a.CONSTANT_COLOR,
    [$w]: a.ONE_MINUS_CONSTANT_COLOR,
    [tA]: a.CONSTANT_ALPHA,
    [eA]: a.ONE_MINUS_CONSTANT_ALPHA,
  };
  function G(nt, qt, Ct, Ot, ae, te, Pe, cn, Rn, Ye) {
    if (nt === Os) {
      R === !0 && (Gt(a.BLEND), (R = !1));
      return;
    }
    if ((R === !1 && (It(a.BLEND), (R = !0)), nt !== Bw)) {
      if (nt !== T || Ye !== F) {
        if (((M !== yo || D !== yo) && (a.blendEquation(a.FUNC_ADD), (M = yo), (D = yo)), Ye))
          switch (nt) {
            case zl:
              a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA);
              break;
            case Bm:
              a.blendFunc(a.ONE, a.ONE);
              break;
            case Uy:
              a.blendFuncSeparate(a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ZERO, a.ONE);
              break;
            case Ny:
              a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', nt);
              break;
          }
        else
          switch (nt) {
            case zl:
              a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA);
              break;
            case Bm:
              a.blendFunc(a.SRC_ALPHA, a.ONE);
              break;
            case Uy:
              a.blendFuncSeparate(a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ZERO, a.ONE);
              break;
            case Ny:
              a.blendFunc(a.ZERO, a.SRC_COLOR);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', nt);
              break;
          }
        (z = null), (P = null), (W = null), (Z = null), V.set(0, 0, 0), (J = 0), (T = nt), (F = Ye);
      }
      return;
    }
    (ae = ae || qt),
      (te = te || Ct),
      (Pe = Pe || Ot),
      (qt !== M || ae !== D) && (a.blendEquationSeparate(Te[qt], Te[ae]), (M = qt), (D = ae)),
      (Ct !== z || Ot !== P || te !== W || Pe !== Z) &&
        (a.blendFuncSeparate(ye[Ct], ye[Ot], ye[te], ye[Pe]),
        (z = Ct),
        (P = Ot),
        (W = te),
        (Z = Pe)),
      (cn.equals(V) === !1 || Rn !== J) &&
        (a.blendColor(cn.r, cn.g, cn.b, Rn), V.copy(cn), (J = Rn)),
      (T = nt),
      (F = !1);
  }
  function Zt(nt, qt) {
    nt.side === Dr ? Gt(a.CULL_FACE) : It(a.CULL_FACE);
    let Ct = nt.side === Ni;
    qt && (Ct = !Ct),
      Bt(Ct),
      nt.blending === zl && nt.transparent === !1
        ? G(Os)
        : G(
            nt.blending,
            nt.blendEquation,
            nt.blendSrc,
            nt.blendDst,
            nt.blendEquationAlpha,
            nt.blendSrcAlpha,
            nt.blendDstAlpha,
            nt.blendColor,
            nt.blendAlpha,
            nt.premultipliedAlpha,
          ),
      f.setFunc(nt.depthFunc),
      f.setTest(nt.depthTest),
      f.setMask(nt.depthWrite),
      h.setMask(nt.colorWrite);
    const Ot = nt.stencilWrite;
    m.setTest(Ot),
      Ot &&
        (m.setMask(nt.stencilWriteMask),
        m.setFunc(nt.stencilFunc, nt.stencilRef, nt.stencilFuncMask),
        m.setOp(nt.stencilFail, nt.stencilZFail, nt.stencilZPass)),
      le(nt.polygonOffset, nt.polygonOffsetFactor, nt.polygonOffsetUnits),
      nt.alphaToCoverage === !0 ? It(a.SAMPLE_ALPHA_TO_COVERAGE) : Gt(a.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Bt(nt) {
    I !== nt && (nt ? a.frontFace(a.CW) : a.frontFace(a.CCW), (I = nt));
  }
  function Ut(nt) {
    nt !== Nw
      ? (It(a.CULL_FACE),
        nt !== j &&
          (nt === Oy
            ? a.cullFace(a.BACK)
            : nt === zw
              ? a.cullFace(a.FRONT)
              : a.cullFace(a.FRONT_AND_BACK)))
      : Gt(a.CULL_FACE),
      (j = nt);
  }
  function Lt(nt) {
    nt !== ft && (X && a.lineWidth(nt), (ft = nt));
  }
  function le(nt, qt, Ct) {
    nt
      ? (It(a.POLYGON_OFFSET_FILL),
        (pt !== qt || Mt !== Ct) && (a.polygonOffset(qt, Ct), (pt = qt), (Mt = Ct)))
      : Gt(a.POLYGON_OFFSET_FILL);
  }
  function kt(nt) {
    nt ? It(a.SCISSOR_TEST) : Gt(a.SCISSOR_TEST);
  }
  function H(nt) {
    nt === void 0 && (nt = a.TEXTURE0 + bt - 1), zt !== nt && (a.activeTexture(nt), (zt = nt));
  }
  function O(nt, qt, Ct) {
    Ct === void 0 && (zt === null ? (Ct = a.TEXTURE0 + bt - 1) : (Ct = zt));
    let Ot = N[Ct];
    Ot === void 0 && ((Ot = { type: void 0, texture: void 0 }), (N[Ct] = Ot)),
      (Ot.type !== nt || Ot.texture !== qt) &&
        (zt !== Ct && (a.activeTexture(Ct), (zt = Ct)),
        a.bindTexture(nt, qt || _t[nt]),
        (Ot.type = nt),
        (Ot.texture = qt));
  }
  function rt() {
    const nt = N[zt];
    nt !== void 0 &&
      nt.type !== void 0 &&
      (a.bindTexture(nt.type, null), (nt.type = void 0), (nt.texture = void 0));
  }
  function wt() {
    try {
      a.compressedTexImage2D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function Dt() {
    try {
      a.compressedTexImage3D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function Et() {
    try {
      a.texSubImage2D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function Xt() {
    try {
      a.texSubImage3D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function Wt() {
    try {
      a.compressedTexSubImage2D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function $t() {
    try {
      a.compressedTexSubImage3D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function ce() {
    try {
      a.texStorage2D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function Ht() {
    try {
      a.texStorage3D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function re() {
    try {
      a.texImage2D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function pe() {
    try {
      a.texImage3D(...arguments);
    } catch (nt) {
      console.error('THREE.WebGLState:', nt);
    }
  }
  function Se(nt) {
    At.equals(nt) === !1 && (a.scissor(nt.x, nt.y, nt.z, nt.w), At.copy(nt));
  }
  function Qt(nt) {
    tt.equals(nt) === !1 && (a.viewport(nt.x, nt.y, nt.z, nt.w), tt.copy(nt));
  }
  function Oe(nt, qt) {
    let Ct = g.get(qt);
    Ct === void 0 && ((Ct = new WeakMap()), g.set(qt, Ct));
    let Ot = Ct.get(nt);
    Ot === void 0 && ((Ot = a.getUniformBlockIndex(qt, nt.name)), Ct.set(nt, Ot));
  }
  function Me(nt, qt) {
    const Ot = g.get(qt).get(nt);
    _.get(qt) !== Ot && (a.uniformBlockBinding(qt, Ot, nt.__bindingPointIndex), _.set(qt, Ot));
  }
  function Je() {
    a.disable(a.BLEND),
      a.disable(a.CULL_FACE),
      a.disable(a.DEPTH_TEST),
      a.disable(a.POLYGON_OFFSET_FILL),
      a.disable(a.SCISSOR_TEST),
      a.disable(a.STENCIL_TEST),
      a.disable(a.SAMPLE_ALPHA_TO_COVERAGE),
      a.blendEquation(a.FUNC_ADD),
      a.blendFunc(a.ONE, a.ZERO),
      a.blendFuncSeparate(a.ONE, a.ZERO, a.ONE, a.ZERO),
      a.blendColor(0, 0, 0, 0),
      a.colorMask(!0, !0, !0, !0),
      a.clearColor(0, 0, 0, 0),
      a.depthMask(!0),
      a.depthFunc(a.LESS),
      f.setReversed(!1),
      a.clearDepth(1),
      a.stencilMask(4294967295),
      a.stencilFunc(a.ALWAYS, 0, 4294967295),
      a.stencilOp(a.KEEP, a.KEEP, a.KEEP),
      a.clearStencil(0),
      a.cullFace(a.BACK),
      a.frontFace(a.CCW),
      a.polygonOffset(0, 0),
      a.activeTexture(a.TEXTURE0),
      a.bindFramebuffer(a.FRAMEBUFFER, null),
      a.bindFramebuffer(a.DRAW_FRAMEBUFFER, null),
      a.bindFramebuffer(a.READ_FRAMEBUFFER, null),
      a.useProgram(null),
      a.lineWidth(1),
      a.scissor(0, 0, a.canvas.width, a.canvas.height),
      a.viewport(0, 0, a.canvas.width, a.canvas.height),
      (x = {}),
      (zt = null),
      (N = {}),
      (S = {}),
      (b = new WeakMap()),
      (E = []),
      (A = null),
      (R = !1),
      (T = null),
      (M = null),
      (z = null),
      (P = null),
      (D = null),
      (W = null),
      (Z = null),
      (V = new Qe(0, 0, 0)),
      (J = 0),
      (F = !1),
      (I = null),
      (j = null),
      (ft = null),
      (pt = null),
      (Mt = null),
      At.set(0, 0, a.canvas.width, a.canvas.height),
      tt.set(0, 0, a.canvas.width, a.canvas.height),
      h.reset(),
      f.reset(),
      m.reset();
  }
  return {
    buffers: { color: h, depth: f, stencil: m },
    enable: It,
    disable: Gt,
    bindFramebuffer: fe,
    drawBuffers: oe,
    useProgram: Ne,
    setBlending: G,
    setMaterial: Zt,
    setFlipSided: Bt,
    setCullFace: Ut,
    setLineWidth: Lt,
    setPolygonOffset: le,
    setScissorTest: kt,
    activeTexture: H,
    bindTexture: O,
    unbindTexture: rt,
    compressedTexImage2D: wt,
    compressedTexImage3D: Dt,
    texImage2D: re,
    texImage3D: pe,
    updateUBOMapping: Oe,
    uniformBlockBinding: Me,
    texStorage2D: ce,
    texStorage3D: Ht,
    texSubImage2D: Et,
    texSubImage3D: Xt,
    compressedTexSubImage2D: Wt,
    compressedTexSubImage3D: $t,
    scissor: Se,
    viewport: Qt,
    reset: Je,
  };
}
function yP(a, t, e, s, l, h, f) {
  const m = t.has('WEBGL_multisampled_render_to_texture')
      ? t.get('WEBGL_multisampled_render_to_texture')
      : null,
    _ = typeof navigator > 'u' ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    g = new Yt(),
    x = new WeakMap();
  let S;
  const b = new WeakMap();
  let E = !1;
  try {
    E = typeof OffscreenCanvas < 'u' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
  } catch {}
  function A(H, O) {
    return E ? new OffscreenCanvas(H, O) : gu('canvas');
  }
  function R(H, O, rt) {
    let wt = 1;
    const Dt = kt(H);
    if (((Dt.width > rt || Dt.height > rt) && (wt = rt / Math.max(Dt.width, Dt.height)), wt < 1))
      if (
        (typeof HTMLImageElement < 'u' && H instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && H instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && H instanceof ImageBitmap) ||
        (typeof VideoFrame < 'u' && H instanceof VideoFrame)
      ) {
        const Et = Math.floor(wt * Dt.width),
          Xt = Math.floor(wt * Dt.height);
        S === void 0 && (S = A(Et, Xt));
        const Wt = O ? A(Et, Xt) : S;
        return (
          (Wt.width = Et),
          (Wt.height = Xt),
          Wt.getContext('2d').drawImage(H, 0, 0, Et, Xt),
          console.warn(
            'THREE.WebGLRenderer: Texture has been resized from (' +
              Dt.width +
              'x' +
              Dt.height +
              ') to (' +
              Et +
              'x' +
              Xt +
              ').',
          ),
          Wt
        );
      } else
        return (
          'data' in H &&
            console.warn(
              'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                Dt.width +
                'x' +
                Dt.height +
                ').',
            ),
          H
        );
    return H;
  }
  function T(H) {
    return H.generateMipmaps;
  }
  function M(H) {
    a.generateMipmap(H);
  }
  function z(H) {
    return H.isWebGLCubeRenderTarget
      ? a.TEXTURE_CUBE_MAP
      : H.isWebGL3DRenderTarget
        ? a.TEXTURE_3D
        : H.isWebGLArrayRenderTarget || H.isCompressedArrayTexture
          ? a.TEXTURE_2D_ARRAY
          : a.TEXTURE_2D;
  }
  function P(H, O, rt, wt, Dt = !1) {
    if (H !== null) {
      if (a[H] !== void 0) return a[H];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + H + "'",
      );
    }
    let Et = O;
    if (
      (O === a.RED &&
        (rt === a.FLOAT && (Et = a.R32F),
        rt === a.HALF_FLOAT && (Et = a.R16F),
        rt === a.UNSIGNED_BYTE && (Et = a.R8)),
      O === a.RED_INTEGER &&
        (rt === a.UNSIGNED_BYTE && (Et = a.R8UI),
        rt === a.UNSIGNED_SHORT && (Et = a.R16UI),
        rt === a.UNSIGNED_INT && (Et = a.R32UI),
        rt === a.BYTE && (Et = a.R8I),
        rt === a.SHORT && (Et = a.R16I),
        rt === a.INT && (Et = a.R32I)),
      O === a.RG &&
        (rt === a.FLOAT && (Et = a.RG32F),
        rt === a.HALF_FLOAT && (Et = a.RG16F),
        rt === a.UNSIGNED_BYTE && (Et = a.RG8)),
      O === a.RG_INTEGER &&
        (rt === a.UNSIGNED_BYTE && (Et = a.RG8UI),
        rt === a.UNSIGNED_SHORT && (Et = a.RG16UI),
        rt === a.UNSIGNED_INT && (Et = a.RG32UI),
        rt === a.BYTE && (Et = a.RG8I),
        rt === a.SHORT && (Et = a.RG16I),
        rt === a.INT && (Et = a.RG32I)),
      O === a.RGB_INTEGER &&
        (rt === a.UNSIGNED_BYTE && (Et = a.RGB8UI),
        rt === a.UNSIGNED_SHORT && (Et = a.RGB16UI),
        rt === a.UNSIGNED_INT && (Et = a.RGB32UI),
        rt === a.BYTE && (Et = a.RGB8I),
        rt === a.SHORT && (Et = a.RGB16I),
        rt === a.INT && (Et = a.RGB32I)),
      O === a.RGBA_INTEGER &&
        (rt === a.UNSIGNED_BYTE && (Et = a.RGBA8UI),
        rt === a.UNSIGNED_SHORT && (Et = a.RGBA16UI),
        rt === a.UNSIGNED_INT && (Et = a.RGBA32UI),
        rt === a.BYTE && (Et = a.RGBA8I),
        rt === a.SHORT && (Et = a.RGBA16I),
        rt === a.INT && (Et = a.RGBA32I)),
      O === a.RGB && rt === a.UNSIGNED_INT_5_9_9_9_REV && (Et = a.RGB9_E5),
      O === a.RGBA)
    ) {
      const Xt = Dt ? If : en.getTransfer(wt);
      rt === a.FLOAT && (Et = a.RGBA32F),
        rt === a.HALF_FLOAT && (Et = a.RGBA16F),
        rt === a.UNSIGNED_BYTE && (Et = Xt === dn ? a.SRGB8_ALPHA8 : a.RGBA8),
        rt === a.UNSIGNED_SHORT_4_4_4_4 && (Et = a.RGBA4),
        rt === a.UNSIGNED_SHORT_5_5_5_1 && (Et = a.RGB5_A1);
    }
    return (
      (Et === a.R16F ||
        Et === a.R32F ||
        Et === a.RG16F ||
        Et === a.RG32F ||
        Et === a.RGBA16F ||
        Et === a.RGBA32F) &&
        t.get('EXT_color_buffer_float'),
      Et
    );
  }
  function D(H, O) {
    let rt;
    return (
      H
        ? O === null || O === bo || O === pu
          ? (rt = a.DEPTH24_STENCIL8)
          : O === Or
            ? (rt = a.DEPTH32F_STENCIL8)
            : O === du &&
              ((rt = a.DEPTH24_STENCIL8),
              console.warn(
                'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.',
              ))
        : O === null || O === bo || O === pu
          ? (rt = a.DEPTH_COMPONENT24)
          : O === Or
            ? (rt = a.DEPTH_COMPONENT32F)
            : O === du && (rt = a.DEPTH_COMPONENT16),
      rt
    );
  }
  function W(H, O) {
    return T(H) === !0 || (H.isFramebufferTexture && H.minFilter !== Da && H.minFilter !== ja)
      ? Math.log2(Math.max(O.width, O.height)) + 1
      : H.mipmaps !== void 0 && H.mipmaps.length > 0
        ? H.mipmaps.length
        : H.isCompressedTexture && Array.isArray(H.image)
          ? O.mipmaps.length
          : 1;
  }
  function Z(H) {
    const O = H.target;
    O.removeEventListener('dispose', Z), J(O), O.isVideoTexture && x.delete(O);
  }
  function V(H) {
    const O = H.target;
    O.removeEventListener('dispose', V), I(O);
  }
  function J(H) {
    const O = s.get(H);
    if (O.__webglInit === void 0) return;
    const rt = H.source,
      wt = b.get(rt);
    if (wt) {
      const Dt = wt[O.__cacheKey];
      Dt.usedTimes--, Dt.usedTimes === 0 && F(H), Object.keys(wt).length === 0 && b.delete(rt);
    }
    s.remove(H);
  }
  function F(H) {
    const O = s.get(H);
    a.deleteTexture(O.__webglTexture);
    const rt = H.source,
      wt = b.get(rt);
    delete wt[O.__cacheKey], f.memory.textures--;
  }
  function I(H) {
    const O = s.get(H);
    if (
      (H.depthTexture && (H.depthTexture.dispose(), s.remove(H.depthTexture)),
      H.isWebGLCubeRenderTarget)
    )
      for (let wt = 0; wt < 6; wt++) {
        if (Array.isArray(O.__webglFramebuffer[wt]))
          for (let Dt = 0; Dt < O.__webglFramebuffer[wt].length; Dt++)
            a.deleteFramebuffer(O.__webglFramebuffer[wt][Dt]);
        else a.deleteFramebuffer(O.__webglFramebuffer[wt]);
        O.__webglDepthbuffer && a.deleteRenderbuffer(O.__webglDepthbuffer[wt]);
      }
    else {
      if (Array.isArray(O.__webglFramebuffer))
        for (let wt = 0; wt < O.__webglFramebuffer.length; wt++)
          a.deleteFramebuffer(O.__webglFramebuffer[wt]);
      else a.deleteFramebuffer(O.__webglFramebuffer);
      if (
        (O.__webglDepthbuffer && a.deleteRenderbuffer(O.__webglDepthbuffer),
        O.__webglMultisampledFramebuffer && a.deleteFramebuffer(O.__webglMultisampledFramebuffer),
        O.__webglColorRenderbuffer)
      )
        for (let wt = 0; wt < O.__webglColorRenderbuffer.length; wt++)
          O.__webglColorRenderbuffer[wt] && a.deleteRenderbuffer(O.__webglColorRenderbuffer[wt]);
      O.__webglDepthRenderbuffer && a.deleteRenderbuffer(O.__webglDepthRenderbuffer);
    }
    const rt = H.textures;
    for (let wt = 0, Dt = rt.length; wt < Dt; wt++) {
      const Et = s.get(rt[wt]);
      Et.__webglTexture && (a.deleteTexture(Et.__webglTexture), f.memory.textures--),
        s.remove(rt[wt]);
    }
    s.remove(H);
  }
  let j = 0;
  function ft() {
    j = 0;
  }
  function pt() {
    const H = j;
    return (
      H >= l.maxTextures &&
        console.warn(
          'THREE.WebGLTextures: Trying to use ' +
            H +
            ' texture units while this GPU supports only ' +
            l.maxTextures,
        ),
      (j += 1),
      H
    );
  }
  function Mt(H) {
    const O = [];
    return (
      O.push(H.wrapS),
      O.push(H.wrapT),
      O.push(H.wrapR || 0),
      O.push(H.magFilter),
      O.push(H.minFilter),
      O.push(H.anisotropy),
      O.push(H.internalFormat),
      O.push(H.format),
      O.push(H.type),
      O.push(H.generateMipmaps),
      O.push(H.premultiplyAlpha),
      O.push(H.flipY),
      O.push(H.unpackAlignment),
      O.push(H.colorSpace),
      O.join()
    );
  }
  function bt(H, O) {
    const rt = s.get(H);
    if (
      (H.isVideoTexture && Lt(H),
      H.isRenderTargetTexture === !1 && H.version > 0 && rt.__version !== H.version)
    ) {
      const wt = H.image;
      if (wt === null)
        console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
      else if (wt.complete === !1)
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      else {
        tt(rt, H, O);
        return;
      }
    }
    e.bindTexture(a.TEXTURE_2D, rt.__webglTexture, a.TEXTURE0 + O);
  }
  function X(H, O) {
    const rt = s.get(H);
    if (H.version > 0 && rt.__version !== H.version) {
      tt(rt, H, O);
      return;
    }
    e.bindTexture(a.TEXTURE_2D_ARRAY, rt.__webglTexture, a.TEXTURE0 + O);
  }
  function it(H, O) {
    const rt = s.get(H);
    if (H.version > 0 && rt.__version !== H.version) {
      tt(rt, H, O);
      return;
    }
    e.bindTexture(a.TEXTURE_3D, rt.__webglTexture, a.TEXTURE0 + O);
  }
  function K(H, O) {
    const rt = s.get(H);
    if (H.version > 0 && rt.__version !== H.version) {
      st(rt, H, O);
      return;
    }
    e.bindTexture(a.TEXTURE_CUBE_MAP, rt.__webglTexture, a.TEXTURE0 + O);
  }
  const zt = { [Km]: a.REPEAT, [So]: a.CLAMP_TO_EDGE, [Qm]: a.MIRRORED_REPEAT },
    N = {
      [Da]: a.NEAREST,
      [hA]: a.NEAREST_MIPMAP_NEAREST,
      [Zh]: a.NEAREST_MIPMAP_LINEAR,
      [ja]: a.LINEAR,
      [Jp]: a.LINEAR_MIPMAP_NEAREST,
      [Mo]: a.LINEAR_MIPMAP_LINEAR,
    },
    Q = {
      [mA]: a.NEVER,
      [SA]: a.ALWAYS,
      [_A]: a.LESS,
      [YS]: a.LEQUAL,
      [gA]: a.EQUAL,
      [xA]: a.GEQUAL,
      [vA]: a.GREATER,
      [yA]: a.NOTEQUAL,
    };
  function gt(H, O) {
    if (
      (O.type === Or &&
        t.has('OES_texture_float_linear') === !1 &&
        (O.magFilter === ja ||
          O.magFilter === Jp ||
          O.magFilter === Zh ||
          O.magFilter === Mo ||
          O.minFilter === ja ||
          O.minFilter === Jp ||
          O.minFilter === Zh ||
          O.minFilter === Mo) &&
        console.warn(
          'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.',
        ),
      a.texParameteri(H, a.TEXTURE_WRAP_S, zt[O.wrapS]),
      a.texParameteri(H, a.TEXTURE_WRAP_T, zt[O.wrapT]),
      (H === a.TEXTURE_3D || H === a.TEXTURE_2D_ARRAY) &&
        a.texParameteri(H, a.TEXTURE_WRAP_R, zt[O.wrapR]),
      a.texParameteri(H, a.TEXTURE_MAG_FILTER, N[O.magFilter]),
      a.texParameteri(H, a.TEXTURE_MIN_FILTER, N[O.minFilter]),
      O.compareFunction &&
        (a.texParameteri(H, a.TEXTURE_COMPARE_MODE, a.COMPARE_REF_TO_TEXTURE),
        a.texParameteri(H, a.TEXTURE_COMPARE_FUNC, Q[O.compareFunction])),
      t.has('EXT_texture_filter_anisotropic') === !0)
    ) {
      if (
        O.magFilter === Da ||
        (O.minFilter !== Zh && O.minFilter !== Mo) ||
        (O.type === Or && t.has('OES_texture_float_linear') === !1)
      )
        return;
      if (O.anisotropy > 1 || s.get(O).__currentAnisotropy) {
        const rt = t.get('EXT_texture_filter_anisotropic');
        a.texParameterf(
          H,
          rt.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(O.anisotropy, l.getMaxAnisotropy()),
        ),
          (s.get(O).__currentAnisotropy = O.anisotropy);
      }
    }
  }
  function At(H, O) {
    let rt = !1;
    H.__webglInit === void 0 && ((H.__webglInit = !0), O.addEventListener('dispose', Z));
    const wt = O.source;
    let Dt = b.get(wt);
    Dt === void 0 && ((Dt = {}), b.set(wt, Dt));
    const Et = Mt(O);
    if (Et !== H.__cacheKey) {
      Dt[Et] === void 0 &&
        ((Dt[Et] = { texture: a.createTexture(), usedTimes: 0 }), f.memory.textures++, (rt = !0)),
        Dt[Et].usedTimes++;
      const Xt = Dt[H.__cacheKey];
      Xt !== void 0 && (Dt[H.__cacheKey].usedTimes--, Xt.usedTimes === 0 && F(O)),
        (H.__cacheKey = Et),
        (H.__webglTexture = Dt[Et].texture);
    }
    return rt;
  }
  function tt(H, O, rt) {
    let wt = a.TEXTURE_2D;
    (O.isDataArrayTexture || O.isCompressedArrayTexture) && (wt = a.TEXTURE_2D_ARRAY),
      O.isData3DTexture && (wt = a.TEXTURE_3D);
    const Dt = At(H, O),
      Et = O.source;
    e.bindTexture(wt, H.__webglTexture, a.TEXTURE0 + rt);
    const Xt = s.get(Et);
    if (Et.version !== Xt.__version || Dt === !0) {
      e.activeTexture(a.TEXTURE0 + rt);
      const Wt = en.getPrimaries(en.workingColorSpace),
        $t = O.colorSpace === Ds ? null : en.getPrimaries(O.colorSpace),
        ce = O.colorSpace === Ds || Wt === $t ? a.NONE : a.BROWSER_DEFAULT_WEBGL;
      a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, O.flipY),
        a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha),
        a.pixelStorei(a.UNPACK_ALIGNMENT, O.unpackAlignment),
        a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL, ce);
      let Ht = R(O.image, !1, l.maxTextureSize);
      Ht = le(O, Ht);
      const re = h.convert(O.format, O.colorSpace),
        pe = h.convert(O.type);
      let Se = P(O.internalFormat, re, pe, O.colorSpace, O.isVideoTexture);
      gt(wt, O);
      let Qt;
      const Oe = O.mipmaps,
        Me = O.isVideoTexture !== !0,
        Je = Xt.__version === void 0 || Dt === !0,
        nt = Et.dataReady,
        qt = W(O, Ht);
      if (O.isDepthTexture)
        (Se = D(O.format === _u, O.type)),
          Je &&
            (Me
              ? e.texStorage2D(a.TEXTURE_2D, 1, Se, Ht.width, Ht.height)
              : e.texImage2D(a.TEXTURE_2D, 0, Se, Ht.width, Ht.height, 0, re, pe, null));
      else if (O.isDataTexture)
        if (Oe.length > 0) {
          Me && Je && e.texStorage2D(a.TEXTURE_2D, qt, Se, Oe[0].width, Oe[0].height);
          for (let Ct = 0, Ot = Oe.length; Ct < Ot; Ct++)
            (Qt = Oe[Ct]),
              Me
                ? nt &&
                  e.texSubImage2D(a.TEXTURE_2D, Ct, 0, 0, Qt.width, Qt.height, re, pe, Qt.data)
                : e.texImage2D(a.TEXTURE_2D, Ct, Se, Qt.width, Qt.height, 0, re, pe, Qt.data);
          O.generateMipmaps = !1;
        } else
          Me
            ? (Je && e.texStorage2D(a.TEXTURE_2D, qt, Se, Ht.width, Ht.height),
              nt && e.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, Ht.width, Ht.height, re, pe, Ht.data))
            : e.texImage2D(a.TEXTURE_2D, 0, Se, Ht.width, Ht.height, 0, re, pe, Ht.data);
      else if (O.isCompressedTexture)
        if (O.isCompressedArrayTexture) {
          Me &&
            Je &&
            e.texStorage3D(a.TEXTURE_2D_ARRAY, qt, Se, Oe[0].width, Oe[0].height, Ht.depth);
          for (let Ct = 0, Ot = Oe.length; Ct < Ot; Ct++)
            if (((Qt = Oe[Ct]), O.format !== Pa))
              if (re !== null)
                if (Me) {
                  if (nt)
                    if (O.layerUpdates.size > 0) {
                      const ae = px(Qt.width, Qt.height, O.format, O.type);
                      for (const te of O.layerUpdates) {
                        const Pe = Qt.data.subarray(
                          (te * ae) / Qt.data.BYTES_PER_ELEMENT,
                          ((te + 1) * ae) / Qt.data.BYTES_PER_ELEMENT,
                        );
                        e.compressedTexSubImage3D(
                          a.TEXTURE_2D_ARRAY,
                          Ct,
                          0,
                          0,
                          te,
                          Qt.width,
                          Qt.height,
                          1,
                          re,
                          Pe,
                        );
                      }
                      O.clearLayerUpdates();
                    } else
                      e.compressedTexSubImage3D(
                        a.TEXTURE_2D_ARRAY,
                        Ct,
                        0,
                        0,
                        0,
                        Qt.width,
                        Qt.height,
                        Ht.depth,
                        re,
                        Qt.data,
                      );
                } else
                  e.compressedTexImage3D(
                    a.TEXTURE_2D_ARRAY,
                    Ct,
                    Se,
                    Qt.width,
                    Qt.height,
                    Ht.depth,
                    0,
                    Qt.data,
                    0,
                    0,
                  );
              else
                console.warn(
                  'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                );
            else
              Me
                ? nt &&
                  e.texSubImage3D(
                    a.TEXTURE_2D_ARRAY,
                    Ct,
                    0,
                    0,
                    0,
                    Qt.width,
                    Qt.height,
                    Ht.depth,
                    re,
                    pe,
                    Qt.data,
                  )
                : e.texImage3D(
                    a.TEXTURE_2D_ARRAY,
                    Ct,
                    Se,
                    Qt.width,
                    Qt.height,
                    Ht.depth,
                    0,
                    re,
                    pe,
                    Qt.data,
                  );
        } else {
          Me && Je && e.texStorage2D(a.TEXTURE_2D, qt, Se, Oe[0].width, Oe[0].height);
          for (let Ct = 0, Ot = Oe.length; Ct < Ot; Ct++)
            (Qt = Oe[Ct]),
              O.format !== Pa
                ? re !== null
                  ? Me
                    ? nt &&
                      e.compressedTexSubImage2D(
                        a.TEXTURE_2D,
                        Ct,
                        0,
                        0,
                        Qt.width,
                        Qt.height,
                        re,
                        Qt.data,
                      )
                    : e.compressedTexImage2D(a.TEXTURE_2D, Ct, Se, Qt.width, Qt.height, 0, Qt.data)
                  : console.warn(
                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                    )
                : Me
                  ? nt &&
                    e.texSubImage2D(a.TEXTURE_2D, Ct, 0, 0, Qt.width, Qt.height, re, pe, Qt.data)
                  : e.texImage2D(a.TEXTURE_2D, Ct, Se, Qt.width, Qt.height, 0, re, pe, Qt.data);
        }
      else if (O.isDataArrayTexture)
        if (Me) {
          if ((Je && e.texStorage3D(a.TEXTURE_2D_ARRAY, qt, Se, Ht.width, Ht.height, Ht.depth), nt))
            if (O.layerUpdates.size > 0) {
              const Ct = px(Ht.width, Ht.height, O.format, O.type);
              for (const Ot of O.layerUpdates) {
                const ae = Ht.data.subarray(
                  (Ot * Ct) / Ht.data.BYTES_PER_ELEMENT,
                  ((Ot + 1) * Ct) / Ht.data.BYTES_PER_ELEMENT,
                );
                e.texSubImage3D(
                  a.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Ot,
                  Ht.width,
                  Ht.height,
                  1,
                  re,
                  pe,
                  ae,
                );
              }
              O.clearLayerUpdates();
            } else
              e.texSubImage3D(
                a.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ht.width,
                Ht.height,
                Ht.depth,
                re,
                pe,
                Ht.data,
              );
        } else
          e.texImage3D(
            a.TEXTURE_2D_ARRAY,
            0,
            Se,
            Ht.width,
            Ht.height,
            Ht.depth,
            0,
            re,
            pe,
            Ht.data,
          );
      else if (O.isData3DTexture)
        Me
          ? (Je && e.texStorage3D(a.TEXTURE_3D, qt, Se, Ht.width, Ht.height, Ht.depth),
            nt &&
              e.texSubImage3D(
                a.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ht.width,
                Ht.height,
                Ht.depth,
                re,
                pe,
                Ht.data,
              ))
          : e.texImage3D(a.TEXTURE_3D, 0, Se, Ht.width, Ht.height, Ht.depth, 0, re, pe, Ht.data);
      else if (O.isFramebufferTexture) {
        if (Je)
          if (Me) e.texStorage2D(a.TEXTURE_2D, qt, Se, Ht.width, Ht.height);
          else {
            let Ct = Ht.width,
              Ot = Ht.height;
            for (let ae = 0; ae < qt; ae++)
              e.texImage2D(a.TEXTURE_2D, ae, Se, Ct, Ot, 0, re, pe, null), (Ct >>= 1), (Ot >>= 1);
          }
      } else if (Oe.length > 0) {
        if (Me && Je) {
          const Ct = kt(Oe[0]);
          e.texStorage2D(a.TEXTURE_2D, qt, Se, Ct.width, Ct.height);
        }
        for (let Ct = 0, Ot = Oe.length; Ct < Ot; Ct++)
          (Qt = Oe[Ct]),
            Me
              ? nt && e.texSubImage2D(a.TEXTURE_2D, Ct, 0, 0, re, pe, Qt)
              : e.texImage2D(a.TEXTURE_2D, Ct, Se, re, pe, Qt);
        O.generateMipmaps = !1;
      } else if (Me) {
        if (Je) {
          const Ct = kt(Ht);
          e.texStorage2D(a.TEXTURE_2D, qt, Se, Ct.width, Ct.height);
        }
        nt && e.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, re, pe, Ht);
      } else e.texImage2D(a.TEXTURE_2D, 0, Se, re, pe, Ht);
      T(O) && M(wt), (Xt.__version = Et.version), O.onUpdate && O.onUpdate(O);
    }
    H.__version = O.version;
  }
  function st(H, O, rt) {
    if (O.image.length !== 6) return;
    const wt = At(H, O),
      Dt = O.source;
    e.bindTexture(a.TEXTURE_CUBE_MAP, H.__webglTexture, a.TEXTURE0 + rt);
    const Et = s.get(Dt);
    if (Dt.version !== Et.__version || wt === !0) {
      e.activeTexture(a.TEXTURE0 + rt);
      const Xt = en.getPrimaries(en.workingColorSpace),
        Wt = O.colorSpace === Ds ? null : en.getPrimaries(O.colorSpace),
        $t = O.colorSpace === Ds || Xt === Wt ? a.NONE : a.BROWSER_DEFAULT_WEBGL;
      a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, O.flipY),
        a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha),
        a.pixelStorei(a.UNPACK_ALIGNMENT, O.unpackAlignment),
        a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL, $t);
      const ce = O.isCompressedTexture || O.image[0].isCompressedTexture,
        Ht = O.image[0] && O.image[0].isDataTexture,
        re = [];
      for (let Ot = 0; Ot < 6; Ot++)
        !ce && !Ht
          ? (re[Ot] = R(O.image[Ot], !0, l.maxCubemapSize))
          : (re[Ot] = Ht ? O.image[Ot].image : O.image[Ot]),
          (re[Ot] = le(O, re[Ot]));
      const pe = re[0],
        Se = h.convert(O.format, O.colorSpace),
        Qt = h.convert(O.type),
        Oe = P(O.internalFormat, Se, Qt, O.colorSpace),
        Me = O.isVideoTexture !== !0,
        Je = Et.__version === void 0 || wt === !0,
        nt = Dt.dataReady;
      let qt = W(O, pe);
      gt(a.TEXTURE_CUBE_MAP, O);
      let Ct;
      if (ce) {
        Me && Je && e.texStorage2D(a.TEXTURE_CUBE_MAP, qt, Oe, pe.width, pe.height);
        for (let Ot = 0; Ot < 6; Ot++) {
          Ct = re[Ot].mipmaps;
          for (let ae = 0; ae < Ct.length; ae++) {
            const te = Ct[ae];
            O.format !== Pa
              ? Se !== null
                ? Me
                  ? nt &&
                    e.compressedTexSubImage2D(
                      a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                      ae,
                      0,
                      0,
                      te.width,
                      te.height,
                      Se,
                      te.data,
                    )
                  : e.compressedTexImage2D(
                      a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                      ae,
                      Oe,
                      te.width,
                      te.height,
                      0,
                      te.data,
                    )
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                  )
              : Me
                ? nt &&
                  e.texSubImage2D(
                    a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                    ae,
                    0,
                    0,
                    te.width,
                    te.height,
                    Se,
                    Qt,
                    te.data,
                  )
                : e.texImage2D(
                    a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                    ae,
                    Oe,
                    te.width,
                    te.height,
                    0,
                    Se,
                    Qt,
                    te.data,
                  );
          }
        }
      } else {
        if (((Ct = O.mipmaps), Me && Je)) {
          Ct.length > 0 && qt++;
          const Ot = kt(re[0]);
          e.texStorage2D(a.TEXTURE_CUBE_MAP, qt, Oe, Ot.width, Ot.height);
        }
        for (let Ot = 0; Ot < 6; Ot++)
          if (Ht) {
            Me
              ? nt &&
                e.texSubImage2D(
                  a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                  0,
                  0,
                  0,
                  re[Ot].width,
                  re[Ot].height,
                  Se,
                  Qt,
                  re[Ot].data,
                )
              : e.texImage2D(
                  a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                  0,
                  Oe,
                  re[Ot].width,
                  re[Ot].height,
                  0,
                  Se,
                  Qt,
                  re[Ot].data,
                );
            for (let ae = 0; ae < Ct.length; ae++) {
              const Pe = Ct[ae].image[Ot].image;
              Me
                ? nt &&
                  e.texSubImage2D(
                    a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                    ae + 1,
                    0,
                    0,
                    Pe.width,
                    Pe.height,
                    Se,
                    Qt,
                    Pe.data,
                  )
                : e.texImage2D(
                    a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                    ae + 1,
                    Oe,
                    Pe.width,
                    Pe.height,
                    0,
                    Se,
                    Qt,
                    Pe.data,
                  );
            }
          } else {
            Me
              ? nt && e.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot, 0, 0, 0, Se, Qt, re[Ot])
              : e.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot, 0, Oe, Se, Qt, re[Ot]);
            for (let ae = 0; ae < Ct.length; ae++) {
              const te = Ct[ae];
              Me
                ? nt &&
                  e.texSubImage2D(
                    a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                    ae + 1,
                    0,
                    0,
                    Se,
                    Qt,
                    te.image[Ot],
                  )
                : e.texImage2D(
                    a.TEXTURE_CUBE_MAP_POSITIVE_X + Ot,
                    ae + 1,
                    Oe,
                    Se,
                    Qt,
                    te.image[Ot],
                  );
            }
          }
      }
      T(O) && M(a.TEXTURE_CUBE_MAP), (Et.__version = Dt.version), O.onUpdate && O.onUpdate(O);
    }
    H.__version = O.version;
  }
  function _t(H, O, rt, wt, Dt, Et) {
    const Xt = h.convert(rt.format, rt.colorSpace),
      Wt = h.convert(rt.type),
      $t = P(rt.internalFormat, Xt, Wt, rt.colorSpace),
      ce = s.get(O),
      Ht = s.get(rt);
    if (((Ht.__renderTarget = O), !ce.__hasExternalTextures)) {
      const re = Math.max(1, O.width >> Et),
        pe = Math.max(1, O.height >> Et);
      Dt === a.TEXTURE_3D || Dt === a.TEXTURE_2D_ARRAY
        ? e.texImage3D(Dt, Et, $t, re, pe, O.depth, 0, Xt, Wt, null)
        : e.texImage2D(Dt, Et, $t, re, pe, 0, Xt, Wt, null);
    }
    e.bindFramebuffer(a.FRAMEBUFFER, H),
      Ut(O)
        ? m.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER, wt, Dt, Ht.__webglTexture, 0, Bt(O))
        : (Dt === a.TEXTURE_2D ||
            (Dt >= a.TEXTURE_CUBE_MAP_POSITIVE_X && Dt <= a.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          a.framebufferTexture2D(a.FRAMEBUFFER, wt, Dt, Ht.__webglTexture, Et),
      e.bindFramebuffer(a.FRAMEBUFFER, null);
  }
  function It(H, O, rt) {
    if ((a.bindRenderbuffer(a.RENDERBUFFER, H), O.depthBuffer)) {
      const wt = O.depthTexture,
        Dt = wt && wt.isDepthTexture ? wt.type : null,
        Et = D(O.stencilBuffer, Dt),
        Xt = O.stencilBuffer ? a.DEPTH_STENCIL_ATTACHMENT : a.DEPTH_ATTACHMENT,
        Wt = Bt(O);
      Ut(O)
        ? m.renderbufferStorageMultisampleEXT(a.RENDERBUFFER, Wt, Et, O.width, O.height)
        : rt
          ? a.renderbufferStorageMultisample(a.RENDERBUFFER, Wt, Et, O.width, O.height)
          : a.renderbufferStorage(a.RENDERBUFFER, Et, O.width, O.height),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, Xt, a.RENDERBUFFER, H);
    } else {
      const wt = O.textures;
      for (let Dt = 0; Dt < wt.length; Dt++) {
        const Et = wt[Dt],
          Xt = h.convert(Et.format, Et.colorSpace),
          Wt = h.convert(Et.type),
          $t = P(Et.internalFormat, Xt, Wt, Et.colorSpace),
          ce = Bt(O);
        rt && Ut(O) === !1
          ? a.renderbufferStorageMultisample(a.RENDERBUFFER, ce, $t, O.width, O.height)
          : Ut(O)
            ? m.renderbufferStorageMultisampleEXT(a.RENDERBUFFER, ce, $t, O.width, O.height)
            : a.renderbufferStorage(a.RENDERBUFFER, $t, O.width, O.height);
      }
    }
    a.bindRenderbuffer(a.RENDERBUFFER, null);
  }
  function Gt(H, O) {
    if (O && O.isWebGLCubeRenderTarget)
      throw new Error('Depth Texture with cube render targets is not supported');
    if ((e.bindFramebuffer(a.FRAMEBUFFER, H), !(O.depthTexture && O.depthTexture.isDepthTexture)))
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    const wt = s.get(O.depthTexture);
    (wt.__renderTarget = O),
      (!wt.__webglTexture ||
        O.depthTexture.image.width !== O.width ||
        O.depthTexture.image.height !== O.height) &&
        ((O.depthTexture.image.width = O.width),
        (O.depthTexture.image.height = O.height),
        (O.depthTexture.needsUpdate = !0)),
      bt(O.depthTexture, 0);
    const Dt = wt.__webglTexture,
      Et = Bt(O);
    if (O.depthTexture.format === mu)
      Ut(O)
        ? m.framebufferTexture2DMultisampleEXT(
            a.FRAMEBUFFER,
            a.DEPTH_ATTACHMENT,
            a.TEXTURE_2D,
            Dt,
            0,
            Et,
          )
        : a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, Dt, 0);
    else if (O.depthTexture.format === _u)
      Ut(O)
        ? m.framebufferTexture2DMultisampleEXT(
            a.FRAMEBUFFER,
            a.DEPTH_STENCIL_ATTACHMENT,
            a.TEXTURE_2D,
            Dt,
            0,
            Et,
          )
        : a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, Dt, 0);
    else throw new Error('Unknown depthTexture format');
  }
  function fe(H) {
    const O = s.get(H),
      rt = H.isWebGLCubeRenderTarget === !0;
    if (O.__boundDepthTexture !== H.depthTexture) {
      const wt = H.depthTexture;
      if ((O.__depthDisposeCallback && O.__depthDisposeCallback(), wt)) {
        const Dt = () => {
          delete O.__boundDepthTexture,
            delete O.__depthDisposeCallback,
            wt.removeEventListener('dispose', Dt);
        };
        wt.addEventListener('dispose', Dt), (O.__depthDisposeCallback = Dt);
      }
      O.__boundDepthTexture = wt;
    }
    if (H.depthTexture && !O.__autoAllocateDepthBuffer) {
      if (rt) throw new Error('target.depthTexture not supported in Cube render targets');
      const wt = H.texture.mipmaps;
      wt && wt.length > 0 ? Gt(O.__webglFramebuffer[0], H) : Gt(O.__webglFramebuffer, H);
    } else if (rt) {
      O.__webglDepthbuffer = [];
      for (let wt = 0; wt < 6; wt++)
        if (
          (e.bindFramebuffer(a.FRAMEBUFFER, O.__webglFramebuffer[wt]),
          O.__webglDepthbuffer[wt] === void 0)
        )
          (O.__webglDepthbuffer[wt] = a.createRenderbuffer()), It(O.__webglDepthbuffer[wt], H, !1);
        else {
          const Dt = H.stencilBuffer ? a.DEPTH_STENCIL_ATTACHMENT : a.DEPTH_ATTACHMENT,
            Et = O.__webglDepthbuffer[wt];
          a.bindRenderbuffer(a.RENDERBUFFER, Et),
            a.framebufferRenderbuffer(a.FRAMEBUFFER, Dt, a.RENDERBUFFER, Et);
        }
    } else {
      const wt = H.texture.mipmaps;
      if (
        (wt && wt.length > 0
          ? e.bindFramebuffer(a.FRAMEBUFFER, O.__webglFramebuffer[0])
          : e.bindFramebuffer(a.FRAMEBUFFER, O.__webglFramebuffer),
        O.__webglDepthbuffer === void 0)
      )
        (O.__webglDepthbuffer = a.createRenderbuffer()), It(O.__webglDepthbuffer, H, !1);
      else {
        const Dt = H.stencilBuffer ? a.DEPTH_STENCIL_ATTACHMENT : a.DEPTH_ATTACHMENT,
          Et = O.__webglDepthbuffer;
        a.bindRenderbuffer(a.RENDERBUFFER, Et),
          a.framebufferRenderbuffer(a.FRAMEBUFFER, Dt, a.RENDERBUFFER, Et);
      }
    }
    e.bindFramebuffer(a.FRAMEBUFFER, null);
  }
  function oe(H, O, rt) {
    const wt = s.get(H);
    O !== void 0 && _t(wt.__webglFramebuffer, H, H.texture, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, 0),
      rt !== void 0 && fe(H);
  }
  function Ne(H) {
    const O = H.texture,
      rt = s.get(H),
      wt = s.get(O);
    H.addEventListener('dispose', V);
    const Dt = H.textures,
      Et = H.isWebGLCubeRenderTarget === !0,
      Xt = Dt.length > 1;
    if (
      (Xt ||
        (wt.__webglTexture === void 0 && (wt.__webglTexture = a.createTexture()),
        (wt.__version = O.version),
        f.memory.textures++),
      Et)
    ) {
      rt.__webglFramebuffer = [];
      for (let Wt = 0; Wt < 6; Wt++)
        if (O.mipmaps && O.mipmaps.length > 0) {
          rt.__webglFramebuffer[Wt] = [];
          for (let $t = 0; $t < O.mipmaps.length; $t++)
            rt.__webglFramebuffer[Wt][$t] = a.createFramebuffer();
        } else rt.__webglFramebuffer[Wt] = a.createFramebuffer();
    } else {
      if (O.mipmaps && O.mipmaps.length > 0) {
        rt.__webglFramebuffer = [];
        for (let Wt = 0; Wt < O.mipmaps.length; Wt++)
          rt.__webglFramebuffer[Wt] = a.createFramebuffer();
      } else rt.__webglFramebuffer = a.createFramebuffer();
      if (Xt)
        for (let Wt = 0, $t = Dt.length; Wt < $t; Wt++) {
          const ce = s.get(Dt[Wt]);
          ce.__webglTexture === void 0 &&
            ((ce.__webglTexture = a.createTexture()), f.memory.textures++);
        }
      if (H.samples > 0 && Ut(H) === !1) {
        (rt.__webglMultisampledFramebuffer = a.createFramebuffer()),
          (rt.__webglColorRenderbuffer = []),
          e.bindFramebuffer(a.FRAMEBUFFER, rt.__webglMultisampledFramebuffer);
        for (let Wt = 0; Wt < Dt.length; Wt++) {
          const $t = Dt[Wt];
          (rt.__webglColorRenderbuffer[Wt] = a.createRenderbuffer()),
            a.bindRenderbuffer(a.RENDERBUFFER, rt.__webglColorRenderbuffer[Wt]);
          const ce = h.convert($t.format, $t.colorSpace),
            Ht = h.convert($t.type),
            re = P($t.internalFormat, ce, Ht, $t.colorSpace, H.isXRRenderTarget === !0),
            pe = Bt(H);
          a.renderbufferStorageMultisample(a.RENDERBUFFER, pe, re, H.width, H.height),
            a.framebufferRenderbuffer(
              a.FRAMEBUFFER,
              a.COLOR_ATTACHMENT0 + Wt,
              a.RENDERBUFFER,
              rt.__webglColorRenderbuffer[Wt],
            );
        }
        a.bindRenderbuffer(a.RENDERBUFFER, null),
          H.depthBuffer &&
            ((rt.__webglDepthRenderbuffer = a.createRenderbuffer()),
            It(rt.__webglDepthRenderbuffer, H, !0)),
          e.bindFramebuffer(a.FRAMEBUFFER, null);
      }
    }
    if (Et) {
      e.bindTexture(a.TEXTURE_CUBE_MAP, wt.__webglTexture), gt(a.TEXTURE_CUBE_MAP, O);
      for (let Wt = 0; Wt < 6; Wt++)
        if (O.mipmaps && O.mipmaps.length > 0)
          for (let $t = 0; $t < O.mipmaps.length; $t++)
            _t(
              rt.__webglFramebuffer[Wt][$t],
              H,
              O,
              a.COLOR_ATTACHMENT0,
              a.TEXTURE_CUBE_MAP_POSITIVE_X + Wt,
              $t,
            );
        else
          _t(
            rt.__webglFramebuffer[Wt],
            H,
            O,
            a.COLOR_ATTACHMENT0,
            a.TEXTURE_CUBE_MAP_POSITIVE_X + Wt,
            0,
          );
      T(O) && M(a.TEXTURE_CUBE_MAP), e.unbindTexture();
    } else if (Xt) {
      for (let Wt = 0, $t = Dt.length; Wt < $t; Wt++) {
        const ce = Dt[Wt],
          Ht = s.get(ce);
        e.bindTexture(a.TEXTURE_2D, Ht.__webglTexture),
          gt(a.TEXTURE_2D, ce),
          _t(rt.__webglFramebuffer, H, ce, a.COLOR_ATTACHMENT0 + Wt, a.TEXTURE_2D, 0),
          T(ce) && M(a.TEXTURE_2D);
      }
      e.unbindTexture();
    } else {
      let Wt = a.TEXTURE_2D;
      if (
        ((H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) &&
          (Wt = H.isWebGL3DRenderTarget ? a.TEXTURE_3D : a.TEXTURE_2D_ARRAY),
        e.bindTexture(Wt, wt.__webglTexture),
        gt(Wt, O),
        O.mipmaps && O.mipmaps.length > 0)
      )
        for (let $t = 0; $t < O.mipmaps.length; $t++)
          _t(rt.__webglFramebuffer[$t], H, O, a.COLOR_ATTACHMENT0, Wt, $t);
      else _t(rt.__webglFramebuffer, H, O, a.COLOR_ATTACHMENT0, Wt, 0);
      T(O) && M(Wt), e.unbindTexture();
    }
    H.depthBuffer && fe(H);
  }
  function Te(H) {
    const O = H.textures;
    for (let rt = 0, wt = O.length; rt < wt; rt++) {
      const Dt = O[rt];
      if (T(Dt)) {
        const Et = z(H),
          Xt = s.get(Dt).__webglTexture;
        e.bindTexture(Et, Xt), M(Et), e.unbindTexture();
      }
    }
  }
  const ye = [],
    G = [];
  function Zt(H) {
    if (H.samples > 0) {
      if (Ut(H) === !1) {
        const O = H.textures,
          rt = H.width,
          wt = H.height;
        let Dt = a.COLOR_BUFFER_BIT;
        const Et = H.stencilBuffer ? a.DEPTH_STENCIL_ATTACHMENT : a.DEPTH_ATTACHMENT,
          Xt = s.get(H),
          Wt = O.length > 1;
        if (Wt)
          for (let ce = 0; ce < O.length; ce++)
            e.bindFramebuffer(a.FRAMEBUFFER, Xt.__webglMultisampledFramebuffer),
              a.framebufferRenderbuffer(
                a.FRAMEBUFFER,
                a.COLOR_ATTACHMENT0 + ce,
                a.RENDERBUFFER,
                null,
              ),
              e.bindFramebuffer(a.FRAMEBUFFER, Xt.__webglFramebuffer),
              a.framebufferTexture2D(
                a.DRAW_FRAMEBUFFER,
                a.COLOR_ATTACHMENT0 + ce,
                a.TEXTURE_2D,
                null,
                0,
              );
        e.bindFramebuffer(a.READ_FRAMEBUFFER, Xt.__webglMultisampledFramebuffer);
        const $t = H.texture.mipmaps;
        $t && $t.length > 0
          ? e.bindFramebuffer(a.DRAW_FRAMEBUFFER, Xt.__webglFramebuffer[0])
          : e.bindFramebuffer(a.DRAW_FRAMEBUFFER, Xt.__webglFramebuffer);
        for (let ce = 0; ce < O.length; ce++) {
          if (
            (H.resolveDepthBuffer &&
              (H.depthBuffer && (Dt |= a.DEPTH_BUFFER_BIT),
              H.stencilBuffer && H.resolveStencilBuffer && (Dt |= a.STENCIL_BUFFER_BIT)),
            Wt)
          ) {
            a.framebufferRenderbuffer(
              a.READ_FRAMEBUFFER,
              a.COLOR_ATTACHMENT0,
              a.RENDERBUFFER,
              Xt.__webglColorRenderbuffer[ce],
            );
            const Ht = s.get(O[ce]).__webglTexture;
            a.framebufferTexture2D(a.DRAW_FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, Ht, 0);
          }
          a.blitFramebuffer(0, 0, rt, wt, 0, 0, rt, wt, Dt, a.NEAREST),
            _ === !0 &&
              ((ye.length = 0),
              (G.length = 0),
              ye.push(a.COLOR_ATTACHMENT0 + ce),
              H.depthBuffer &&
                H.resolveDepthBuffer === !1 &&
                (ye.push(Et), G.push(Et), a.invalidateFramebuffer(a.DRAW_FRAMEBUFFER, G)),
              a.invalidateFramebuffer(a.READ_FRAMEBUFFER, ye));
        }
        if (
          (e.bindFramebuffer(a.READ_FRAMEBUFFER, null),
          e.bindFramebuffer(a.DRAW_FRAMEBUFFER, null),
          Wt)
        )
          for (let ce = 0; ce < O.length; ce++) {
            e.bindFramebuffer(a.FRAMEBUFFER, Xt.__webglMultisampledFramebuffer),
              a.framebufferRenderbuffer(
                a.FRAMEBUFFER,
                a.COLOR_ATTACHMENT0 + ce,
                a.RENDERBUFFER,
                Xt.__webglColorRenderbuffer[ce],
              );
            const Ht = s.get(O[ce]).__webglTexture;
            e.bindFramebuffer(a.FRAMEBUFFER, Xt.__webglFramebuffer),
              a.framebufferTexture2D(
                a.DRAW_FRAMEBUFFER,
                a.COLOR_ATTACHMENT0 + ce,
                a.TEXTURE_2D,
                Ht,
                0,
              );
          }
        e.bindFramebuffer(a.DRAW_FRAMEBUFFER, Xt.__webglMultisampledFramebuffer);
      } else if (H.depthBuffer && H.resolveDepthBuffer === !1 && _) {
        const O = H.stencilBuffer ? a.DEPTH_STENCIL_ATTACHMENT : a.DEPTH_ATTACHMENT;
        a.invalidateFramebuffer(a.DRAW_FRAMEBUFFER, [O]);
      }
    }
  }
  function Bt(H) {
    return Math.min(l.maxSamples, H.samples);
  }
  function Ut(H) {
    const O = s.get(H);
    return (
      H.samples > 0 &&
      t.has('WEBGL_multisampled_render_to_texture') === !0 &&
      O.__useRenderToTexture !== !1
    );
  }
  function Lt(H) {
    const O = f.render.frame;
    x.get(H) !== O && (x.set(H, O), H.update());
  }
  function le(H, O) {
    const rt = H.colorSpace,
      wt = H.format,
      Dt = H.type;
    return (
      H.isCompressedTexture === !0 ||
        H.isVideoTexture === !0 ||
        (rt !== Gl &&
          rt !== Ds &&
          (en.getTransfer(rt) === dn
            ? (wt !== Pa || Dt !== Ka) &&
              console.warn(
                'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.',
              )
            : console.error('THREE.WebGLTextures: Unsupported texture color space:', rt))),
      O
    );
  }
  function kt(H) {
    return (
      typeof HTMLImageElement < 'u' && H instanceof HTMLImageElement
        ? ((g.width = H.naturalWidth || H.width), (g.height = H.naturalHeight || H.height))
        : typeof VideoFrame < 'u' && H instanceof VideoFrame
          ? ((g.width = H.displayWidth), (g.height = H.displayHeight))
          : ((g.width = H.width), (g.height = H.height)),
      g
    );
  }
  (this.allocateTextureUnit = pt),
    (this.resetTextureUnits = ft),
    (this.setTexture2D = bt),
    (this.setTexture2DArray = X),
    (this.setTexture3D = it),
    (this.setTextureCube = K),
    (this.rebindTextures = oe),
    (this.setupRenderTarget = Ne),
    (this.updateRenderTargetMipmap = Te),
    (this.updateMultisampleRenderTarget = Zt),
    (this.setupDepthRenderbuffer = fe),
    (this.setupFrameBufferTexture = _t),
    (this.useMultisampledRTT = Ut);
}
function xP(a, t) {
  function e(s, l = Ds) {
    let h;
    const f = en.getTransfer(l);
    if (s === Ka) return a.UNSIGNED_BYTE;
    if (s === Q_) return a.UNSIGNED_SHORT_4_4_4_4;
    if (s === J_) return a.UNSIGNED_SHORT_5_5_5_1;
    if (s === GS) return a.UNSIGNED_INT_5_9_9_9_REV;
    if (s === FS) return a.BYTE;
    if (s === HS) return a.SHORT;
    if (s === du) return a.UNSIGNED_SHORT;
    if (s === K_) return a.INT;
    if (s === bo) return a.UNSIGNED_INT;
    if (s === Or) return a.FLOAT;
    if (s === Tu) return a.HALF_FLOAT;
    if (s === VS) return a.ALPHA;
    if (s === WS) return a.RGB;
    if (s === Pa) return a.RGBA;
    if (s === mu) return a.DEPTH_COMPONENT;
    if (s === _u) return a.DEPTH_STENCIL;
    if (s === ZS) return a.RED;
    if (s === $_) return a.RED_INTEGER;
    if (s === XS) return a.RG;
    if (s === tg) return a.RG_INTEGER;
    if (s === eg) return a.RGBA_INTEGER;
    if (s === Tf || s === wf || s === Af || s === Cf)
      if (f === dn)
        if (((h = t.get('WEBGL_compressed_texture_s3tc_srgb')), h !== null)) {
          if (s === Tf) return h.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === wf) return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === Af) return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === Cf) return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((h = t.get('WEBGL_compressed_texture_s3tc')), h !== null)) {
        if (s === Tf) return h.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === wf) return h.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === Af) return h.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Cf) return h.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Jm || s === $m || s === t_ || s === e_)
      if (((h = t.get('WEBGL_compressed_texture_pvrtc')), h !== null)) {
        if (s === Jm) return h.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === $m) return h.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === t_) return h.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === e_) return h.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === n_ || s === i_ || s === a_)
      if (((h = t.get('WEBGL_compressed_texture_etc')), h !== null)) {
        if (s === n_ || s === i_)
          return f === dn ? h.COMPRESSED_SRGB8_ETC2 : h.COMPRESSED_RGB8_ETC2;
        if (s === a_)
          return f === dn ? h.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : h.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === r_ ||
      s === s_ ||
      s === o_ ||
      s === l_ ||
      s === c_ ||
      s === u_ ||
      s === h_ ||
      s === f_ ||
      s === d_ ||
      s === p_ ||
      s === m_ ||
      s === __ ||
      s === g_ ||
      s === v_
    )
      if (((h = t.get('WEBGL_compressed_texture_astc')), h !== null)) {
        if (s === r_)
          return f === dn ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : h.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === s_)
          return f === dn ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : h.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === o_)
          return f === dn ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : h.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === l_)
          return f === dn ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : h.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === c_)
          return f === dn ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : h.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === u_)
          return f === dn ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : h.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === h_)
          return f === dn ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : h.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === f_)
          return f === dn ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : h.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === d_)
          return f === dn
            ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : h.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === p_)
          return f === dn
            ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : h.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === m_)
          return f === dn
            ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : h.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === __)
          return f === dn
            ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : h.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === g_)
          return f === dn
            ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : h.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === v_)
          return f === dn
            ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : h.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === Rf || s === y_ || s === x_)
      if (((h = t.get('EXT_texture_compression_bptc')), h !== null)) {
        if (s === Rf)
          return f === dn
            ? h.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : h.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (s === y_) return h.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (s === x_) return h.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (s === jS || s === S_ || s === M_ || s === b_)
      if (((h = t.get('EXT_texture_compression_rgtc')), h !== null)) {
        if (s === Rf) return h.COMPRESSED_RED_RGTC1_EXT;
        if (s === S_) return h.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === M_) return h.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === b_) return h.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === pu ? a.UNSIGNED_INT_24_8 : a[s] !== void 0 ? a[s] : null;
  }
  return { convert: e };
}
const SP = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  MP = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class bP {
  constructor() {
    (this.texture = null), (this.mesh = null), (this.depthNear = 0), (this.depthFar = 0);
  }
  init(t, e, s) {
    if (this.texture === null) {
      const l = new Ai(),
        h = t.properties.get(l);
      (h.__webglTexture = e.texture),
        (e.depthNear !== s.depthNear || e.depthFar !== s.depthFar) &&
          ((this.depthNear = e.depthNear), (this.depthFar = e.depthFar)),
        (this.texture = l);
    }
  }
  getMesh(t) {
    if (this.texture !== null && this.mesh === null) {
      const e = t.cameras[0].viewport,
        s = new zs({
          vertexShader: SP,
          fragmentShader: MP,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: e.z },
            depthHeight: { value: e.w },
          },
        });
      this.mesh = new bn(new qf(20, 20), s);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class EP extends Co {
  constructor(t, e) {
    super();
    const s = this;
    let l = null,
      h = 1,
      f = null,
      m = 'local-floor',
      _ = 1,
      g = null,
      x = null,
      S = null,
      b = null,
      E = null,
      A = null;
    const R = new bP(),
      T = e.getContextAttributes();
    let M = null,
      z = null;
    const P = [],
      D = [],
      W = new Yt();
    let Z = null;
    const V = new da();
    V.viewport = new Un();
    const J = new da();
    J.viewport = new Un();
    const F = [V, J],
      I = new W2();
    let j = null,
      ft = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (tt) {
        let st = P[tt];
        return st === void 0 && ((st = new ym()), (P[tt] = st)), st.getTargetRaySpace();
      }),
      (this.getControllerGrip = function (tt) {
        let st = P[tt];
        return st === void 0 && ((st = new ym()), (P[tt] = st)), st.getGripSpace();
      }),
      (this.getHand = function (tt) {
        let st = P[tt];
        return st === void 0 && ((st = new ym()), (P[tt] = st)), st.getHandSpace();
      });
    function pt(tt) {
      const st = D.indexOf(tt.inputSource);
      if (st === -1) return;
      const _t = P[st];
      _t !== void 0 &&
        (_t.update(tt.inputSource, tt.frame, g || f),
        _t.dispatchEvent({ type: tt.type, data: tt.inputSource }));
    }
    function Mt() {
      l.removeEventListener('select', pt),
        l.removeEventListener('selectstart', pt),
        l.removeEventListener('selectend', pt),
        l.removeEventListener('squeeze', pt),
        l.removeEventListener('squeezestart', pt),
        l.removeEventListener('squeezeend', pt),
        l.removeEventListener('end', Mt),
        l.removeEventListener('inputsourceschange', bt);
      for (let tt = 0; tt < P.length; tt++) {
        const st = D[tt];
        st !== null && ((D[tt] = null), P[tt].disconnect(st));
      }
      (j = null),
        (ft = null),
        R.reset(),
        t.setRenderTarget(M),
        (E = null),
        (b = null),
        (S = null),
        (l = null),
        (z = null),
        At.stop(),
        (s.isPresenting = !1),
        t.setPixelRatio(Z),
        t.setSize(W.width, W.height, !1),
        s.dispatchEvent({ type: 'sessionend' });
    }
    (this.setFramebufferScaleFactor = function (tt) {
      (h = tt),
        s.isPresenting === !0 &&
          console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
    }),
      (this.setReferenceSpaceType = function (tt) {
        (m = tt),
          s.isPresenting === !0 &&
            console.warn(
              'THREE.WebXRManager: Cannot change reference space type while presenting.',
            );
      }),
      (this.getReferenceSpace = function () {
        return g || f;
      }),
      (this.setReferenceSpace = function (tt) {
        g = tt;
      }),
      (this.getBaseLayer = function () {
        return b !== null ? b : E;
      }),
      (this.getBinding = function () {
        return S;
      }),
      (this.getFrame = function () {
        return A;
      }),
      (this.getSession = function () {
        return l;
      }),
      (this.setSession = async function (tt) {
        if (((l = tt), l !== null)) {
          if (
            ((M = t.getRenderTarget()),
            l.addEventListener('select', pt),
            l.addEventListener('selectstart', pt),
            l.addEventListener('selectend', pt),
            l.addEventListener('squeeze', pt),
            l.addEventListener('squeezestart', pt),
            l.addEventListener('squeezeend', pt),
            l.addEventListener('end', Mt),
            l.addEventListener('inputsourceschange', bt),
            T.xrCompatible !== !0 && (await e.makeXRCompatible()),
            (Z = t.getPixelRatio()),
            t.getSize(W),
            typeof XRWebGLBinding < 'u' && 'createProjectionLayer' in XRWebGLBinding.prototype)
          ) {
            let _t = null,
              It = null,
              Gt = null;
            T.depth &&
              ((Gt = T.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
              (_t = T.stencil ? _u : mu),
              (It = T.stencil ? pu : bo));
            const fe = { colorFormat: e.RGBA8, depthFormat: Gt, scaleFactor: h };
            (S = new XRWebGLBinding(l, e)),
              (b = S.createProjectionLayer(fe)),
              l.updateRenderState({ layers: [b] }),
              t.setPixelRatio(1),
              t.setSize(b.textureWidth, b.textureHeight, !1),
              (z = new Eo(b.textureWidth, b.textureHeight, {
                format: Pa,
                type: Ka,
                depthTexture: new sM(
                  b.textureWidth,
                  b.textureHeight,
                  It,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  _t,
                ),
                stencilBuffer: T.stencil,
                colorSpace: t.outputColorSpace,
                samples: T.antialias ? 4 : 0,
                resolveDepthBuffer: b.ignoreDepthValues === !1,
                resolveStencilBuffer: b.ignoreDepthValues === !1,
              }));
          } else {
            const _t = {
              antialias: T.antialias,
              alpha: !0,
              depth: T.depth,
              stencil: T.stencil,
              framebufferScaleFactor: h,
            };
            (E = new XRWebGLLayer(l, e, _t)),
              l.updateRenderState({ baseLayer: E }),
              t.setPixelRatio(1),
              t.setSize(E.framebufferWidth, E.framebufferHeight, !1),
              (z = new Eo(E.framebufferWidth, E.framebufferHeight, {
                format: Pa,
                type: Ka,
                colorSpace: t.outputColorSpace,
                stencilBuffer: T.stencil,
                resolveDepthBuffer: E.ignoreDepthValues === !1,
                resolveStencilBuffer: E.ignoreDepthValues === !1,
              }));
          }
          (z.isXRRenderTarget = !0),
            this.setFoveation(_),
            (g = null),
            (f = await l.requestReferenceSpace(m)),
            At.setContext(l),
            At.start(),
            (s.isPresenting = !0),
            s.dispatchEvent({ type: 'sessionstart' });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (l !== null) return l.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return R.getDepthTexture();
      });
    function bt(tt) {
      for (let st = 0; st < tt.removed.length; st++) {
        const _t = tt.removed[st],
          It = D.indexOf(_t);
        It >= 0 && ((D[It] = null), P[It].disconnect(_t));
      }
      for (let st = 0; st < tt.added.length; st++) {
        const _t = tt.added[st];
        let It = D.indexOf(_t);
        if (It === -1) {
          for (let fe = 0; fe < P.length; fe++)
            if (fe >= D.length) {
              D.push(_t), (It = fe);
              break;
            } else if (D[fe] === null) {
              (D[fe] = _t), (It = fe);
              break;
            }
          if (It === -1) break;
        }
        const Gt = P[It];
        Gt && Gt.connect(_t);
      }
    }
    const X = new et(),
      it = new et();
    function K(tt, st, _t) {
      X.setFromMatrixPosition(st.matrixWorld), it.setFromMatrixPosition(_t.matrixWorld);
      const It = X.distanceTo(it),
        Gt = st.projectionMatrix.elements,
        fe = _t.projectionMatrix.elements,
        oe = Gt[14] / (Gt[10] - 1),
        Ne = Gt[14] / (Gt[10] + 1),
        Te = (Gt[9] + 1) / Gt[5],
        ye = (Gt[9] - 1) / Gt[5],
        G = (Gt[8] - 1) / Gt[0],
        Zt = (fe[8] + 1) / fe[0],
        Bt = oe * G,
        Ut = oe * Zt,
        Lt = It / (-G + Zt),
        le = Lt * -G;
      if (
        (st.matrixWorld.decompose(tt.position, tt.quaternion, tt.scale),
        tt.translateX(le),
        tt.translateZ(Lt),
        tt.matrixWorld.compose(tt.position, tt.quaternion, tt.scale),
        tt.matrixWorldInverse.copy(tt.matrixWorld).invert(),
        Gt[10] === -1)
      )
        tt.projectionMatrix.copy(st.projectionMatrix),
          tt.projectionMatrixInverse.copy(st.projectionMatrixInverse);
      else {
        const kt = oe + Lt,
          H = Ne + Lt,
          O = Bt - le,
          rt = Ut + (It - le),
          wt = ((Te * Ne) / H) * kt,
          Dt = ((ye * Ne) / H) * kt;
        tt.projectionMatrix.makePerspective(O, rt, wt, Dt, kt, H),
          tt.projectionMatrixInverse.copy(tt.projectionMatrix).invert();
      }
    }
    function zt(tt, st) {
      st === null
        ? tt.matrixWorld.copy(tt.matrix)
        : tt.matrixWorld.multiplyMatrices(st.matrixWorld, tt.matrix),
        tt.matrixWorldInverse.copy(tt.matrixWorld).invert();
    }
    this.updateCamera = function (tt) {
      if (l === null) return;
      let st = tt.near,
        _t = tt.far;
      R.texture !== null &&
        (R.depthNear > 0 && (st = R.depthNear), R.depthFar > 0 && (_t = R.depthFar)),
        (I.near = J.near = V.near = st),
        (I.far = J.far = V.far = _t),
        (j !== I.near || ft !== I.far) &&
          (l.updateRenderState({ depthNear: I.near, depthFar: I.far }), (j = I.near), (ft = I.far)),
        (V.layers.mask = tt.layers.mask | 2),
        (J.layers.mask = tt.layers.mask | 4),
        (I.layers.mask = V.layers.mask | J.layers.mask);
      const It = tt.parent,
        Gt = I.cameras;
      zt(I, It);
      for (let fe = 0; fe < Gt.length; fe++) zt(Gt[fe], It);
      Gt.length === 2 ? K(I, V, J) : I.projectionMatrix.copy(V.projectionMatrix), N(tt, I, It);
    };
    function N(tt, st, _t) {
      _t === null
        ? tt.matrix.copy(st.matrixWorld)
        : (tt.matrix.copy(_t.matrixWorld), tt.matrix.invert(), tt.matrix.multiply(st.matrixWorld)),
        tt.matrix.decompose(tt.position, tt.quaternion, tt.scale),
        tt.updateMatrixWorld(!0),
        tt.projectionMatrix.copy(st.projectionMatrix),
        tt.projectionMatrixInverse.copy(st.projectionMatrixInverse),
        tt.isPerspectiveCamera &&
          ((tt.fov = E_ * 2 * Math.atan(1 / tt.projectionMatrix.elements[5])), (tt.zoom = 1));
    }
    (this.getCamera = function () {
      return I;
    }),
      (this.getFoveation = function () {
        if (!(b === null && E === null)) return _;
      }),
      (this.setFoveation = function (tt) {
        (_ = tt),
          b !== null && (b.fixedFoveation = tt),
          E !== null && E.fixedFoveation !== void 0 && (E.fixedFoveation = tt);
      }),
      (this.hasDepthSensing = function () {
        return R.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return R.getMesh(I);
      });
    let Q = null;
    function gt(tt, st) {
      if (((x = st.getViewerPose(g || f)), (A = st), x !== null)) {
        const _t = x.views;
        E !== null && (t.setRenderTargetFramebuffer(z, E.framebuffer), t.setRenderTarget(z));
        let It = !1;
        _t.length !== I.cameras.length && ((I.cameras.length = 0), (It = !0));
        for (let oe = 0; oe < _t.length; oe++) {
          const Ne = _t[oe];
          let Te = null;
          if (E !== null) Te = E.getViewport(Ne);
          else {
            const G = S.getViewSubImage(b, Ne);
            (Te = G.viewport),
              oe === 0 &&
                (t.setRenderTargetTextures(z, G.colorTexture, G.depthStencilTexture),
                t.setRenderTarget(z));
          }
          let ye = F[oe];
          ye === void 0 &&
            ((ye = new da()), ye.layers.enable(oe), (ye.viewport = new Un()), (F[oe] = ye)),
            ye.matrix.fromArray(Ne.transform.matrix),
            ye.matrix.decompose(ye.position, ye.quaternion, ye.scale),
            ye.projectionMatrix.fromArray(Ne.projectionMatrix),
            ye.projectionMatrixInverse.copy(ye.projectionMatrix).invert(),
            ye.viewport.set(Te.x, Te.y, Te.width, Te.height),
            oe === 0 &&
              (I.matrix.copy(ye.matrix), I.matrix.decompose(I.position, I.quaternion, I.scale)),
            It === !0 && I.cameras.push(ye);
        }
        const Gt = l.enabledFeatures;
        if (Gt && Gt.includes('depth-sensing') && l.depthUsage == 'gpu-optimized' && S) {
          const oe = S.getDepthInformation(_t[0]);
          oe && oe.isValid && oe.texture && R.init(t, oe, l.renderState);
        }
      }
      for (let _t = 0; _t < P.length; _t++) {
        const It = D[_t],
          Gt = P[_t];
        It !== null && Gt !== void 0 && Gt.update(It, st, g || f);
      }
      Q && Q(tt, st),
        st.detectedPlanes && s.dispatchEvent({ type: 'planesdetected', data: st }),
        (A = null);
    }
    const At = new gM();
    At.setAnimationLoop(gt),
      (this.setAnimationLoop = function (tt) {
        Q = tt;
      }),
      (this.dispose = function () {});
  }
}
const _o = new Qa(),
  TP = new En();
function wP(a, t) {
  function e(T, M) {
    T.matrixAutoUpdate === !0 && T.updateMatrix(), M.value.copy(T.matrix);
  }
  function s(T, M) {
    M.color.getRGB(T.fogColor.value, iM(a)),
      M.isFog
        ? ((T.fogNear.value = M.near), (T.fogFar.value = M.far))
        : M.isFogExp2 && (T.fogDensity.value = M.density);
  }
  function l(T, M, z, P, D) {
    M.isMeshBasicMaterial || M.isMeshLambertMaterial
      ? h(T, M)
      : M.isMeshToonMaterial
        ? (h(T, M), S(T, M))
        : M.isMeshPhongMaterial
          ? (h(T, M), x(T, M))
          : M.isMeshStandardMaterial
            ? (h(T, M), b(T, M), M.isMeshPhysicalMaterial && E(T, M, D))
            : M.isMeshMatcapMaterial
              ? (h(T, M), A(T, M))
              : M.isMeshDepthMaterial
                ? h(T, M)
                : M.isMeshDistanceMaterial
                  ? (h(T, M), R(T, M))
                  : M.isMeshNormalMaterial
                    ? h(T, M)
                    : M.isLineBasicMaterial
                      ? (f(T, M), M.isLineDashedMaterial && m(T, M))
                      : M.isPointsMaterial
                        ? _(T, M, z, P)
                        : M.isSpriteMaterial
                          ? g(T, M)
                          : M.isShadowMaterial
                            ? (T.color.value.copy(M.color), (T.opacity.value = M.opacity))
                            : M.isShaderMaterial && (M.uniformsNeedUpdate = !1);
  }
  function h(T, M) {
    (T.opacity.value = M.opacity),
      M.color && T.diffuse.value.copy(M.color),
      M.emissive && T.emissive.value.copy(M.emissive).multiplyScalar(M.emissiveIntensity),
      M.map && ((T.map.value = M.map), e(M.map, T.mapTransform)),
      M.alphaMap && ((T.alphaMap.value = M.alphaMap), e(M.alphaMap, T.alphaMapTransform)),
      M.bumpMap &&
        ((T.bumpMap.value = M.bumpMap),
        e(M.bumpMap, T.bumpMapTransform),
        (T.bumpScale.value = M.bumpScale),
        M.side === Ni && (T.bumpScale.value *= -1)),
      M.normalMap &&
        ((T.normalMap.value = M.normalMap),
        e(M.normalMap, T.normalMapTransform),
        T.normalScale.value.copy(M.normalScale),
        M.side === Ni && T.normalScale.value.negate()),
      M.displacementMap &&
        ((T.displacementMap.value = M.displacementMap),
        e(M.displacementMap, T.displacementMapTransform),
        (T.displacementScale.value = M.displacementScale),
        (T.displacementBias.value = M.displacementBias)),
      M.emissiveMap &&
        ((T.emissiveMap.value = M.emissiveMap), e(M.emissiveMap, T.emissiveMapTransform)),
      M.specularMap &&
        ((T.specularMap.value = M.specularMap), e(M.specularMap, T.specularMapTransform)),
      M.alphaTest > 0 && (T.alphaTest.value = M.alphaTest);
    const z = t.get(M),
      P = z.envMap,
      D = z.envMapRotation;
    P &&
      ((T.envMap.value = P),
      _o.copy(D),
      (_o.x *= -1),
      (_o.y *= -1),
      (_o.z *= -1),
      P.isCubeTexture && P.isRenderTargetTexture === !1 && ((_o.y *= -1), (_o.z *= -1)),
      T.envMapRotation.value.setFromMatrix4(TP.makeRotationFromEuler(_o)),
      (T.flipEnvMap.value = P.isCubeTexture && P.isRenderTargetTexture === !1 ? -1 : 1),
      (T.reflectivity.value = M.reflectivity),
      (T.ior.value = M.ior),
      (T.refractionRatio.value = M.refractionRatio)),
      M.lightMap &&
        ((T.lightMap.value = M.lightMap),
        (T.lightMapIntensity.value = M.lightMapIntensity),
        e(M.lightMap, T.lightMapTransform)),
      M.aoMap &&
        ((T.aoMap.value = M.aoMap),
        (T.aoMapIntensity.value = M.aoMapIntensity),
        e(M.aoMap, T.aoMapTransform));
  }
  function f(T, M) {
    T.diffuse.value.copy(M.color),
      (T.opacity.value = M.opacity),
      M.map && ((T.map.value = M.map), e(M.map, T.mapTransform));
  }
  function m(T, M) {
    (T.dashSize.value = M.dashSize),
      (T.totalSize.value = M.dashSize + M.gapSize),
      (T.scale.value = M.scale);
  }
  function _(T, M, z, P) {
    T.diffuse.value.copy(M.color),
      (T.opacity.value = M.opacity),
      (T.size.value = M.size * z),
      (T.scale.value = P * 0.5),
      M.map && ((T.map.value = M.map), e(M.map, T.uvTransform)),
      M.alphaMap && ((T.alphaMap.value = M.alphaMap), e(M.alphaMap, T.alphaMapTransform)),
      M.alphaTest > 0 && (T.alphaTest.value = M.alphaTest);
  }
  function g(T, M) {
    T.diffuse.value.copy(M.color),
      (T.opacity.value = M.opacity),
      (T.rotation.value = M.rotation),
      M.map && ((T.map.value = M.map), e(M.map, T.mapTransform)),
      M.alphaMap && ((T.alphaMap.value = M.alphaMap), e(M.alphaMap, T.alphaMapTransform)),
      M.alphaTest > 0 && (T.alphaTest.value = M.alphaTest);
  }
  function x(T, M) {
    T.specular.value.copy(M.specular), (T.shininess.value = Math.max(M.shininess, 1e-4));
  }
  function S(T, M) {
    M.gradientMap && (T.gradientMap.value = M.gradientMap);
  }
  function b(T, M) {
    (T.metalness.value = M.metalness),
      M.metalnessMap &&
        ((T.metalnessMap.value = M.metalnessMap), e(M.metalnessMap, T.metalnessMapTransform)),
      (T.roughness.value = M.roughness),
      M.roughnessMap &&
        ((T.roughnessMap.value = M.roughnessMap), e(M.roughnessMap, T.roughnessMapTransform)),
      M.envMap && (T.envMapIntensity.value = M.envMapIntensity);
  }
  function E(T, M, z) {
    (T.ior.value = M.ior),
      M.sheen > 0 &&
        (T.sheenColor.value.copy(M.sheenColor).multiplyScalar(M.sheen),
        (T.sheenRoughness.value = M.sheenRoughness),
        M.sheenColorMap &&
          ((T.sheenColorMap.value = M.sheenColorMap), e(M.sheenColorMap, T.sheenColorMapTransform)),
        M.sheenRoughnessMap &&
          ((T.sheenRoughnessMap.value = M.sheenRoughnessMap),
          e(M.sheenRoughnessMap, T.sheenRoughnessMapTransform))),
      M.clearcoat > 0 &&
        ((T.clearcoat.value = M.clearcoat),
        (T.clearcoatRoughness.value = M.clearcoatRoughness),
        M.clearcoatMap &&
          ((T.clearcoatMap.value = M.clearcoatMap), e(M.clearcoatMap, T.clearcoatMapTransform)),
        M.clearcoatRoughnessMap &&
          ((T.clearcoatRoughnessMap.value = M.clearcoatRoughnessMap),
          e(M.clearcoatRoughnessMap, T.clearcoatRoughnessMapTransform)),
        M.clearcoatNormalMap &&
          ((T.clearcoatNormalMap.value = M.clearcoatNormalMap),
          e(M.clearcoatNormalMap, T.clearcoatNormalMapTransform),
          T.clearcoatNormalScale.value.copy(M.clearcoatNormalScale),
          M.side === Ni && T.clearcoatNormalScale.value.negate())),
      M.dispersion > 0 && (T.dispersion.value = M.dispersion),
      M.iridescence > 0 &&
        ((T.iridescence.value = M.iridescence),
        (T.iridescenceIOR.value = M.iridescenceIOR),
        (T.iridescenceThicknessMinimum.value = M.iridescenceThicknessRange[0]),
        (T.iridescenceThicknessMaximum.value = M.iridescenceThicknessRange[1]),
        M.iridescenceMap &&
          ((T.iridescenceMap.value = M.iridescenceMap),
          e(M.iridescenceMap, T.iridescenceMapTransform)),
        M.iridescenceThicknessMap &&
          ((T.iridescenceThicknessMap.value = M.iridescenceThicknessMap),
          e(M.iridescenceThicknessMap, T.iridescenceThicknessMapTransform))),
      M.transmission > 0 &&
        ((T.transmission.value = M.transmission),
        (T.transmissionSamplerMap.value = z.texture),
        T.transmissionSamplerSize.value.set(z.width, z.height),
        M.transmissionMap &&
          ((T.transmissionMap.value = M.transmissionMap),
          e(M.transmissionMap, T.transmissionMapTransform)),
        (T.thickness.value = M.thickness),
        M.thicknessMap &&
          ((T.thicknessMap.value = M.thicknessMap), e(M.thicknessMap, T.thicknessMapTransform)),
        (T.attenuationDistance.value = M.attenuationDistance),
        T.attenuationColor.value.copy(M.attenuationColor)),
      M.anisotropy > 0 &&
        (T.anisotropyVector.value.set(
          M.anisotropy * Math.cos(M.anisotropyRotation),
          M.anisotropy * Math.sin(M.anisotropyRotation),
        ),
        M.anisotropyMap &&
          ((T.anisotropyMap.value = M.anisotropyMap),
          e(M.anisotropyMap, T.anisotropyMapTransform))),
      (T.specularIntensity.value = M.specularIntensity),
      T.specularColor.value.copy(M.specularColor),
      M.specularColorMap &&
        ((T.specularColorMap.value = M.specularColorMap),
        e(M.specularColorMap, T.specularColorMapTransform)),
      M.specularIntensityMap &&
        ((T.specularIntensityMap.value = M.specularIntensityMap),
        e(M.specularIntensityMap, T.specularIntensityMapTransform));
  }
  function A(T, M) {
    M.matcap && (T.matcap.value = M.matcap);
  }
  function R(T, M) {
    const z = t.get(M).light;
    T.referencePosition.value.setFromMatrixPosition(z.matrixWorld),
      (T.nearDistance.value = z.shadow.camera.near),
      (T.farDistance.value = z.shadow.camera.far);
  }
  return { refreshFogUniforms: s, refreshMaterialUniforms: l };
}
function AP(a, t, e, s) {
  let l = {},
    h = {},
    f = [];
  const m = a.getParameter(a.MAX_UNIFORM_BUFFER_BINDINGS);
  function _(z, P) {
    const D = P.program;
    s.uniformBlockBinding(z, D);
  }
  function g(z, P) {
    let D = l[z.id];
    D === void 0 && (A(z), (D = x(z)), (l[z.id] = D), z.addEventListener('dispose', T));
    const W = P.program;
    s.updateUBOMapping(z, W);
    const Z = t.render.frame;
    h[z.id] !== Z && (b(z), (h[z.id] = Z));
  }
  function x(z) {
    const P = S();
    z.__bindingPointIndex = P;
    const D = a.createBuffer(),
      W = z.__size,
      Z = z.usage;
    return (
      a.bindBuffer(a.UNIFORM_BUFFER, D),
      a.bufferData(a.UNIFORM_BUFFER, W, Z),
      a.bindBuffer(a.UNIFORM_BUFFER, null),
      a.bindBufferBase(a.UNIFORM_BUFFER, P, D),
      D
    );
  }
  function S() {
    for (let z = 0; z < m; z++) if (f.indexOf(z) === -1) return f.push(z), z;
    return (
      console.error(
        'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.',
      ),
      0
    );
  }
  function b(z) {
    const P = l[z.id],
      D = z.uniforms,
      W = z.__cache;
    a.bindBuffer(a.UNIFORM_BUFFER, P);
    for (let Z = 0, V = D.length; Z < V; Z++) {
      const J = Array.isArray(D[Z]) ? D[Z] : [D[Z]];
      for (let F = 0, I = J.length; F < I; F++) {
        const j = J[F];
        if (E(j, Z, F, W) === !0) {
          const ft = j.__offset,
            pt = Array.isArray(j.value) ? j.value : [j.value];
          let Mt = 0;
          for (let bt = 0; bt < pt.length; bt++) {
            const X = pt[bt],
              it = R(X);
            typeof X == 'number' || typeof X == 'boolean'
              ? ((j.__data[0] = X), a.bufferSubData(a.UNIFORM_BUFFER, ft + Mt, j.__data))
              : X.isMatrix3
                ? ((j.__data[0] = X.elements[0]),
                  (j.__data[1] = X.elements[1]),
                  (j.__data[2] = X.elements[2]),
                  (j.__data[3] = 0),
                  (j.__data[4] = X.elements[3]),
                  (j.__data[5] = X.elements[4]),
                  (j.__data[6] = X.elements[5]),
                  (j.__data[7] = 0),
                  (j.__data[8] = X.elements[6]),
                  (j.__data[9] = X.elements[7]),
                  (j.__data[10] = X.elements[8]),
                  (j.__data[11] = 0))
                : (X.toArray(j.__data, Mt), (Mt += it.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          a.bufferSubData(a.UNIFORM_BUFFER, ft, j.__data);
        }
      }
    }
    a.bindBuffer(a.UNIFORM_BUFFER, null);
  }
  function E(z, P, D, W) {
    const Z = z.value,
      V = P + '_' + D;
    if (W[V] === void 0)
      return typeof Z == 'number' || typeof Z == 'boolean' ? (W[V] = Z) : (W[V] = Z.clone()), !0;
    {
      const J = W[V];
      if (typeof Z == 'number' || typeof Z == 'boolean') {
        if (J !== Z) return (W[V] = Z), !0;
      } else if (J.equals(Z) === !1) return J.copy(Z), !0;
    }
    return !1;
  }
  function A(z) {
    const P = z.uniforms;
    let D = 0;
    const W = 16;
    for (let V = 0, J = P.length; V < J; V++) {
      const F = Array.isArray(P[V]) ? P[V] : [P[V]];
      for (let I = 0, j = F.length; I < j; I++) {
        const ft = F[I],
          pt = Array.isArray(ft.value) ? ft.value : [ft.value];
        for (let Mt = 0, bt = pt.length; Mt < bt; Mt++) {
          const X = pt[Mt],
            it = R(X),
            K = D % W,
            zt = K % it.boundary,
            N = K + zt;
          (D += zt),
            N !== 0 && W - N < it.storage && (D += W - N),
            (ft.__data = new Float32Array(it.storage / Float32Array.BYTES_PER_ELEMENT)),
            (ft.__offset = D),
            (D += it.storage);
        }
      }
    }
    const Z = D % W;
    return Z > 0 && (D += W - Z), (z.__size = D), (z.__cache = {}), this;
  }
  function R(z) {
    const P = { boundary: 0, storage: 0 };
    return (
      typeof z == 'number' || typeof z == 'boolean'
        ? ((P.boundary = 4), (P.storage = 4))
        : z.isVector2
          ? ((P.boundary = 8), (P.storage = 8))
          : z.isVector3 || z.isColor
            ? ((P.boundary = 16), (P.storage = 12))
            : z.isVector4
              ? ((P.boundary = 16), (P.storage = 16))
              : z.isMatrix3
                ? ((P.boundary = 48), (P.storage = 48))
                : z.isMatrix4
                  ? ((P.boundary = 64), (P.storage = 64))
                  : z.isTexture
                    ? console.warn(
                        'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.',
                      )
                    : console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', z),
      P
    );
  }
  function T(z) {
    const P = z.target;
    P.removeEventListener('dispose', T);
    const D = f.indexOf(P.__bindingPointIndex);
    f.splice(D, 1), a.deleteBuffer(l[P.id]), delete l[P.id], delete h[P.id];
  }
  function M() {
    for (const z in l) a.deleteBuffer(l[z]);
    (f = []), (l = {}), (h = {});
  }
  return { bind: _, update: g, dispose: M };
}
class CP {
  constructor(t = {}) {
    const {
      canvas: e = EA(),
      context: s = null,
      depth: l = !0,
      stencil: h = !1,
      alpha: f = !1,
      antialias: m = !1,
      premultipliedAlpha: _ = !0,
      preserveDrawingBuffer: g = !1,
      powerPreference: x = 'default',
      failIfMajorPerformanceCaveat: S = !1,
      reverseDepthBuffer: b = !1,
    } = t;
    this.isWebGLRenderer = !0;
    let E;
    if (s !== null) {
      if (typeof WebGLRenderingContext < 'u' && s instanceof WebGLRenderingContext)
        throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.');
      E = s.getContextAttributes().alpha;
    } else E = f;
    const A = new Uint32Array(4),
      R = new Int32Array(4);
    let T = null,
      M = null;
    const z = [],
      P = [];
    (this.domElement = e),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.toneMapping = Us),
      (this.toneMappingExposure = 1),
      (this.transmissionResolutionScale = 1);
    const D = this;
    let W = !1;
    this._outputColorSpace = fa;
    let Z = 0,
      V = 0,
      J = null,
      F = -1,
      I = null;
    const j = new Un(),
      ft = new Un();
    let pt = null;
    const Mt = new Qe(0);
    let bt = 0,
      X = e.width,
      it = e.height,
      K = 1,
      zt = null,
      N = null;
    const Q = new Un(0, 0, X, it),
      gt = new Un(0, 0, X, it);
    let At = !1;
    const tt = new ag();
    let st = !1,
      _t = !1;
    const It = new En(),
      Gt = new En(),
      fe = new et(),
      oe = new Un(),
      Ne = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let Te = !1;
    function ye() {
      return J === null ? K : 1;
    }
    let G = s;
    function Zt(k, lt) {
      return e.getContext(k, lt);
    }
    try {
      const k = {
        alpha: !0,
        depth: l,
        stencil: h,
        antialias: m,
        premultipliedAlpha: _,
        preserveDrawingBuffer: g,
        powerPreference: x,
        failIfMajorPerformanceCaveat: S,
      };
      if (
        ('setAttribute' in e && e.setAttribute('data-engine', `three.js r${q_}`),
        e.addEventListener('webglcontextlost', Ot, !1),
        e.addEventListener('webglcontextrestored', ae, !1),
        e.addEventListener('webglcontextcreationerror', te, !1),
        G === null)
      ) {
        const lt = 'webgl2';
        if (((G = Zt(lt, k)), G === null))
          throw Zt(lt)
            ? new Error('Error creating WebGL context with your selected attributes.')
            : new Error('Error creating WebGL context.');
      }
    } catch (k) {
      throw (console.error('THREE.WebGLRenderer: ' + k.message), k);
    }
    let Bt,
      Ut,
      Lt,
      le,
      kt,
      H,
      O,
      rt,
      wt,
      Dt,
      Et,
      Xt,
      Wt,
      $t,
      ce,
      Ht,
      re,
      pe,
      Se,
      Qt,
      Oe,
      Me,
      Je,
      nt;
    function qt() {
      (Bt = new B3(G)),
        Bt.init(),
        (Me = new xP(G, Bt)),
        (Ut = new P3(G, Bt, t, Me)),
        (Lt = new vP(G, Bt)),
        Ut.reverseDepthBuffer && b && Lt.buffers.depth.setReversed(!0),
        (le = new H3(G)),
        (kt = new rP()),
        (H = new yP(G, Bt, Lt, kt, Ut, Me, le)),
        (O = new O3(D)),
        (rt = new I3(D)),
        (wt = new j2(G)),
        (Je = new R3(G, wt)),
        (Dt = new k3(G, wt, le, Je)),
        (Et = new V3(G, Dt, wt, le)),
        (Se = new G3(G, Ut, H)),
        (Ht = new D3(kt)),
        (Xt = new aP(D, O, rt, Bt, Ut, Je, Ht)),
        (Wt = new wP(D, kt)),
        ($t = new oP()),
        (ce = new dP(Bt)),
        (pe = new C3(D, O, rt, Lt, Et, E, _)),
        (re = new _P(D, Et, Ut)),
        (nt = new AP(G, le, Ut, Lt)),
        (Qt = new L3(G, Bt, le)),
        (Oe = new F3(G, Bt, le)),
        (le.programs = Xt.programs),
        (D.capabilities = Ut),
        (D.extensions = Bt),
        (D.properties = kt),
        (D.renderLists = $t),
        (D.shadowMap = re),
        (D.state = Lt),
        (D.info = le);
    }
    qt();
    const Ct = new EP(D, G);
    (this.xr = Ct),
      (this.getContext = function () {
        return G;
      }),
      (this.getContextAttributes = function () {
        return G.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const k = Bt.get('WEBGL_lose_context');
        k && k.loseContext();
      }),
      (this.forceContextRestore = function () {
        const k = Bt.get('WEBGL_lose_context');
        k && k.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return K;
      }),
      (this.setPixelRatio = function (k) {
        k !== void 0 && ((K = k), this.setSize(X, it, !1));
      }),
      (this.getSize = function (k) {
        return k.set(X, it);
      }),
      (this.setSize = function (k, lt, yt = !0) {
        if (Ct.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        (X = k),
          (it = lt),
          (e.width = Math.floor(k * K)),
          (e.height = Math.floor(lt * K)),
          yt === !0 && ((e.style.width = k + 'px'), (e.style.height = lt + 'px')),
          this.setViewport(0, 0, k, lt);
      }),
      (this.getDrawingBufferSize = function (k) {
        return k.set(X * K, it * K).floor();
      }),
      (this.setDrawingBufferSize = function (k, lt, yt) {
        (X = k),
          (it = lt),
          (K = yt),
          (e.width = Math.floor(k * yt)),
          (e.height = Math.floor(lt * yt)),
          this.setViewport(0, 0, k, lt);
      }),
      (this.getCurrentViewport = function (k) {
        return k.copy(j);
      }),
      (this.getViewport = function (k) {
        return k.copy(Q);
      }),
      (this.setViewport = function (k, lt, yt, Tt) {
        k.isVector4 ? Q.set(k.x, k.y, k.z, k.w) : Q.set(k, lt, yt, Tt),
          Lt.viewport(j.copy(Q).multiplyScalar(K).round());
      }),
      (this.getScissor = function (k) {
        return k.copy(gt);
      }),
      (this.setScissor = function (k, lt, yt, Tt) {
        k.isVector4 ? gt.set(k.x, k.y, k.z, k.w) : gt.set(k, lt, yt, Tt),
          Lt.scissor(ft.copy(gt).multiplyScalar(K).round());
      }),
      (this.getScissorTest = function () {
        return At;
      }),
      (this.setScissorTest = function (k) {
        Lt.setScissorTest((At = k));
      }),
      (this.setOpaqueSort = function (k) {
        zt = k;
      }),
      (this.setTransparentSort = function (k) {
        N = k;
      }),
      (this.getClearColor = function (k) {
        return k.copy(pe.getClearColor());
      }),
      (this.setClearColor = function () {
        pe.setClearColor(...arguments);
      }),
      (this.getClearAlpha = function () {
        return pe.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        pe.setClearAlpha(...arguments);
      }),
      (this.clear = function (k = !0, lt = !0, yt = !0) {
        let Tt = 0;
        if (k) {
          let ut = !1;
          if (J !== null) {
            const Vt = J.texture.format;
            ut = Vt === eg || Vt === tg || Vt === $_;
          }
          if (ut) {
            const Vt = J.texture.type,
              Kt = Vt === Ka || Vt === bo || Vt === du || Vt === pu || Vt === Q_ || Vt === J_,
              Jt = pe.getClearColor(),
              se = pe.getClearAlpha(),
              Ee = Jt.r,
              be = Jt.g,
              ve = Jt.b;
            Kt
              ? ((A[0] = Ee),
                (A[1] = be),
                (A[2] = ve),
                (A[3] = se),
                G.clearBufferuiv(G.COLOR, 0, A))
              : ((R[0] = Ee),
                (R[1] = be),
                (R[2] = ve),
                (R[3] = se),
                G.clearBufferiv(G.COLOR, 0, R));
          } else Tt |= G.COLOR_BUFFER_BIT;
        }
        lt && (Tt |= G.DEPTH_BUFFER_BIT),
          yt && ((Tt |= G.STENCIL_BUFFER_BIT), this.state.buffers.stencil.setMask(4294967295)),
          G.clear(Tt);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        e.removeEventListener('webglcontextlost', Ot, !1),
          e.removeEventListener('webglcontextrestored', ae, !1),
          e.removeEventListener('webglcontextcreationerror', te, !1),
          pe.dispose(),
          $t.dispose(),
          ce.dispose(),
          kt.dispose(),
          O.dispose(),
          rt.dispose(),
          Et.dispose(),
          Je.dispose(),
          nt.dispose(),
          Xt.dispose(),
          Ct.dispose(),
          Ct.removeEventListener('sessionstart', Nn),
          Ct.removeEventListener('sessionend', Wn),
          ui.stop();
      });
    function Ot(k) {
      k.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (W = !0);
    }
    function ae() {
      console.log('THREE.WebGLRenderer: Context Restored.'), (W = !1);
      const k = le.autoReset,
        lt = re.enabled,
        yt = re.autoUpdate,
        Tt = re.needsUpdate,
        ut = re.type;
      qt(),
        (le.autoReset = k),
        (re.enabled = lt),
        (re.autoUpdate = yt),
        (re.needsUpdate = Tt),
        (re.type = ut);
    }
    function te(k) {
      console.error(
        'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
        k.statusMessage,
      );
    }
    function Pe(k) {
      const lt = k.target;
      lt.removeEventListener('dispose', Pe), cn(lt);
    }
    function cn(k) {
      Rn(k), kt.remove(k);
    }
    function Rn(k) {
      const lt = kt.get(k).programs;
      lt !== void 0 &&
        (lt.forEach(function (yt) {
          Xt.releaseProgram(yt);
        }),
        k.isShaderMaterial && Xt.releaseShaderCache(k));
    }
    this.renderBufferDirect = function (k, lt, yt, Tt, ut, Vt) {
      lt === null && (lt = Ne);
      const Kt = ut.isMesh && ut.matrixWorld.determinant() < 0,
        Jt = Ci(k, lt, yt, Tt, ut);
      Lt.setMaterial(Tt, Kt);
      let se = yt.index,
        Ee = 1;
      if (Tt.wireframe === !0) {
        if (((se = Dt.getWireframeAttribute(yt)), se === void 0)) return;
        Ee = 2;
      }
      const be = yt.drawRange,
        ve = yt.attributes.position;
      let Ue = be.start * Ee,
        ue = (be.start + be.count) * Ee;
      Vt !== null &&
        ((Ue = Math.max(Ue, Vt.start * Ee)), (ue = Math.min(ue, (Vt.start + Vt.count) * Ee))),
        se !== null
          ? ((Ue = Math.max(Ue, 0)), (ue = Math.min(ue, se.count)))
          : ve != null && ((Ue = Math.max(Ue, 0)), (ue = Math.min(ue, ve.count)));
      const Re = ue - Ue;
      if (Re < 0 || Re === 1 / 0) return;
      Je.setup(ut, Tt, Jt, yt, se);
      let ke,
        ze = Qt;
      if ((se !== null && ((ke = wt.get(se)), (ze = Oe), ze.setIndex(ke)), ut.isMesh))
        Tt.wireframe === !0
          ? (Lt.setLineWidth(Tt.wireframeLinewidth * ye()), ze.setMode(G.LINES))
          : ze.setMode(G.TRIANGLES);
      else if (ut.isLine) {
        let ge = Tt.linewidth;
        ge === void 0 && (ge = 1),
          Lt.setLineWidth(ge * ye()),
          ut.isLineSegments
            ? ze.setMode(G.LINES)
            : ut.isLineLoop
              ? ze.setMode(G.LINE_LOOP)
              : ze.setMode(G.LINE_STRIP);
      } else ut.isPoints ? ze.setMode(G.POINTS) : ut.isSprite && ze.setMode(G.TRIANGLES);
      if (ut.isBatchedMesh)
        if (ut._multiDrawInstances !== null)
          Pf(
            'THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.',
          ),
            ze.renderMultiDrawInstances(
              ut._multiDrawStarts,
              ut._multiDrawCounts,
              ut._multiDrawCount,
              ut._multiDrawInstances,
            );
        else if (Bt.get('WEBGL_multi_draw'))
          ze.renderMultiDraw(ut._multiDrawStarts, ut._multiDrawCounts, ut._multiDrawCount);
        else {
          const ge = ut._multiDrawStarts,
            gn = ut._multiDrawCounts,
            ne = ut._multiDrawCount,
            We = se ? wt.get(se).bytesPerElement : 1,
            ea = kt.get(Tt).currentProgram.getUniforms();
          for (let nn = 0; nn < ne; nn++)
            ea.setValue(G, '_gl_DrawID', nn), ze.render(ge[nn] / We, gn[nn]);
        }
      else if (ut.isInstancedMesh) ze.renderInstances(Ue, Re, ut.count);
      else if (yt.isInstancedBufferGeometry) {
        const ge = yt._maxInstanceCount !== void 0 ? yt._maxInstanceCount : 1 / 0,
          gn = Math.min(yt.instanceCount, ge);
        ze.renderInstances(Ue, Re, gn);
      } else ze.render(Ue, Re);
    };
    function Ye(k, lt, yt) {
      k.transparent === !0 && k.side === Dr && k.forceSinglePass === !1
        ? ((k.side = Ni),
          (k.needsUpdate = !0),
          ga(k, lt, yt),
          (k.side = Ns),
          (k.needsUpdate = !0),
          ga(k, lt, yt),
          (k.side = Dr))
        : ga(k, lt, yt);
    }
    (this.compile = function (k, lt, yt = null) {
      yt === null && (yt = k),
        (M = ce.get(yt)),
        M.init(lt),
        P.push(M),
        yt.traverseVisible(function (ut) {
          ut.isLight &&
            ut.layers.test(lt.layers) &&
            (M.pushLight(ut), ut.castShadow && M.pushShadow(ut));
        }),
        k !== yt &&
          k.traverseVisible(function (ut) {
            ut.isLight &&
              ut.layers.test(lt.layers) &&
              (M.pushLight(ut), ut.castShadow && M.pushShadow(ut));
          }),
        M.setupLights();
      const Tt = new Set();
      return (
        k.traverse(function (ut) {
          if (!(ut.isMesh || ut.isPoints || ut.isLine || ut.isSprite)) return;
          const Vt = ut.material;
          if (Vt)
            if (Array.isArray(Vt))
              for (let Kt = 0; Kt < Vt.length; Kt++) {
                const Jt = Vt[Kt];
                Ye(Jt, yt, ut), Tt.add(Jt);
              }
            else Ye(Vt, yt, ut), Tt.add(Vt);
        }),
        (M = P.pop()),
        Tt
      );
    }),
      (this.compileAsync = function (k, lt, yt = null) {
        const Tt = this.compile(k, lt, yt);
        return new Promise((ut) => {
          function Vt() {
            if (
              (Tt.forEach(function (Kt) {
                kt.get(Kt).currentProgram.isReady() && Tt.delete(Kt);
              }),
              Tt.size === 0)
            ) {
              ut(k);
              return;
            }
            setTimeout(Vt, 10);
          }
          Bt.get('KHR_parallel_shader_compile') !== null ? Vt() : setTimeout(Vt, 10);
        });
      });
    let ii = null;
    function kn(k) {
      ii && ii(k);
    }
    function Nn() {
      ui.stop();
    }
    function Wn() {
      ui.start();
    }
    const ui = new gM();
    ui.setAnimationLoop(kn),
      typeof self < 'u' && ui.setContext(self),
      (this.setAnimationLoop = function (k) {
        (ii = k), Ct.setAnimationLoop(k), k === null ? ui.stop() : ui.start();
      }),
      Ct.addEventListener('sessionstart', Nn),
      Ct.addEventListener('sessionend', Wn),
      (this.render = function (k, lt) {
        if (lt !== void 0 && lt.isCamera !== !0) {
          console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
          return;
        }
        if (W === !0) return;
        if (
          (k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(),
          lt.parent === null && lt.matrixWorldAutoUpdate === !0 && lt.updateMatrixWorld(),
          Ct.enabled === !0 &&
            Ct.isPresenting === !0 &&
            (Ct.cameraAutoUpdate === !0 && Ct.updateCamera(lt), (lt = Ct.getCamera())),
          k.isScene === !0 && k.onBeforeRender(D, k, lt, J),
          (M = ce.get(k, P.length)),
          M.init(lt),
          P.push(M),
          Gt.multiplyMatrices(lt.projectionMatrix, lt.matrixWorldInverse),
          tt.setFromProjectionMatrix(Gt),
          (_t = this.localClippingEnabled),
          (st = Ht.init(this.clippingPlanes, _t)),
          (T = $t.get(k, z.length)),
          T.init(),
          z.push(T),
          Ct.enabled === !0 && Ct.isPresenting === !0)
        ) {
          const Vt = D.xr.getDepthSensingMesh();
          Vt !== null && Kn(Vt, lt, -1 / 0, D.sortObjects);
        }
        Kn(k, lt, 0, D.sortObjects),
          T.finish(),
          D.sortObjects === !0 && T.sort(zt, N),
          (Te = Ct.enabled === !1 || Ct.isPresenting === !1 || Ct.hasDepthSensing() === !1),
          Te && pe.addToRenderList(T, k),
          this.info.render.frame++,
          st === !0 && Ht.beginShadows();
        const yt = M.state.shadowsArray;
        re.render(yt, k, lt),
          st === !0 && Ht.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const Tt = T.opaque,
          ut = T.transmissive;
        if ((M.setupLights(), lt.isArrayCamera)) {
          const Vt = lt.cameras;
          if (ut.length > 0)
            for (let Kt = 0, Jt = Vt.length; Kt < Jt; Kt++) {
              const se = Vt[Kt];
              Is(Tt, ut, k, se);
            }
          Te && pe.render(k);
          for (let Kt = 0, Jt = Vt.length; Kt < Jt; Kt++) {
            const se = Vt[Kt];
            me(T, k, se, se.viewport);
          }
        } else ut.length > 0 && Is(Tt, ut, k, lt), Te && pe.render(k), me(T, k, lt);
        J !== null &&
          V === 0 &&
          (H.updateMultisampleRenderTarget(J), H.updateRenderTargetMipmap(J)),
          k.isScene === !0 && k.onAfterRender(D, k, lt),
          Je.resetDefaultState(),
          (F = -1),
          (I = null),
          P.pop(),
          P.length > 0
            ? ((M = P[P.length - 1]),
              st === !0 && Ht.setGlobalState(D.clippingPlanes, M.state.camera))
            : (M = null),
          z.pop(),
          z.length > 0 ? (T = z[z.length - 1]) : (T = null);
      });
    function Kn(k, lt, yt, Tt) {
      if (k.visible === !1) return;
      if (k.layers.test(lt.layers)) {
        if (k.isGroup) yt = k.renderOrder;
        else if (k.isLOD) k.autoUpdate === !0 && k.update(lt);
        else if (k.isLight) M.pushLight(k), k.castShadow && M.pushShadow(k);
        else if (k.isSprite) {
          if (!k.frustumCulled || tt.intersectsSprite(k)) {
            Tt && oe.setFromMatrixPosition(k.matrixWorld).applyMatrix4(Gt);
            const Kt = Et.update(k),
              Jt = k.material;
            Jt.visible && T.push(k, Kt, Jt, yt, oe.z, null);
          }
        } else if (
          (k.isMesh || k.isLine || k.isPoints) &&
          (!k.frustumCulled || tt.intersectsObject(k))
        ) {
          const Kt = Et.update(k),
            Jt = k.material;
          if (
            (Tt &&
              (k.boundingSphere !== void 0
                ? (k.boundingSphere === null && k.computeBoundingSphere(),
                  oe.copy(k.boundingSphere.center))
                : (Kt.boundingSphere === null && Kt.computeBoundingSphere(),
                  oe.copy(Kt.boundingSphere.center)),
              oe.applyMatrix4(k.matrixWorld).applyMatrix4(Gt)),
            Array.isArray(Jt))
          ) {
            const se = Kt.groups;
            for (let Ee = 0, be = se.length; Ee < be; Ee++) {
              const ve = se[Ee],
                Ue = Jt[ve.materialIndex];
              Ue && Ue.visible && T.push(k, Kt, Ue, yt, oe.z, ve);
            }
          } else Jt.visible && T.push(k, Kt, Jt, yt, oe.z, null);
        }
      }
      const Vt = k.children;
      for (let Kt = 0, Jt = Vt.length; Kt < Jt; Kt++) Kn(Vt[Kt], lt, yt, Tt);
    }
    function me(k, lt, yt, Tt) {
      const ut = k.opaque,
        Vt = k.transmissive,
        Kt = k.transparent;
      M.setupLightsView(yt),
        st === !0 && Ht.setGlobalState(D.clippingPlanes, yt),
        Tt && Lt.viewport(j.copy(Tt)),
        ut.length > 0 && Oa(ut, lt, yt),
        Vt.length > 0 && Oa(Vt, lt, yt),
        Kt.length > 0 && Oa(Kt, lt, yt),
        Lt.buffers.depth.setTest(!0),
        Lt.buffers.depth.setMask(!0),
        Lt.buffers.color.setMask(!0),
        Lt.setPolygonOffset(!1);
    }
    function Is(k, lt, yt, Tt) {
      if ((yt.isScene === !0 ? yt.overrideMaterial : null) !== null) return;
      M.state.transmissionRenderTarget[Tt.id] === void 0 &&
        (M.state.transmissionRenderTarget[Tt.id] = new Eo(1, 1, {
          generateMipmaps: !0,
          type: Bt.has('EXT_color_buffer_half_float') || Bt.has('EXT_color_buffer_float') ? Tu : Ka,
          minFilter: Mo,
          samples: 4,
          stencilBuffer: h,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: en.workingColorSpace,
        }));
      const Vt = M.state.transmissionRenderTarget[Tt.id],
        Kt = Tt.viewport || j;
      Vt.setSize(Kt.z * D.transmissionResolutionScale, Kt.w * D.transmissionResolutionScale);
      const Jt = D.getRenderTarget();
      D.setRenderTarget(Vt),
        D.getClearColor(Mt),
        (bt = D.getClearAlpha()),
        bt < 1 && D.setClearColor(16777215, 0.5),
        D.clear(),
        Te && pe.render(yt);
      const se = D.toneMapping;
      D.toneMapping = Us;
      const Ee = Tt.viewport;
      if (
        (Tt.viewport !== void 0 && (Tt.viewport = void 0),
        M.setupLightsView(Tt),
        st === !0 && Ht.setGlobalState(D.clippingPlanes, Tt),
        Oa(k, yt, Tt),
        H.updateMultisampleRenderTarget(Vt),
        H.updateRenderTargetMipmap(Vt),
        Bt.has('WEBGL_multisampled_render_to_texture') === !1)
      ) {
        let be = !1;
        for (let ve = 0, Ue = lt.length; ve < Ue; ve++) {
          const ue = lt[ve],
            Re = ue.object,
            ke = ue.geometry,
            ze = ue.material,
            ge = ue.group;
          if (ze.side === Dr && Re.layers.test(Tt.layers)) {
            const gn = ze.side;
            (ze.side = Ni),
              (ze.needsUpdate = !0),
              _a(Re, yt, Tt, ke, ze, ge),
              (ze.side = gn),
              (ze.needsUpdate = !0),
              (be = !0);
          }
        }
        be === !0 && (H.updateMultisampleRenderTarget(Vt), H.updateRenderTargetMipmap(Vt));
      }
      D.setRenderTarget(Jt),
        D.setClearColor(Mt, bt),
        Ee !== void 0 && (Tt.viewport = Ee),
        (D.toneMapping = se);
    }
    function Oa(k, lt, yt) {
      const Tt = lt.isScene === !0 ? lt.overrideMaterial : null;
      for (let ut = 0, Vt = k.length; ut < Vt; ut++) {
        const Kt = k[ut],
          Jt = Kt.object,
          se = Kt.geometry,
          Ee = Kt.group;
        let be = Kt.material;
        be.allowOverride === !0 && Tt !== null && (be = Tt),
          Jt.layers.test(yt.layers) && _a(Jt, lt, yt, se, be, Ee);
      }
    }
    function _a(k, lt, yt, Tt, ut, Vt) {
      k.onBeforeRender(D, lt, yt, Tt, ut, Vt),
        k.modelViewMatrix.multiplyMatrices(yt.matrixWorldInverse, k.matrixWorld),
        k.normalMatrix.getNormalMatrix(k.modelViewMatrix),
        ut.onBeforeRender(D, lt, yt, Tt, k, Vt),
        ut.transparent === !0 && ut.side === Dr && ut.forceSinglePass === !1
          ? ((ut.side = Ni),
            (ut.needsUpdate = !0),
            D.renderBufferDirect(yt, lt, Tt, ut, k, Vt),
            (ut.side = Ns),
            (ut.needsUpdate = !0),
            D.renderBufferDirect(yt, lt, Tt, ut, k, Vt),
            (ut.side = Dr))
          : D.renderBufferDirect(yt, lt, Tt, ut, k, Vt),
        k.onAfterRender(D, lt, yt, Tt, ut, Vt);
    }
    function ga(k, lt, yt) {
      lt.isScene !== !0 && (lt = Ne);
      const Tt = kt.get(k),
        ut = M.state.lights,
        Vt = M.state.shadowsArray,
        Kt = ut.state.version,
        Jt = Xt.getParameters(k, ut.state, Vt, lt, yt),
        se = Xt.getProgramCacheKey(Jt);
      let Ee = Tt.programs;
      (Tt.environment = k.isMeshStandardMaterial ? lt.environment : null),
        (Tt.fog = lt.fog),
        (Tt.envMap = (k.isMeshStandardMaterial ? rt : O).get(k.envMap || Tt.environment)),
        (Tt.envMapRotation =
          Tt.environment !== null && k.envMap === null ? lt.environmentRotation : k.envMapRotation),
        Ee === void 0 && (k.addEventListener('dispose', Pe), (Ee = new Map()), (Tt.programs = Ee));
      let be = Ee.get(se);
      if (be !== void 0) {
        if (Tt.currentProgram === be && Tt.lightsStateVersion === Kt) return ta(k, Jt), be;
      } else
        (Jt.uniforms = Xt.getUniforms(k)),
          k.onBeforeCompile(Jt, D),
          (be = Xt.acquireProgram(Jt, se)),
          Ee.set(se, be),
          (Tt.uniforms = Jt.uniforms);
      const ve = Tt.uniforms;
      return (
        ((!k.isShaderMaterial && !k.isRawShaderMaterial) || k.clipping === !0) &&
          (ve.clippingPlanes = Ht.uniform),
        ta(k, Jt),
        (Tt.needsLights = Ln(k)),
        (Tt.lightsStateVersion = Kt),
        Tt.needsLights &&
          ((ve.ambientLightColor.value = ut.state.ambient),
          (ve.lightProbe.value = ut.state.probe),
          (ve.directionalLights.value = ut.state.directional),
          (ve.directionalLightShadows.value = ut.state.directionalShadow),
          (ve.spotLights.value = ut.state.spot),
          (ve.spotLightShadows.value = ut.state.spotShadow),
          (ve.rectAreaLights.value = ut.state.rectArea),
          (ve.ltc_1.value = ut.state.rectAreaLTC1),
          (ve.ltc_2.value = ut.state.rectAreaLTC2),
          (ve.pointLights.value = ut.state.point),
          (ve.pointLightShadows.value = ut.state.pointShadow),
          (ve.hemisphereLights.value = ut.state.hemi),
          (ve.directionalShadowMap.value = ut.state.directionalShadowMap),
          (ve.directionalShadowMatrix.value = ut.state.directionalShadowMatrix),
          (ve.spotShadowMap.value = ut.state.spotShadowMap),
          (ve.spotLightMatrix.value = ut.state.spotLightMatrix),
          (ve.spotLightMap.value = ut.state.spotLightMap),
          (ve.pointShadowMap.value = ut.state.pointShadowMap),
          (ve.pointShadowMatrix.value = ut.state.pointShadowMatrix)),
        (Tt.currentProgram = be),
        (Tt.uniformsList = null),
        be
      );
    }
    function Ii(k) {
      if (k.uniformsList === null) {
        const lt = k.currentProgram.getUniforms();
        k.uniformsList = Df.seqWithValue(lt.seq, k.uniforms);
      }
      return k.uniformsList;
    }
    function ta(k, lt) {
      const yt = kt.get(k);
      (yt.outputColorSpace = lt.outputColorSpace),
        (yt.batching = lt.batching),
        (yt.batchingColor = lt.batchingColor),
        (yt.instancing = lt.instancing),
        (yt.instancingColor = lt.instancingColor),
        (yt.instancingMorph = lt.instancingMorph),
        (yt.skinning = lt.skinning),
        (yt.morphTargets = lt.morphTargets),
        (yt.morphNormals = lt.morphNormals),
        (yt.morphColors = lt.morphColors),
        (yt.morphTargetsCount = lt.morphTargetsCount),
        (yt.numClippingPlanes = lt.numClippingPlanes),
        (yt.numIntersection = lt.numClipIntersection),
        (yt.vertexAlphas = lt.vertexAlphas),
        (yt.vertexTangents = lt.vertexTangents),
        (yt.toneMapping = lt.toneMapping);
    }
    function Ci(k, lt, yt, Tt, ut) {
      lt.isScene !== !0 && (lt = Ne), H.resetTextureUnits();
      const Vt = lt.fog,
        Kt = Tt.isMeshStandardMaterial ? lt.environment : null,
        Jt =
          J === null ? D.outputColorSpace : J.isXRRenderTarget === !0 ? J.texture.colorSpace : Gl,
        se = (Tt.isMeshStandardMaterial ? rt : O).get(Tt.envMap || Kt),
        Ee = Tt.vertexColors === !0 && !!yt.attributes.color && yt.attributes.color.itemSize === 4,
        be = !!yt.attributes.tangent && (!!Tt.normalMap || Tt.anisotropy > 0),
        ve = !!yt.morphAttributes.position,
        Ue = !!yt.morphAttributes.normal,
        ue = !!yt.morphAttributes.color;
      let Re = Us;
      Tt.toneMapped && (J === null || J.isXRRenderTarget === !0) && (Re = D.toneMapping);
      const ke =
          yt.morphAttributes.position || yt.morphAttributes.normal || yt.morphAttributes.color,
        ze = ke !== void 0 ? ke.length : 0,
        ge = kt.get(Tt),
        gn = M.state.lights;
      if (st === !0 && (_t === !0 || k !== I)) {
        const He = k === I && Tt.id === F;
        Ht.setState(Tt, k, He);
      }
      let ne = !1;
      Tt.version === ge.__version
        ? ((ge.needsLights && ge.lightsStateVersion !== gn.state.version) ||
            ge.outputColorSpace !== Jt ||
            (ut.isBatchedMesh && ge.batching === !1) ||
            (!ut.isBatchedMesh && ge.batching === !0) ||
            (ut.isBatchedMesh && ge.batchingColor === !0 && ut.colorTexture === null) ||
            (ut.isBatchedMesh && ge.batchingColor === !1 && ut.colorTexture !== null) ||
            (ut.isInstancedMesh && ge.instancing === !1) ||
            (!ut.isInstancedMesh && ge.instancing === !0) ||
            (ut.isSkinnedMesh && ge.skinning === !1) ||
            (!ut.isSkinnedMesh && ge.skinning === !0) ||
            (ut.isInstancedMesh && ge.instancingColor === !0 && ut.instanceColor === null) ||
            (ut.isInstancedMesh && ge.instancingColor === !1 && ut.instanceColor !== null) ||
            (ut.isInstancedMesh && ge.instancingMorph === !0 && ut.morphTexture === null) ||
            (ut.isInstancedMesh && ge.instancingMorph === !1 && ut.morphTexture !== null) ||
            ge.envMap !== se ||
            (Tt.fog === !0 && ge.fog !== Vt) ||
            (ge.numClippingPlanes !== void 0 &&
              (ge.numClippingPlanes !== Ht.numPlanes ||
                ge.numIntersection !== Ht.numIntersection)) ||
            ge.vertexAlphas !== Ee ||
            ge.vertexTangents !== be ||
            ge.morphTargets !== ve ||
            ge.morphNormals !== Ue ||
            ge.morphColors !== ue ||
            ge.toneMapping !== Re ||
            ge.morphTargetsCount !== ze) &&
          (ne = !0)
        : ((ne = !0), (ge.__version = Tt.version));
      let We = ge.currentProgram;
      ne === !0 && (We = ga(Tt, lt, ut));
      let ea = !1,
        nn = !1,
        Pn = !1;
      const sn = We.getUniforms(),
        zn = ge.uniforms;
      if (
        (Lt.useProgram(We.program) && ((ea = !0), (nn = !0), (Pn = !0)),
        Tt.id !== F && ((F = Tt.id), (nn = !0)),
        ea || I !== k)
      ) {
        Lt.buffers.depth.getReversed()
          ? (It.copy(k.projectionMatrix), wA(It), AA(It), sn.setValue(G, 'projectionMatrix', It))
          : sn.setValue(G, 'projectionMatrix', k.projectionMatrix),
          sn.setValue(G, 'viewMatrix', k.matrixWorldInverse);
        const xn = sn.map.cameraPosition;
        xn !== void 0 && xn.setValue(G, fe.setFromMatrixPosition(k.matrixWorld)),
          Ut.logarithmicDepthBuffer &&
            sn.setValue(G, 'logDepthBufFC', 2 / (Math.log(k.far + 1) / Math.LN2)),
          (Tt.isMeshPhongMaterial ||
            Tt.isMeshToonMaterial ||
            Tt.isMeshLambertMaterial ||
            Tt.isMeshBasicMaterial ||
            Tt.isMeshStandardMaterial ||
            Tt.isShaderMaterial) &&
            sn.setValue(G, 'isOrthographic', k.isOrthographicCamera === !0),
          I !== k && ((I = k), (nn = !0), (Pn = !0));
      }
      if (ut.isSkinnedMesh) {
        sn.setOptional(G, ut, 'bindMatrix'), sn.setOptional(G, ut, 'bindMatrixInverse');
        const He = ut.skeleton;
        He &&
          (He.boneTexture === null && He.computeBoneTexture(),
          sn.setValue(G, 'boneTexture', He.boneTexture, H));
      }
      ut.isBatchedMesh &&
        (sn.setOptional(G, ut, 'batchingTexture'),
        sn.setValue(G, 'batchingTexture', ut._matricesTexture, H),
        sn.setOptional(G, ut, 'batchingIdTexture'),
        sn.setValue(G, 'batchingIdTexture', ut._indirectTexture, H),
        sn.setOptional(G, ut, 'batchingColorTexture'),
        ut._colorsTexture !== null && sn.setValue(G, 'batchingColorTexture', ut._colorsTexture, H));
      const mn = yt.morphAttributes;
      if (
        ((mn.position !== void 0 || mn.normal !== void 0 || mn.color !== void 0) &&
          Se.update(ut, yt, We),
        (nn || ge.receiveShadow !== ut.receiveShadow) &&
          ((ge.receiveShadow = ut.receiveShadow),
          sn.setValue(G, 'receiveShadow', ut.receiveShadow)),
        Tt.isMeshGouraudMaterial &&
          Tt.envMap !== null &&
          ((zn.envMap.value = se),
          (zn.flipEnvMap.value = se.isCubeTexture && se.isRenderTargetTexture === !1 ? -1 : 1)),
        Tt.isMeshStandardMaterial &&
          Tt.envMap === null &&
          lt.environment !== null &&
          (zn.envMapIntensity.value = lt.environmentIntensity),
        nn &&
          (sn.setValue(G, 'toneMappingExposure', D.toneMappingExposure),
          ge.needsLights && va(zn, Pn),
          Vt && Tt.fog === !0 && Wt.refreshFogUniforms(zn, Vt),
          Wt.refreshMaterialUniforms(zn, Tt, K, it, M.state.transmissionRenderTarget[k.id]),
          Df.upload(G, Ii(ge), zn, H)),
        Tt.isShaderMaterial &&
          Tt.uniformsNeedUpdate === !0 &&
          (Df.upload(G, Ii(ge), zn, H), (Tt.uniformsNeedUpdate = !1)),
        Tt.isSpriteMaterial && sn.setValue(G, 'center', ut.center),
        sn.setValue(G, 'modelViewMatrix', ut.modelViewMatrix),
        sn.setValue(G, 'normalMatrix', ut.normalMatrix),
        sn.setValue(G, 'modelMatrix', ut.matrixWorld),
        Tt.isShaderMaterial || Tt.isRawShaderMaterial)
      ) {
        const He = Tt.uniformsGroups;
        for (let xn = 0, hi = He.length; xn < hi; xn++) {
          const yi = He[xn];
          nt.update(yi, We), nt.bind(yi, We);
        }
      }
      return We;
    }
    function va(k, lt) {
      (k.ambientLightColor.needsUpdate = lt),
        (k.lightProbe.needsUpdate = lt),
        (k.directionalLights.needsUpdate = lt),
        (k.directionalLightShadows.needsUpdate = lt),
        (k.pointLights.needsUpdate = lt),
        (k.pointLightShadows.needsUpdate = lt),
        (k.spotLights.needsUpdate = lt),
        (k.spotLightShadows.needsUpdate = lt),
        (k.rectAreaLights.needsUpdate = lt),
        (k.hemisphereLights.needsUpdate = lt);
    }
    function Ln(k) {
      return (
        k.isMeshLambertMaterial ||
        k.isMeshToonMaterial ||
        k.isMeshPhongMaterial ||
        k.isMeshStandardMaterial ||
        k.isShadowMaterial ||
        (k.isShaderMaterial && k.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return Z;
    }),
      (this.getActiveMipmapLevel = function () {
        return V;
      }),
      (this.getRenderTarget = function () {
        return J;
      }),
      (this.setRenderTargetTextures = function (k, lt, yt) {
        const Tt = kt.get(k);
        (Tt.__autoAllocateDepthBuffer = k.resolveDepthBuffer === !1),
          Tt.__autoAllocateDepthBuffer === !1 && (Tt.__useRenderToTexture = !1),
          (kt.get(k.texture).__webglTexture = lt),
          (kt.get(k.depthTexture).__webglTexture = Tt.__autoAllocateDepthBuffer ? void 0 : yt),
          (Tt.__hasExternalTextures = !0);
      }),
      (this.setRenderTargetFramebuffer = function (k, lt) {
        const yt = kt.get(k);
        (yt.__webglFramebuffer = lt), (yt.__useDefaultFramebuffer = lt === void 0);
      });
    const Ro = G.createFramebuffer();
    (this.setRenderTarget = function (k, lt = 0, yt = 0) {
      (J = k), (Z = lt), (V = yt);
      let Tt = !0,
        ut = null,
        Vt = !1,
        Kt = !1;
      if (k) {
        const se = kt.get(k);
        if (se.__useDefaultFramebuffer !== void 0)
          Lt.bindFramebuffer(G.FRAMEBUFFER, null), (Tt = !1);
        else if (se.__webglFramebuffer === void 0) H.setupRenderTarget(k);
        else if (se.__hasExternalTextures)
          H.rebindTextures(
            k,
            kt.get(k.texture).__webglTexture,
            kt.get(k.depthTexture).__webglTexture,
          );
        else if (k.depthBuffer) {
          const ve = k.depthTexture;
          if (se.__boundDepthTexture !== ve) {
            if (
              ve !== null &&
              kt.has(ve) &&
              (k.width !== ve.image.width || k.height !== ve.image.height)
            )
              throw new Error(
                'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.',
              );
            H.setupDepthRenderbuffer(k);
          }
        }
        const Ee = k.texture;
        (Ee.isData3DTexture || Ee.isDataArrayTexture || Ee.isCompressedArrayTexture) && (Kt = !0);
        const be = kt.get(k).__webglFramebuffer;
        k.isWebGLCubeRenderTarget
          ? (Array.isArray(be[lt]) ? (ut = be[lt][yt]) : (ut = be[lt]), (Vt = !0))
          : k.samples > 0 && H.useMultisampledRTT(k) === !1
            ? (ut = kt.get(k).__webglMultisampledFramebuffer)
            : Array.isArray(be)
              ? (ut = be[yt])
              : (ut = be),
          j.copy(k.viewport),
          ft.copy(k.scissor),
          (pt = k.scissorTest);
      } else j.copy(Q).multiplyScalar(K).floor(), ft.copy(gt).multiplyScalar(K).floor(), (pt = At);
      if (
        (yt !== 0 && (ut = Ro),
        Lt.bindFramebuffer(G.FRAMEBUFFER, ut) && Tt && Lt.drawBuffers(k, ut),
        Lt.viewport(j),
        Lt.scissor(ft),
        Lt.setScissorTest(pt),
        Vt)
      ) {
        const se = kt.get(k.texture);
        G.framebufferTexture2D(
          G.FRAMEBUFFER,
          G.COLOR_ATTACHMENT0,
          G.TEXTURE_CUBE_MAP_POSITIVE_X + lt,
          se.__webglTexture,
          yt,
        );
      } else if (Kt) {
        const se = kt.get(k.texture),
          Ee = lt;
        G.framebufferTextureLayer(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, se.__webglTexture, yt, Ee);
      } else if (k !== null && yt !== 0) {
        const se = kt.get(k.texture);
        G.framebufferTexture2D(
          G.FRAMEBUFFER,
          G.COLOR_ATTACHMENT0,
          G.TEXTURE_2D,
          se.__webglTexture,
          yt,
        );
      }
      F = -1;
    }),
      (this.readRenderTargetPixels = function (k, lt, yt, Tt, ut, Vt, Kt) {
        if (!(k && k.isWebGLRenderTarget)) {
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
          );
          return;
        }
        let Jt = kt.get(k).__webglFramebuffer;
        if ((k.isWebGLCubeRenderTarget && Kt !== void 0 && (Jt = Jt[Kt]), Jt)) {
          Lt.bindFramebuffer(G.FRAMEBUFFER, Jt);
          try {
            const se = k.texture,
              Ee = se.format,
              be = se.type;
            if (!Ut.textureFormatReadable(Ee)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
              );
              return;
            }
            if (!Ut.textureTypeReadable(be)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
              );
              return;
            }
            lt >= 0 &&
              lt <= k.width - Tt &&
              yt >= 0 &&
              yt <= k.height - ut &&
              G.readPixels(lt, yt, Tt, ut, Me.convert(Ee), Me.convert(be), Vt);
          } finally {
            const se = J !== null ? kt.get(J).__webglFramebuffer : null;
            Lt.bindFramebuffer(G.FRAMEBUFFER, se);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (k, lt, yt, Tt, ut, Vt, Kt) {
        if (!(k && k.isWebGLRenderTarget))
          throw new Error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
          );
        let Jt = kt.get(k).__webglFramebuffer;
        if ((k.isWebGLCubeRenderTarget && Kt !== void 0 && (Jt = Jt[Kt]), Jt))
          if (lt >= 0 && lt <= k.width - Tt && yt >= 0 && yt <= k.height - ut) {
            Lt.bindFramebuffer(G.FRAMEBUFFER, Jt);
            const se = k.texture,
              Ee = se.format,
              be = se.type;
            if (!Ut.textureFormatReadable(Ee))
              throw new Error(
                'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.',
              );
            if (!Ut.textureTypeReadable(be))
              throw new Error(
                'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.',
              );
            const ve = G.createBuffer();
            G.bindBuffer(G.PIXEL_PACK_BUFFER, ve),
              G.bufferData(G.PIXEL_PACK_BUFFER, Vt.byteLength, G.STREAM_READ),
              G.readPixels(lt, yt, Tt, ut, Me.convert(Ee), Me.convert(be), 0);
            const Ue = J !== null ? kt.get(J).__webglFramebuffer : null;
            Lt.bindFramebuffer(G.FRAMEBUFFER, Ue);
            const ue = G.fenceSync(G.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              G.flush(),
              await TA(G, ue, 4),
              G.bindBuffer(G.PIXEL_PACK_BUFFER, ve),
              G.getBufferSubData(G.PIXEL_PACK_BUFFER, 0, Vt),
              G.deleteBuffer(ve),
              G.deleteSync(ue),
              Vt
            );
          } else
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.',
            );
      }),
      (this.copyFramebufferToTexture = function (k, lt = null, yt = 0) {
        const Tt = Math.pow(2, -yt),
          ut = Math.floor(k.image.width * Tt),
          Vt = Math.floor(k.image.height * Tt),
          Kt = lt !== null ? lt.x : 0,
          Jt = lt !== null ? lt.y : 0;
        H.setTexture2D(k, 0),
          G.copyTexSubImage2D(G.TEXTURE_2D, yt, 0, 0, Kt, Jt, ut, Vt),
          Lt.unbindTexture();
      });
    const Lo = G.createFramebuffer(),
      ya = G.createFramebuffer();
    (this.copyTextureToTexture = function (k, lt, yt = null, Tt = null, ut = 0, Vt = null) {
      Vt === null &&
        (ut !== 0
          ? (Pf(
              'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.',
            ),
            (Vt = ut),
            (ut = 0))
          : (Vt = 0));
      let Kt, Jt, se, Ee, be, ve, Ue, ue, Re;
      const ke = k.isCompressedTexture ? k.mipmaps[Vt] : k.image;
      if (yt !== null)
        (Kt = yt.max.x - yt.min.x),
          (Jt = yt.max.y - yt.min.y),
          (se = yt.isBox3 ? yt.max.z - yt.min.z : 1),
          (Ee = yt.min.x),
          (be = yt.min.y),
          (ve = yt.isBox3 ? yt.min.z : 0);
      else {
        const mn = Math.pow(2, -ut);
        (Kt = Math.floor(ke.width * mn)),
          (Jt = Math.floor(ke.height * mn)),
          k.isDataArrayTexture
            ? (se = ke.depth)
            : k.isData3DTexture
              ? (se = Math.floor(ke.depth * mn))
              : (se = 1),
          (Ee = 0),
          (be = 0),
          (ve = 0);
      }
      Tt !== null ? ((Ue = Tt.x), (ue = Tt.y), (Re = Tt.z)) : ((Ue = 0), (ue = 0), (Re = 0));
      const ze = Me.convert(lt.format),
        ge = Me.convert(lt.type);
      let gn;
      lt.isData3DTexture
        ? (H.setTexture3D(lt, 0), (gn = G.TEXTURE_3D))
        : lt.isDataArrayTexture || lt.isCompressedArrayTexture
          ? (H.setTexture2DArray(lt, 0), (gn = G.TEXTURE_2D_ARRAY))
          : (H.setTexture2D(lt, 0), (gn = G.TEXTURE_2D)),
        G.pixelStorei(G.UNPACK_FLIP_Y_WEBGL, lt.flipY),
        G.pixelStorei(G.UNPACK_PREMULTIPLY_ALPHA_WEBGL, lt.premultiplyAlpha),
        G.pixelStorei(G.UNPACK_ALIGNMENT, lt.unpackAlignment);
      const ne = G.getParameter(G.UNPACK_ROW_LENGTH),
        We = G.getParameter(G.UNPACK_IMAGE_HEIGHT),
        ea = G.getParameter(G.UNPACK_SKIP_PIXELS),
        nn = G.getParameter(G.UNPACK_SKIP_ROWS),
        Pn = G.getParameter(G.UNPACK_SKIP_IMAGES);
      G.pixelStorei(G.UNPACK_ROW_LENGTH, ke.width),
        G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, ke.height),
        G.pixelStorei(G.UNPACK_SKIP_PIXELS, Ee),
        G.pixelStorei(G.UNPACK_SKIP_ROWS, be),
        G.pixelStorei(G.UNPACK_SKIP_IMAGES, ve);
      const sn = k.isDataArrayTexture || k.isData3DTexture,
        zn = lt.isDataArrayTexture || lt.isData3DTexture;
      if (k.isDepthTexture) {
        const mn = kt.get(k),
          He = kt.get(lt),
          xn = kt.get(mn.__renderTarget),
          hi = kt.get(He.__renderTarget);
        Lt.bindFramebuffer(G.READ_FRAMEBUFFER, xn.__webglFramebuffer),
          Lt.bindFramebuffer(G.DRAW_FRAMEBUFFER, hi.__webglFramebuffer);
        for (let yi = 0; yi < se; yi++)
          sn &&
            (G.framebufferTextureLayer(
              G.READ_FRAMEBUFFER,
              G.COLOR_ATTACHMENT0,
              kt.get(k).__webglTexture,
              ut,
              ve + yi,
            ),
            G.framebufferTextureLayer(
              G.DRAW_FRAMEBUFFER,
              G.COLOR_ATTACHMENT0,
              kt.get(lt).__webglTexture,
              Vt,
              Re + yi,
            )),
            G.blitFramebuffer(Ee, be, Kt, Jt, Ue, ue, Kt, Jt, G.DEPTH_BUFFER_BIT, G.NEAREST);
        Lt.bindFramebuffer(G.READ_FRAMEBUFFER, null), Lt.bindFramebuffer(G.DRAW_FRAMEBUFFER, null);
      } else if (ut !== 0 || k.isRenderTargetTexture || kt.has(k)) {
        const mn = kt.get(k),
          He = kt.get(lt);
        Lt.bindFramebuffer(G.READ_FRAMEBUFFER, Lo), Lt.bindFramebuffer(G.DRAW_FRAMEBUFFER, ya);
        for (let xn = 0; xn < se; xn++)
          sn
            ? G.framebufferTextureLayer(
                G.READ_FRAMEBUFFER,
                G.COLOR_ATTACHMENT0,
                mn.__webglTexture,
                ut,
                ve + xn,
              )
            : G.framebufferTexture2D(
                G.READ_FRAMEBUFFER,
                G.COLOR_ATTACHMENT0,
                G.TEXTURE_2D,
                mn.__webglTexture,
                ut,
              ),
            zn
              ? G.framebufferTextureLayer(
                  G.DRAW_FRAMEBUFFER,
                  G.COLOR_ATTACHMENT0,
                  He.__webglTexture,
                  Vt,
                  Re + xn,
                )
              : G.framebufferTexture2D(
                  G.DRAW_FRAMEBUFFER,
                  G.COLOR_ATTACHMENT0,
                  G.TEXTURE_2D,
                  He.__webglTexture,
                  Vt,
                ),
            ut !== 0
              ? G.blitFramebuffer(Ee, be, Kt, Jt, Ue, ue, Kt, Jt, G.COLOR_BUFFER_BIT, G.NEAREST)
              : zn
                ? G.copyTexSubImage3D(gn, Vt, Ue, ue, Re + xn, Ee, be, Kt, Jt)
                : G.copyTexSubImage2D(gn, Vt, Ue, ue, Ee, be, Kt, Jt);
        Lt.bindFramebuffer(G.READ_FRAMEBUFFER, null), Lt.bindFramebuffer(G.DRAW_FRAMEBUFFER, null);
      } else
        zn
          ? k.isDataTexture || k.isData3DTexture
            ? G.texSubImage3D(gn, Vt, Ue, ue, Re, Kt, Jt, se, ze, ge, ke.data)
            : lt.isCompressedArrayTexture
              ? G.compressedTexSubImage3D(gn, Vt, Ue, ue, Re, Kt, Jt, se, ze, ke.data)
              : G.texSubImage3D(gn, Vt, Ue, ue, Re, Kt, Jt, se, ze, ge, ke)
          : k.isDataTexture
            ? G.texSubImage2D(G.TEXTURE_2D, Vt, Ue, ue, Kt, Jt, ze, ge, ke.data)
            : k.isCompressedTexture
              ? G.compressedTexSubImage2D(
                  G.TEXTURE_2D,
                  Vt,
                  Ue,
                  ue,
                  ke.width,
                  ke.height,
                  ze,
                  ke.data,
                )
              : G.texSubImage2D(G.TEXTURE_2D, Vt, Ue, ue, Kt, Jt, ze, ge, ke);
      G.pixelStorei(G.UNPACK_ROW_LENGTH, ne),
        G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, We),
        G.pixelStorei(G.UNPACK_SKIP_PIXELS, ea),
        G.pixelStorei(G.UNPACK_SKIP_ROWS, nn),
        G.pixelStorei(G.UNPACK_SKIP_IMAGES, Pn),
        Vt === 0 && lt.generateMipmaps && G.generateMipmap(gn),
        Lt.unbindTexture();
    }),
      (this.copyTextureToTexture3D = function (k, lt, yt = null, Tt = null, ut = 0) {
        return (
          Pf(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.',
          ),
          this.copyTextureToTexture(k, lt, yt, Tt, ut)
        );
      }),
      (this.initRenderTarget = function (k) {
        kt.get(k).__webglFramebuffer === void 0 && H.setupRenderTarget(k);
      }),
      (this.initTexture = function (k) {
        k.isCubeTexture
          ? H.setTextureCube(k, 0)
          : k.isData3DTexture
            ? H.setTexture3D(k, 0)
            : k.isDataArrayTexture || k.isCompressedArrayTexture
              ? H.setTexture2DArray(k, 0)
              : H.setTexture2D(k, 0),
          Lt.unbindTexture();
      }),
      (this.resetState = function () {
        (Z = 0), (V = 0), (J = null), Lt.reset(), Je.reset();
      }),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
  }
  get coordinateSystem() {
    return Ur;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(t) {
    this._outputColorSpace = t;
    const e = this.getContext();
    (e.drawingBufferColorSpace = en._getDrawingBufferColorSpace(t)),
      (e.unpackColorSpace = en._getUnpackColorSpace());
  }
}
const kx = { type: 'change' },
  cg = { type: 'start' },
  MM = { type: 'end' },
  vf = new ig(),
  Fx = new Ls(),
  RP = Math.cos(70 * bA.DEG2RAD),
  jn = new et(),
  Ui = 2 * Math.PI,
  pn = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6,
  },
  Pm = 1e-6;
class LP extends Z2 {
  constructor(t, e = null) {
    super(t, e),
      (this.state = pn.NONE),
      (this.target = new et()),
      (this.cursor = new et()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minTargetRadius = 0),
      (this.maxTargetRadius = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.keyRotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.zoomToCursor = !1),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }),
      (this.mouseButtons = { LEFT: Nl.ROTATE, MIDDLE: Nl.DOLLY, RIGHT: Nl.PAN }),
      (this.touches = { ONE: Rl.ROTATE, TWO: Rl.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this._lastPosition = new et()),
      (this._lastQuaternion = new kr()),
      (this._lastTargetPosition = new et()),
      (this._quat = new kr().setFromUnitVectors(t.up, new et(0, 1, 0))),
      (this._quatInverse = this._quat.clone().invert()),
      (this._spherical = new dx()),
      (this._sphericalDelta = new dx()),
      (this._scale = 1),
      (this._panOffset = new et()),
      (this._rotateStart = new Yt()),
      (this._rotateEnd = new Yt()),
      (this._rotateDelta = new Yt()),
      (this._panStart = new Yt()),
      (this._panEnd = new Yt()),
      (this._panDelta = new Yt()),
      (this._dollyStart = new Yt()),
      (this._dollyEnd = new Yt()),
      (this._dollyDelta = new Yt()),
      (this._dollyDirection = new et()),
      (this._mouse = new Yt()),
      (this._performCursorZoom = !1),
      (this._pointers = []),
      (this._pointerPositions = {}),
      (this._controlActive = !1),
      (this._onPointerMove = DP.bind(this)),
      (this._onPointerDown = PP.bind(this)),
      (this._onPointerUp = OP.bind(this)),
      (this._onContextMenu = FP.bind(this)),
      (this._onMouseWheel = zP.bind(this)),
      (this._onKeyDown = IP.bind(this)),
      (this._onTouchStart = BP.bind(this)),
      (this._onTouchMove = kP.bind(this)),
      (this._onMouseDown = UP.bind(this)),
      (this._onMouseMove = NP.bind(this)),
      (this._interceptControlDown = HP.bind(this)),
      (this._interceptControlUp = GP.bind(this)),
      this.domElement !== null && this.connect(this.domElement),
      this.update();
  }
  connect(t) {
    super.connect(t),
      this.domElement.addEventListener('pointerdown', this._onPointerDown),
      this.domElement.addEventListener('pointercancel', this._onPointerUp),
      this.domElement.addEventListener('contextmenu', this._onContextMenu),
      this.domElement.addEventListener('wheel', this._onMouseWheel, { passive: !1 }),
      this.domElement
        .getRootNode()
        .addEventListener('keydown', this._interceptControlDown, { passive: !0, capture: !0 }),
      (this.domElement.style.touchAction = 'none');
  }
  disconnect() {
    this.domElement.removeEventListener('pointerdown', this._onPointerDown),
      this.domElement.removeEventListener('pointermove', this._onPointerMove),
      this.domElement.removeEventListener('pointerup', this._onPointerUp),
      this.domElement.removeEventListener('pointercancel', this._onPointerUp),
      this.domElement.removeEventListener('wheel', this._onMouseWheel),
      this.domElement.removeEventListener('contextmenu', this._onContextMenu),
      this.stopListenToKeyEvents(),
      this.domElement
        .getRootNode()
        .removeEventListener('keydown', this._interceptControlDown, { capture: !0 }),
      (this.domElement.style.touchAction = 'auto');
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(t) {
    t.addEventListener('keydown', this._onKeyDown), (this._domElementKeyEvents = t);
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null &&
      (this._domElementKeyEvents.removeEventListener('keydown', this._onKeyDown),
      (this._domElementKeyEvents = null));
  }
  saveState() {
    this.target0.copy(this.target),
      this.position0.copy(this.object.position),
      (this.zoom0 = this.object.zoom);
  }
  reset() {
    this.target.copy(this.target0),
      this.object.position.copy(this.position0),
      (this.object.zoom = this.zoom0),
      this.object.updateProjectionMatrix(),
      this.dispatchEvent(kx),
      this.update(),
      (this.state = pn.NONE);
  }
  update(t = null) {
    const e = this.object.position;
    jn.copy(e).sub(this.target),
      jn.applyQuaternion(this._quat),
      this._spherical.setFromVector3(jn),
      this.autoRotate && this.state === pn.NONE && this._rotateLeft(this._getAutoRotationAngle(t)),
      this.enableDamping
        ? ((this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor),
          (this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor))
        : ((this._spherical.theta += this._sphericalDelta.theta),
          (this._spherical.phi += this._sphericalDelta.phi));
    let s = this.minAzimuthAngle,
      l = this.maxAzimuthAngle;
    isFinite(s) &&
      isFinite(l) &&
      (s < -Math.PI ? (s += Ui) : s > Math.PI && (s -= Ui),
      l < -Math.PI ? (l += Ui) : l > Math.PI && (l -= Ui),
      s <= l
        ? (this._spherical.theta = Math.max(s, Math.min(l, this._spherical.theta)))
        : (this._spherical.theta =
            this._spherical.theta > (s + l) / 2
              ? Math.max(s, this._spherical.theta)
              : Math.min(l, this._spherical.theta))),
      (this._spherical.phi = Math.max(
        this.minPolarAngle,
        Math.min(this.maxPolarAngle, this._spherical.phi),
      )),
      this._spherical.makeSafe(),
      this.enableDamping === !0
        ? this.target.addScaledVector(this._panOffset, this.dampingFactor)
        : this.target.add(this._panOffset),
      this.target.sub(this.cursor),
      this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
      this.target.add(this.cursor);
    let h = !1;
    if ((this.zoomToCursor && this._performCursorZoom) || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const f = this._spherical.radius;
      (this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale)),
        (h = f != this._spherical.radius);
    }
    if (
      (jn.setFromSpherical(this._spherical),
      jn.applyQuaternion(this._quatInverse),
      e.copy(this.target).add(jn),
      this.object.lookAt(this.target),
      this.enableDamping === !0
        ? ((this._sphericalDelta.theta *= 1 - this.dampingFactor),
          (this._sphericalDelta.phi *= 1 - this.dampingFactor),
          this._panOffset.multiplyScalar(1 - this.dampingFactor))
        : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)),
      this.zoomToCursor && this._performCursorZoom)
    ) {
      let f = null;
      if (this.object.isPerspectiveCamera) {
        const m = jn.length();
        f = this._clampDistance(m * this._scale);
        const _ = m - f;
        this.object.position.addScaledVector(this._dollyDirection, _),
          this.object.updateMatrixWorld(),
          (h = !!_);
      } else if (this.object.isOrthographicCamera) {
        const m = new et(this._mouse.x, this._mouse.y, 0);
        m.unproject(this.object);
        const _ = this.object.zoom;
        (this.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom / this._scale),
        )),
          this.object.updateProjectionMatrix(),
          (h = _ !== this.object.zoom);
        const g = new et(this._mouse.x, this._mouse.y, 0);
        g.unproject(this.object),
          this.object.position.sub(g).add(m),
          this.object.updateMatrixWorld(),
          (f = jn.length());
      } else
        console.warn(
          'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.',
        ),
          (this.zoomToCursor = !1);
      f !== null &&
        (this.screenSpacePanning
          ? this.target
              .set(0, 0, -1)
              .transformDirection(this.object.matrix)
              .multiplyScalar(f)
              .add(this.object.position)
          : (vf.origin.copy(this.object.position),
            vf.direction.set(0, 0, -1).transformDirection(this.object.matrix),
            Math.abs(this.object.up.dot(vf.direction)) < RP
              ? this.object.lookAt(this.target)
              : (Fx.setFromNormalAndCoplanarPoint(this.object.up, this.target),
                vf.intersectPlane(Fx, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const f = this.object.zoom;
      (this.object.zoom = Math.max(
        this.minZoom,
        Math.min(this.maxZoom, this.object.zoom / this._scale),
      )),
        f !== this.object.zoom && (this.object.updateProjectionMatrix(), (h = !0));
    }
    return (
      (this._scale = 1),
      (this._performCursorZoom = !1),
      h ||
      this._lastPosition.distanceToSquared(this.object.position) > Pm ||
      8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > Pm ||
      this._lastTargetPosition.distanceToSquared(this.target) > Pm
        ? (this.dispatchEvent(kx),
          this._lastPosition.copy(this.object.position),
          this._lastQuaternion.copy(this.object.quaternion),
          this._lastTargetPosition.copy(this.target),
          !0)
        : !1
    );
  }
  _getAutoRotationAngle(t) {
    return t !== null
      ? (Ui / 60) * this.autoRotateSpeed * t
      : (Ui / 60 / 60) * this.autoRotateSpeed;
  }
  _getZoomScale(t) {
    const e = Math.abs(t * 0.01);
    return Math.pow(0.95, this.zoomSpeed * e);
  }
  _rotateLeft(t) {
    this._sphericalDelta.theta -= t;
  }
  _rotateUp(t) {
    this._sphericalDelta.phi -= t;
  }
  _panLeft(t, e) {
    jn.setFromMatrixColumn(e, 0), jn.multiplyScalar(-t), this._panOffset.add(jn);
  }
  _panUp(t, e) {
    this.screenSpacePanning === !0
      ? jn.setFromMatrixColumn(e, 1)
      : (jn.setFromMatrixColumn(e, 0), jn.crossVectors(this.object.up, jn)),
      jn.multiplyScalar(t),
      this._panOffset.add(jn);
  }
  _pan(t, e) {
    const s = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const l = this.object.position;
      jn.copy(l).sub(this.target);
      let h = jn.length();
      (h *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
        this._panLeft((2 * t * h) / s.clientHeight, this.object.matrix),
        this._panUp((2 * e * h) / s.clientHeight, this.object.matrix);
    } else
      this.object.isOrthographicCamera
        ? (this._panLeft(
            (t * (this.object.right - this.object.left)) / this.object.zoom / s.clientWidth,
            this.object.matrix,
          ),
          this._panUp(
            (e * (this.object.top - this.object.bottom)) / this.object.zoom / s.clientHeight,
            this.object.matrix,
          ))
        : (console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.',
          ),
          (this.enablePan = !1));
  }
  _dollyOut(t) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera
      ? (this._scale /= t)
      : (console.warn(
          'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',
        ),
        (this.enableZoom = !1));
  }
  _dollyIn(t) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera
      ? (this._scale *= t)
      : (console.warn(
          'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',
        ),
        (this.enableZoom = !1));
  }
  _updateZoomParameters(t, e) {
    if (!this.zoomToCursor) return;
    this._performCursorZoom = !0;
    const s = this.domElement.getBoundingClientRect(),
      l = t - s.left,
      h = e - s.top,
      f = s.width,
      m = s.height;
    (this._mouse.x = (l / f) * 2 - 1),
      (this._mouse.y = -(h / m) * 2 + 1),
      this._dollyDirection
        .set(this._mouse.x, this._mouse.y, 1)
        .unproject(this.object)
        .sub(this.object.position)
        .normalize();
  }
  _clampDistance(t) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, t));
  }
  _handleMouseDownRotate(t) {
    this._rotateStart.set(t.clientX, t.clientY);
  }
  _handleMouseDownDolly(t) {
    this._updateZoomParameters(t.clientX, t.clientX), this._dollyStart.set(t.clientX, t.clientY);
  }
  _handleMouseDownPan(t) {
    this._panStart.set(t.clientX, t.clientY);
  }
  _handleMouseMoveRotate(t) {
    this._rotateEnd.set(t.clientX, t.clientY),
      this._rotateDelta
        .subVectors(this._rotateEnd, this._rotateStart)
        .multiplyScalar(this.rotateSpeed);
    const e = this.domElement;
    this._rotateLeft((Ui * this._rotateDelta.x) / e.clientHeight),
      this._rotateUp((Ui * this._rotateDelta.y) / e.clientHeight),
      this._rotateStart.copy(this._rotateEnd),
      this.update();
  }
  _handleMouseMoveDolly(t) {
    this._dollyEnd.set(t.clientX, t.clientY),
      this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
      this._dollyDelta.y > 0
        ? this._dollyOut(this._getZoomScale(this._dollyDelta.y))
        : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
      this._dollyStart.copy(this._dollyEnd),
      this.update();
  }
  _handleMouseMovePan(t) {
    this._panEnd.set(t.clientX, t.clientY),
      this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
      this._pan(this._panDelta.x, this._panDelta.y),
      this._panStart.copy(this._panEnd),
      this.update();
  }
  _handleMouseWheel(t) {
    this._updateZoomParameters(t.clientX, t.clientY),
      t.deltaY < 0
        ? this._dollyIn(this._getZoomScale(t.deltaY))
        : t.deltaY > 0 && this._dollyOut(this._getZoomScale(t.deltaY)),
      this.update();
  }
  _handleKeyDown(t) {
    let e = !1;
    switch (t.code) {
      case this.keys.UP:
        t.ctrlKey || t.metaKey || t.shiftKey
          ? this.enableRotate &&
            this._rotateUp((Ui * this.keyRotateSpeed) / this.domElement.clientHeight)
          : this.enablePan && this._pan(0, this.keyPanSpeed),
          (e = !0);
        break;
      case this.keys.BOTTOM:
        t.ctrlKey || t.metaKey || t.shiftKey
          ? this.enableRotate &&
            this._rotateUp((-Ui * this.keyRotateSpeed) / this.domElement.clientHeight)
          : this.enablePan && this._pan(0, -this.keyPanSpeed),
          (e = !0);
        break;
      case this.keys.LEFT:
        t.ctrlKey || t.metaKey || t.shiftKey
          ? this.enableRotate &&
            this._rotateLeft((Ui * this.keyRotateSpeed) / this.domElement.clientHeight)
          : this.enablePan && this._pan(this.keyPanSpeed, 0),
          (e = !0);
        break;
      case this.keys.RIGHT:
        t.ctrlKey || t.metaKey || t.shiftKey
          ? this.enableRotate &&
            this._rotateLeft((-Ui * this.keyRotateSpeed) / this.domElement.clientHeight)
          : this.enablePan && this._pan(-this.keyPanSpeed, 0),
          (e = !0);
        break;
    }
    e && (t.preventDefault(), this.update());
  }
  _handleTouchStartRotate(t) {
    if (this._pointers.length === 1) this._rotateStart.set(t.pageX, t.pageY);
    else {
      const e = this._getSecondPointerPosition(t),
        s = 0.5 * (t.pageX + e.x),
        l = 0.5 * (t.pageY + e.y);
      this._rotateStart.set(s, l);
    }
  }
  _handleTouchStartPan(t) {
    if (this._pointers.length === 1) this._panStart.set(t.pageX, t.pageY);
    else {
      const e = this._getSecondPointerPosition(t),
        s = 0.5 * (t.pageX + e.x),
        l = 0.5 * (t.pageY + e.y);
      this._panStart.set(s, l);
    }
  }
  _handleTouchStartDolly(t) {
    const e = this._getSecondPointerPosition(t),
      s = t.pageX - e.x,
      l = t.pageY - e.y,
      h = Math.sqrt(s * s + l * l);
    this._dollyStart.set(0, h);
  }
  _handleTouchStartDollyPan(t) {
    this.enableZoom && this._handleTouchStartDolly(t),
      this.enablePan && this._handleTouchStartPan(t);
  }
  _handleTouchStartDollyRotate(t) {
    this.enableZoom && this._handleTouchStartDolly(t),
      this.enableRotate && this._handleTouchStartRotate(t);
  }
  _handleTouchMoveRotate(t) {
    if (this._pointers.length == 1) this._rotateEnd.set(t.pageX, t.pageY);
    else {
      const s = this._getSecondPointerPosition(t),
        l = 0.5 * (t.pageX + s.x),
        h = 0.5 * (t.pageY + s.y);
      this._rotateEnd.set(l, h);
    }
    this._rotateDelta
      .subVectors(this._rotateEnd, this._rotateStart)
      .multiplyScalar(this.rotateSpeed);
    const e = this.domElement;
    this._rotateLeft((Ui * this._rotateDelta.x) / e.clientHeight),
      this._rotateUp((Ui * this._rotateDelta.y) / e.clientHeight),
      this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(t) {
    if (this._pointers.length === 1) this._panEnd.set(t.pageX, t.pageY);
    else {
      const e = this._getSecondPointerPosition(t),
        s = 0.5 * (t.pageX + e.x),
        l = 0.5 * (t.pageY + e.y);
      this._panEnd.set(s, l);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
      this._pan(this._panDelta.x, this._panDelta.y),
      this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(t) {
    const e = this._getSecondPointerPosition(t),
      s = t.pageX - e.x,
      l = t.pageY - e.y,
      h = Math.sqrt(s * s + l * l);
    this._dollyEnd.set(0, h),
      this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)),
      this._dollyOut(this._dollyDelta.y),
      this._dollyStart.copy(this._dollyEnd);
    const f = (t.pageX + e.x) * 0.5,
      m = (t.pageY + e.y) * 0.5;
    this._updateZoomParameters(f, m);
  }
  _handleTouchMoveDollyPan(t) {
    this.enableZoom && this._handleTouchMoveDolly(t), this.enablePan && this._handleTouchMovePan(t);
  }
  _handleTouchMoveDollyRotate(t) {
    this.enableZoom && this._handleTouchMoveDolly(t),
      this.enableRotate && this._handleTouchMoveRotate(t);
  }
  _addPointer(t) {
    this._pointers.push(t.pointerId);
  }
  _removePointer(t) {
    delete this._pointerPositions[t.pointerId];
    for (let e = 0; e < this._pointers.length; e++)
      if (this._pointers[e] == t.pointerId) {
        this._pointers.splice(e, 1);
        return;
      }
  }
  _isTrackingPointer(t) {
    for (let e = 0; e < this._pointers.length; e++) if (this._pointers[e] == t.pointerId) return !0;
    return !1;
  }
  _trackPointer(t) {
    let e = this._pointerPositions[t.pointerId];
    e === void 0 && ((e = new Yt()), (this._pointerPositions[t.pointerId] = e)),
      e.set(t.pageX, t.pageY);
  }
  _getSecondPointerPosition(t) {
    const e = t.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[e];
  }
  _customWheelEvent(t) {
    const e = t.deltaMode,
      s = { clientX: t.clientX, clientY: t.clientY, deltaY: t.deltaY };
    switch (e) {
      case 1:
        s.deltaY *= 16;
        break;
      case 2:
        s.deltaY *= 100;
        break;
    }
    return t.ctrlKey && !this._controlActive && (s.deltaY *= 10), s;
  }
}
function PP(a) {
  this.enabled !== !1 &&
    (this._pointers.length === 0 &&
      (this.domElement.setPointerCapture(a.pointerId),
      this.domElement.addEventListener('pointermove', this._onPointerMove),
      this.domElement.addEventListener('pointerup', this._onPointerUp)),
    !this._isTrackingPointer(a) &&
      (this._addPointer(a),
      a.pointerType === 'touch' ? this._onTouchStart(a) : this._onMouseDown(a)));
}
function DP(a) {
  this.enabled !== !1 && (a.pointerType === 'touch' ? this._onTouchMove(a) : this._onMouseMove(a));
}
function OP(a) {
  switch ((this._removePointer(a), this._pointers.length)) {
    case 0:
      this.domElement.releasePointerCapture(a.pointerId),
        this.domElement.removeEventListener('pointermove', this._onPointerMove),
        this.domElement.removeEventListener('pointerup', this._onPointerUp),
        this.dispatchEvent(MM),
        (this.state = pn.NONE);
      break;
    case 1:
      const t = this._pointers[0],
        e = this._pointerPositions[t];
      this._onTouchStart({ pointerId: t, pageX: e.x, pageY: e.y });
      break;
  }
}
function UP(a) {
  let t;
  switch (a.button) {
    case 0:
      t = this.mouseButtons.LEFT;
      break;
    case 1:
      t = this.mouseButtons.MIDDLE;
      break;
    case 2:
      t = this.mouseButtons.RIGHT;
      break;
    default:
      t = -1;
  }
  switch (t) {
    case Nl.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(a), (this.state = pn.DOLLY);
      break;
    case Nl.ROTATE:
      if (a.ctrlKey || a.metaKey || a.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(a), (this.state = pn.PAN);
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(a), (this.state = pn.ROTATE);
      }
      break;
    case Nl.PAN:
      if (a.ctrlKey || a.metaKey || a.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(a), (this.state = pn.ROTATE);
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(a), (this.state = pn.PAN);
      }
      break;
    default:
      this.state = pn.NONE;
  }
  this.state !== pn.NONE && this.dispatchEvent(cg);
}
function NP(a) {
  switch (this.state) {
    case pn.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(a);
      break;
    case pn.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(a);
      break;
    case pn.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(a);
      break;
  }
}
function zP(a) {
  this.enabled === !1 ||
    this.enableZoom === !1 ||
    this.state !== pn.NONE ||
    (a.preventDefault(),
    this.dispatchEvent(cg),
    this._handleMouseWheel(this._customWheelEvent(a)),
    this.dispatchEvent(MM));
}
function IP(a) {
  this.enabled !== !1 && this._handleKeyDown(a);
}
function BP(a) {
  switch ((this._trackPointer(a), this._pointers.length)) {
    case 1:
      switch (this.touches.ONE) {
        case Rl.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(a), (this.state = pn.TOUCH_ROTATE);
          break;
        case Rl.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(a), (this.state = pn.TOUCH_PAN);
          break;
        default:
          this.state = pn.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case Rl.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(a), (this.state = pn.TOUCH_DOLLY_PAN);
          break;
        case Rl.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(a), (this.state = pn.TOUCH_DOLLY_ROTATE);
          break;
        default:
          this.state = pn.NONE;
      }
      break;
    default:
      this.state = pn.NONE;
  }
  this.state !== pn.NONE && this.dispatchEvent(cg);
}
function kP(a) {
  switch ((this._trackPointer(a), this.state)) {
    case pn.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(a), this.update();
      break;
    case pn.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(a), this.update();
      break;
    case pn.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(a), this.update();
      break;
    case pn.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(a), this.update();
      break;
    default:
      this.state = pn.NONE;
  }
}
function FP(a) {
  this.enabled !== !1 && a.preventDefault();
}
function HP(a) {
  a.key === 'Control' &&
    ((this._controlActive = !0),
    this.domElement
      .getRootNode()
      .addEventListener('keyup', this._interceptControlUp, { passive: !0, capture: !0 }));
}
function GP(a) {
  a.key === 'Control' &&
    ((this._controlActive = !1),
    this.domElement
      .getRootNode()
      .removeEventListener('keyup', this._interceptControlUp, { passive: !0, capture: !0 }));
}
const VP = jt.div`
  width: 100vw;
  height: 100vh;
  background: linear-gradient(135deg, #000000 0%, #0a0a1a 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
`,
  WP = jt.canvas`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
`,
  ZP = jt.div`
  position: relative;
  z-index: 2;
  text-align: center;
  padding: 2rem;
`,
  XP = jt.h1`
  font-size: 5rem;
  color: white;
  text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
  margin-bottom: 3rem;
  font-weight: 700;
  letter-spacing: 2px;

  @media (max-width: 768px) {
    font-size: 3rem;
  }
`,
  jP = jt.button`
  background: linear-gradient(45deg, #4caf50, #45a049);
  color: white;
  border: none;
  padding: 1rem 3rem;
  font-size: 1.5rem;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);

  &:hover {
    transform: scale(1.05);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
  }

  @media (max-width: 768px) {
    padding: 0.75rem 2rem;
    font-size: 1.25rem;
  }
`,
  qP = () => {
    const a = ot.useRef(null),
      t = Ao(),
      e = ot.useRef(null);
    ot.useEffect(() => {
      if (!a.current) return;
      const l = new JA(),
        h = new da(75, window.innerWidth / window.innerHeight, 0.1, 1e3),
        f = new CP({ canvas: a.current.querySelector('canvas'), antialias: !0, alpha: !0 });
      f.setSize(window.innerWidth, window.innerHeight), f.setPixelRatio(window.devicePixelRatio);
      const _ = (() => {
          const st = new $i(),
            _t = new T_({ color: 16777215, size: 0.1, transparent: !0 }),
            It = [];
          for (let fe = 0; fe < 1e4; fe++) {
            const oe = (Math.random() - 0.5) * 2e3,
              Ne = (Math.random() - 0.5) * 2e3,
              Te = (Math.random() - 0.5) * 2e3;
            It.push(oe, Ne, Te);
          }
          st.setAttribute('position', new vi(It, 3));
          const Gt = new ix(st, _t);
          return l.add(Gt), Gt;
        })(),
        g = new Ps(5, 64, 64),
        S = new k2().load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
        b = new po({ map: S, specular: new Qe(3355443), shininess: 5 }),
        E = new bn(g, b);
      l.add(E);
      const A = new Ps(5.1, 64, 64),
        R = new po({ color: 30719, transparent: !0, opacity: 0.1 }),
        T = new bn(A, R);
      l.add(T);
      const M = new V2(16777215, 0.5);
      l.add(M);
      const z = new G2(16777215, 1);
      z.position.set(10, 10, 10), l.add(z), h.position.set(0, 0, 12), h.lookAt(0, 0, 0);
      const P = new LP(h, f.domElement);
      (P.enableDamping = !0),
        (P.dampingFactor = 0.05),
        (P.rotateSpeed = 0.5),
        (P.enableZoom = !0),
        (P.minDistance = 8),
        (P.maxDistance = 20),
        (P.minPolarAngle = 0),
        (P.maxPolarAngle = Math.PI);
      const W = (() => {
        const st = new Ll(),
          _t = new po({ color: 14737632, shininess: 100, specular: 4473924 }),
          It = new po({
            color: 8965375,
            transparent: !0,
            opacity: 0.6,
            shininess: 100,
            specular: 16777215,
          }),
          Gt = new po({ color: 4886754, shininess: 100, specular: 4473924 }),
          fe = new po({ color: 6600182, shininess: 100, specular: 4473924 }),
          oe = new po({ color: 9489145, shininess: 100, specular: 4473924 }),
          Ne = new kf(0.1, 0.1, 1.2, 16),
          Te = new bn(Ne, _t);
        (Te.rotation.x = Math.PI / 2), st.add(Te);
        const ye = new kf(0.101, 0.101, 1.2, 16),
          G = new bn(ye, oe);
        (G.rotation.x = Math.PI / 2), st.add(G);
        const Zt = new Ps(0.08, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2),
          Bt = new bn(Zt, It);
        (Bt.rotation.x = Math.PI / 2), Bt.position.set(0, 0.05, 0.4), st.add(Bt);
        const Ut = new C_();
        Ut.moveTo(0, 0),
          Ut.lineTo(0.6, 0.15),
          Ut.lineTo(0.6, 0.25),
          Ut.lineTo(0, 0.1),
          Ut.lineTo(-0.6, 0.25),
          Ut.lineTo(-0.6, 0.15),
          Ut.lineTo(0, 0);
        const Lt = {
            steps: 1,
            depth: 0.05,
            bevelEnabled: !0,
            bevelThickness: 0.02,
            bevelSize: 0.02,
            bevelSegments: 3,
          },
          le = new Ff(Ut, Lt),
          kt = new bn(le, _t);
        (kt.rotation.x = -Math.PI / 2), kt.position.set(0, 0.05, 0), st.add(kt);
        const H = new C_();
        H.moveTo(0, 0),
          H.lineTo(0.55, 0.14),
          H.lineTo(0.55, 0.16),
          H.lineTo(0, 0.08),
          H.lineTo(-0.55, 0.16),
          H.lineTo(-0.55, 0.14),
          H.lineTo(0, 0);
        const O = {
            steps: 1,
            depth: 0.01,
            bevelEnabled: !0,
            bevelThickness: 0.005,
            bevelSize: 0.005,
            bevelSegments: 2,
          },
          rt = new Ff(H, O),
          wt = new bn(rt, Gt);
        (wt.rotation.x = -Math.PI / 2), wt.position.set(0, 0.08, 0.02), st.add(wt);
        const Dt = new bn(rt, Gt);
        (Dt.rotation.x = -Math.PI / 2), Dt.position.set(0, 0.08, -0.02), st.add(Dt);
        const Et = new Ps(0.1, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2),
          Xt = new bn(Et, _t);
        (Xt.rotation.x = Math.PI / 2), Xt.position.set(0, 0, 0.6), st.add(Xt);
        const Wt = new Ps(0.095, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2),
          $t = new bn(Wt, fe);
        ($t.rotation.x = Math.PI / 2), $t.position.set(0, 0.03, 0.6), st.add($t);
        const ce = new Ps(0.101, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2),
          Ht = new bn(ce, oe);
        (Ht.rotation.x = Math.PI / 2), Ht.position.set(0, 0, 0.6), st.add(Ht);
        const re = new Nr(0.25, 0.15, 0.05),
          pe = new bn(re, _t);
        pe.position.set(0, 0.1, -0.5), st.add(pe);
        const Se = new Nr(0.2, 0.005, 0.06),
          Qt = new bn(Se, fe);
        Qt.position.set(0, 0.15, -0.5), st.add(Qt);
        const Oe = new Nr(0.05, 0.15, 0.15),
          Me = new bn(Oe, _t);
        Me.position.set(0, 0.2, -0.5), st.add(Me);
        const Je = new Nr(0.06, 0.005, 0.1),
          nt = new bn(Je, Gt);
        nt.position.set(0, 0.25, -0.5), st.add(nt);
        const qt = new Ll();
        return (
          qt.add(pe), qt.add(Qt), qt.add(Me), qt.add(nt), st.add(qt), (st.rotation.x = Math.PI), st
        );
      })();
      W.position.set(0, 5.5, 0), (e.current = W), l.add(W);
      let Z = 0,
        V = 0,
        J = 0;
      const F = 5.5,
        I = 0.008,
        j = 0.5,
        ft = 1.5,
        pt = 0.8,
        Mt = [],
        bt = 10,
        X = () => {
          const st = new $i(),
            _t = new T_({
              color: 16777215,
              size: 0.08,
              transparent: !0,
              opacity: 0.6,
              blending: Bm,
              sizeAttenuation: !0,
            }),
            It = [],
            Gt = 35;
          for (let Te = 0; Te < Gt; Te++) It.push(new et(0, 0, 0));
          const fe = new Float32Array(It.length * 3),
            oe = new Float32Array(It.length);
          st.setAttribute('position', new ma(fe, 3)), st.setAttribute('opacity', new ma(oe, 1));
          const Ne = new ix(st, _t);
          return l.add(Ne), { trail: Ne, trailPoints: It, opacities: oe };
        },
        { trail: it, trailPoints: K, opacities: zt } = X(),
        { trail: N, trailPoints: Q, opacities: gt } = X(),
        At = () => {
          if (
            (requestAnimationFrame(At),
            (E.rotation.y += 0.001),
            (T.rotation.y += 0.001),
            (_.rotation.y += 1e-4),
            (_.rotation.x += 1e-4),
            e.current)
          ) {
            (Z += I),
              (V = Math.sin(Z * 0.2) * ft + Math.sin(Z * 0.1) * ft * 0.5),
              (J = Math.sin(Z * 0.3) * pt);
            const st = Math.cos(Z) * F,
              _t = Math.sin(Z) * F,
              It = Math.cos(Z + Math.PI / 2) * V,
              Gt = Math.sin(Z + Math.PI / 2) * V,
              fe = st + It,
              oe = _t + Gt,
              Ne = Math.sin(Z * 2) * j + J;
            Mt.unshift(new et(fe, Ne, oe)),
              Mt.length > bt && Mt.pop(),
              e.current.position.set(fe, Ne, oe);
            const Te = 0.6,
              ye = 0.05,
              G = new et(1, 0, 0).applyQuaternion(e.current.quaternion),
              Zt = new et(0, 1, 0).applyQuaternion(e.current.quaternion),
              Bt = new et(0, 0, 1).applyQuaternion(e.current.quaternion),
              Ut = new et()
                .copy(e.current.position)
                .add(G.clone().multiplyScalar(-0.6))
                .add(Zt.clone().multiplyScalar(ye))
                .add(Bt.clone().multiplyScalar(-0.25)),
              Lt = new et()
                .copy(e.current.position)
                .add(G.clone().multiplyScalar(Te))
                .add(Zt.clone().multiplyScalar(ye))
                .add(Bt.clone().multiplyScalar(-0.25)),
              le = Ut.clone();
            (le.x += (Math.random() - 0.5) * 0.03),
              (le.y += (Math.random() - 0.5) * 0.03),
              (le.z += (Math.random() - 0.5) * 0.03),
              K.unshift(le),
              K.pop();
            const kt = Lt.clone();
            (kt.x += (Math.random() - 0.5) * 0.03),
              (kt.y += (Math.random() - 0.5) * 0.03),
              (kt.z += (Math.random() - 0.5) * 0.03),
              Q.unshift(kt),
              Q.pop();
            const H = (Et, Xt, Wt) => {
              const $t = Et.geometry.attributes.position.array;
              for (let ce = 0; ce < Xt.length; ce++) {
                ($t[ce * 3] = Xt[ce].x), ($t[ce * 3 + 1] = Xt[ce].y), ($t[ce * 3 + 2] = Xt[ce].z);
                const Ht = ce / Xt.length;
                Wt[ce] = Math.max(0, Math.exp(-Ht * 4));
              }
              (Et.geometry.attributes.position.needsUpdate = !0),
                (Et.geometry.attributes.opacity.needsUpdate = !0);
            };
            H(it, K, zt), H(N, Q, gt);
            const O = new et(0, 0, 0).sub(e.current.position).normalize();
            let rt;
            Mt.length > 1
              ? (rt = Mt[0].clone().sub(Mt[1]).normalize())
              : (rt = new et(-Math.sin(Z), 0, Math.cos(Z)).normalize());
            const wt = new kr();
            wt.setFromUnitVectors(new et(0, -1, 0), O);
            const Dt = new kr();
            Dt.setFromUnitVectors(new et(0, 0, 1), rt), e.current.quaternion.copy(wt).multiply(Dt);
          }
          P.update(), f.render(l, h);
        };
      At();
      const tt = () => {
        (h.aspect = window.innerWidth / window.innerHeight),
          h.updateProjectionMatrix(),
          f.setSize(window.innerWidth, window.innerHeight);
      };
      return (
        window.addEventListener('resize', tt),
        () => {
          window.removeEventListener('resize', tt),
            l.remove(E, T),
            e.current && l.remove(e.current),
            f.dispose();
        }
      );
    }, []);
    const s = () => {
      t('/main');
    };
    return at.jsxs(VP, {
      ref: a,
      children: [
        at.jsx(WP, {}),
        at.jsxs(ZP, {
          children: [
            at.jsx(XP, { children: 'Topografiewereld' }),
            at.jsx(jP, { onClick: s, children: 'Start' }),
          ],
        }),
      ],
    });
  },
  vo = [
    {
      name: 'Parijs',
      country: 'Frankrijk',
      coordinates: [48.8566, 2.3522],
      package: 'pakket1',
      lat: 48.8566,
      lng: 2.3522,
      continent: 'Europa',
    },
    {
      name: 'Washington',
      country: 'Verenigde Staten',
      coordinates: [38.8951, -77.0364],
      package: 'pakket1',
      lat: 38.8951,
      lng: -77.0364,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Brasília',
      country: 'Brazilië',
      coordinates: [-15.7801, -47.9292],
      package: 'pakket1',
      lat: -15.7801,
      lng: -47.9292,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Londen',
      country: 'Verenigd Koninkrijk',
      coordinates: [51.5074, -0.1278],
      package: 'pakket1',
      lat: 51.5074,
      lng: -0.1278,
      continent: 'Europa',
    },
    {
      name: 'New York',
      country: 'Verenigde Staten',
      coordinates: [40.7128, -74.006],
      package: 'pakket1',
      lat: 40.7128,
      lng: -74.006,
      continent: 'Noord-Amerika',
    },
    {
      name: 'São Paulo',
      country: 'Brazilië',
      coordinates: [-23.5505, -46.6333],
      package: 'pakket1',
      lat: -23.5505,
      lng: -46.6333,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Berlijn',
      country: 'Duitsland',
      coordinates: [52.52, 13.405],
      package: 'pakket1',
      lat: 52.52,
      lng: 13.405,
      continent: 'Europa',
    },
    {
      name: 'Los Angeles',
      country: 'Verenigde Staten',
      coordinates: [34.0522, -118.2437],
      package: 'pakket1',
      lat: 34.0522,
      lng: -118.2437,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Rio de Janeiro',
      country: 'Brazilië',
      coordinates: [-22.9068, -43.1729],
      package: 'pakket1',
      lat: -22.9068,
      lng: -43.1729,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Moskou',
      country: 'Rusland',
      coordinates: [55.7558, 37.6173],
      package: 'pakket1',
      lat: 55.7558,
      lng: 37.6173,
      continent: 'Europa',
    },
    {
      name: 'Chicago',
      country: 'Verenigde Staten',
      coordinates: [41.8781, -87.6298],
      package: 'pakket1',
      lat: 41.8781,
      lng: -87.6298,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Buenos Aires',
      country: 'Argentinië',
      coordinates: [-34.6037, -58.3816],
      package: 'pakket1',
      lat: -34.6037,
      lng: -58.3816,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Athene',
      country: 'Griekenland',
      coordinates: [37.9838, 23.7275],
      package: 'pakket1',
      lat: 37.9838,
      lng: 23.7275,
      continent: 'Europa',
    },
    {
      name: 'Miami',
      country: 'Verenigde Staten',
      coordinates: [25.7617, -80.1918],
      package: 'pakket1',
      lat: 25.7617,
      lng: -80.1918,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Bogotá',
      country: 'Colombia',
      coordinates: [4.711, -74.0721],
      package: 'pakket1',
      lat: 4.711,
      lng: -74.0721,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Madrid',
      country: 'Spanje',
      coordinates: [40.4168, -3.7038],
      package: 'pakket1',
      lat: 40.4168,
      lng: -3.7038,
      continent: 'Europa',
    },
    {
      name: 'Montréal',
      country: 'Canada',
      coordinates: [45.5017, -73.5673],
      package: 'pakket1',
      lat: 45.5017,
      lng: -73.5673,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Caracas',
      country: 'Venezuela',
      coordinates: [10.4806, -66.9036],
      package: 'pakket1',
      lat: 10.4806,
      lng: -66.9036,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Rome',
      country: 'Italië',
      coordinates: [41.9028, 12.4964],
      package: 'pakket1',
      lat: 41.9028,
      lng: 12.4964,
      continent: 'Europa',
    },
    {
      name: 'Mexico-Stad',
      country: 'Mexico',
      coordinates: [19.4326, -99.1332],
      package: 'pakket1',
      lat: 19.4326,
      lng: -99.1332,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Santiago',
      country: 'Chili',
      coordinates: [-33.4489, -70.6693],
      package: 'pakket1',
      lat: -33.4489,
      lng: -70.6693,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Istanbul',
      country: 'Turkije',
      coordinates: [41.0082, 28.9784],
      package: 'pakket1',
      lat: 41.0082,
      lng: 28.9784,
      continent: 'Europa',
    },
    {
      name: 'Havana',
      country: 'Cuba',
      coordinates: [23.1135, -82.3666],
      package: 'pakket1',
      lat: 23.1135,
      lng: -82.3666,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Paramaribo',
      country: 'Suriname',
      coordinates: [5.852, -55.2038],
      package: 'pakket1',
      lat: 5.852,
      lng: -55.2038,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Kaapstad',
      country: 'Zuid-Afrika',
      coordinates: [-33.9249, 18.4241],
      package: 'pakket1',
      lat: -33.9249,
      lng: 18.4241,
      continent: 'Afrika',
    },
    {
      name: 'Jeruzalem',
      country: 'Israël',
      coordinates: [31.7683, 35.2137],
      package: 'pakket1',
      lat: 31.7683,
      lng: 35.2137,
      continent: 'Azië',
    },
    {
      name: 'Sydney',
      country: 'Australië',
      coordinates: [-33.8688, 151.2093],
      package: 'pakket1',
      lat: -33.8688,
      lng: 151.2093,
      continent: 'Australië',
    },
    {
      name: 'Johannesburg',
      country: 'Zuid-Afrika',
      coordinates: [-26.2041, 28.0473],
      package: 'pakket1',
      lat: -26.2041,
      lng: 28.0473,
      continent: 'Afrika',
    },
    {
      name: 'Riad',
      country: 'Saoedi-Arabië',
      coordinates: [24.7136, 46.6753],
      package: 'pakket1',
      lat: 24.7136,
      lng: 46.6753,
      continent: 'Azië',
    },
    {
      name: 'Melbourne',
      country: 'Australië',
      coordinates: [-37.8136, 144.9631],
      package: 'pakket1',
      lat: -37.8136,
      lng: 144.9631,
      continent: 'Australië',
    },
    {
      name: 'Casablanca',
      country: 'Marokko',
      coordinates: [33.5731, -7.5898],
      package: 'pakket1',
      lat: 33.5731,
      lng: -7.5898,
      continent: 'Afrika',
    },
    {
      name: 'Bagdad',
      country: 'Irak',
      coordinates: [33.3152, 44.3661],
      package: 'pakket1',
      lat: 33.3152,
      lng: 44.3661,
      continent: 'Azië',
    },
    {
      name: 'Dakar',
      country: 'Senegal',
      coordinates: [14.7167, -17.4677],
      package: 'pakket1',
      lat: 14.7167,
      lng: -17.4677,
      continent: 'Afrika',
    },
    {
      name: 'Teheran',
      country: 'Iran',
      coordinates: [35.6892, 51.389],
      package: 'pakket1',
      lat: 35.6892,
      lng: 51.389,
      continent: 'Azië',
    },
    {
      name: 'Nairobi',
      country: 'Kenia',
      coordinates: [-1.2921, 36.8219],
      package: 'pakket1',
      lat: -1.2921,
      lng: 36.8219,
      continent: 'Afrika',
    },
    {
      name: 'Kabul',
      country: 'Afghanistan',
      coordinates: [34.5553, 69.2075],
      package: 'pakket1',
      lat: 34.5553,
      lng: 69.2075,
      continent: 'Azië',
    },
    {
      name: 'Accra',
      country: 'Ghana',
      coordinates: [5.6037, -0.187],
      package: 'pakket1',
      lat: 5.6037,
      lng: -0.187,
      continent: 'Afrika',
    },
    {
      name: 'Delhi',
      country: 'India',
      coordinates: [28.6139, 77.209],
      package: 'pakket1',
      lat: 28.6139,
      lng: 77.209,
      continent: 'Azië',
    },
    {
      name: 'Lagos',
      country: 'Nigeria',
      coordinates: [6.5244, 3.3792],
      package: 'pakket1',
      lat: 6.5244,
      lng: 3.3792,
      continent: 'Afrika',
    },
    {
      name: 'Mumbai',
      country: 'India',
      coordinates: [19.076, 72.8777],
      package: 'pakket1',
      lat: 19.076,
      lng: 72.8777,
      continent: 'Azië',
    },
    {
      name: 'Cairo',
      country: 'Egypte',
      coordinates: [30.0444, 31.2357],
      package: 'pakket1',
      lat: 30.0444,
      lng: 31.2357,
      continent: 'Afrika',
    },
    {
      name: 'Bangkok',
      country: 'Thailand',
      coordinates: [13.7563, 100.5018],
      package: 'pakket1',
      lat: 13.7563,
      lng: 100.5018,
      continent: 'Azië',
    },
    {
      name: 'Singapore',
      country: 'Singapore',
      coordinates: [1.3521, 103.8198],
      package: 'pakket1',
      lat: 1.3521,
      lng: 103.8198,
      continent: 'Azië',
    },
    {
      name: 'Jakarta',
      country: 'Indonesië',
      coordinates: [-6.2088, 106.8456],
      package: 'pakket1',
      lat: -6.2088,
      lng: 106.8456,
      continent: 'Azië',
    },
    {
      name: 'Manila',
      country: 'Filipijnen',
      coordinates: [14.5995, 120.9842],
      package: 'pakket1',
      lat: 14.5995,
      lng: 120.9842,
      continent: 'Azië',
    },
    {
      name: 'Tokyo',
      country: 'Japan',
      coordinates: [35.6762, 139.6503],
      package: 'pakket1',
      lat: 35.6762,
      lng: 139.6503,
      continent: 'Azië',
    },
    {
      name: 'Seoul',
      country: 'Zuid-Korea',
      coordinates: [37.5665, 126.978],
      package: 'pakket1',
      lat: 37.5665,
      lng: 126.978,
      continent: 'Azië',
    },
    {
      name: 'Beijing',
      country: 'China',
      coordinates: [39.9042, 116.4074],
      package: 'pakket1',
      lat: 39.9042,
      lng: 116.4074,
      continent: 'Azië',
    },
    {
      name: 'Shanghai',
      country: 'China',
      coordinates: [31.2304, 121.4737],
      package: 'pakket1',
      lat: 31.2304,
      lng: 121.4737,
      continent: 'Azië',
    },
    {
      name: 'Hongkong',
      country: 'China',
      coordinates: [22.3193, 114.1694],
      package: 'pakket1',
      lat: 22.3193,
      lng: 114.1694,
      continent: 'Azië',
    },
    {
      name: 'Kiev',
      country: 'Oekraïne',
      coordinates: [50.4547, 30.5238],
      package: 'pakket2',
      lat: 50.4547,
      lng: 30.5238,
      continent: 'Europa',
    },
    {
      name: 'Wenen',
      country: 'Oostenrijk',
      coordinates: [48.2082, 16.3738],
      package: 'pakket2',
      lat: 48.2082,
      lng: 16.3738,
      continent: 'Europa',
    },
    {
      name: 'San Francisco',
      country: 'Verenigde Staten',
      coordinates: [37.7749, -122.4194],
      package: 'pakket2',
      lat: 37.7749,
      lng: -122.4194,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Detroit',
      country: 'Verenigde Staten',
      coordinates: [42.3314, -83.0458],
      package: 'pakket2',
      lat: 42.3314,
      lng: -83.0458,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Vancouver',
      country: 'Canada',
      coordinates: [49.2827, -123.1207],
      package: 'pakket2',
      lat: 49.2827,
      lng: -123.1207,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Lima',
      country: 'Peru',
      coordinates: [-12.0464, -77.0428],
      package: 'pakket2',
      lat: -12.0464,
      lng: -77.0428,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'La Paz',
      country: 'Bolivia',
      coordinates: [-16.4897, -68.1193],
      package: 'pakket2',
      lat: -16.4897,
      lng: -68.1193,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Kinshasa',
      country: 'Congo',
      coordinates: [-4.4419, 15.2663],
      package: 'pakket2',
      lat: -4.4419,
      lng: 15.2663,
      continent: 'Afrika',
    },
    {
      name: 'Kolkata',
      country: 'India',
      coordinates: [22.5726, 88.3639],
      package: 'pakket2',
      lat: 22.5726,
      lng: 88.3639,
      continent: 'Azië',
    },
    {
      name: 'Perth',
      country: 'Australië',
      coordinates: [-31.9523, 115.8613],
      package: 'pakket2',
      lat: -31.9523,
      lng: 115.8613,
      continent: 'Australië',
    },
    {
      name: 'Addis Abeba',
      country: 'Ethiopië',
      coordinates: [9.032, 38.7488],
      package: 'pakket3',
      lat: 9.032,
      lng: 38.7488,
      continent: 'Afrika',
    },
    {
      name: 'Khartoum',
      country: 'Soedan',
      coordinates: [15.5007, 32.5599],
      package: 'pakket3',
      lat: 15.5007,
      lng: 32.5599,
      continent: 'Afrika',
    },
    {
      name: 'Manaus',
      country: 'Brazilië',
      coordinates: [-3.119, -60.0217],
      package: 'pakket3',
      lat: -3.119,
      lng: -60.0217,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Montevideo',
      country: 'Uruguay',
      coordinates: [-34.9011, -56.1645],
      package: 'pakket3',
      lat: -34.9011,
      lng: -56.1645,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Houston',
      country: 'Verenigde Staten',
      coordinates: [29.7604, -95.3698],
      package: 'pakket3',
      lat: 29.7604,
      lng: -95.3698,
      continent: 'Noord-Amerika',
    },
    {
      name: 'Quito',
      country: 'Ecuador',
      coordinates: [-0.1807, -78.4678],
      package: 'pakket3',
      lat: -0.1807,
      lng: -78.4678,
      continent: 'Zuid-Amerika',
    },
    {
      name: 'Sint Petersburg',
      country: 'Rusland',
      coordinates: [59.9343, 30.3351],
      package: 'pakket3',
      lat: 59.9343,
      lng: 30.3351,
      continent: 'Europa',
    },
    {
      name: 'Stockholm',
      country: 'Zweden',
      coordinates: [59.3293, 18.0686],
      package: 'pakket3',
      lat: 59.3293,
      lng: 18.0686,
      continent: 'Europa',
    },
    {
      name: 'Algiers',
      country: 'Algerije',
      coordinates: [36.7538, 3.0588],
      package: 'pakket3',
      lat: 36.7538,
      lng: 3.0588,
      continent: 'Afrika',
    },
    {
      name: 'Karachi',
      country: 'Pakistan',
      coordinates: [24.8607, 67.0011],
      package: 'pakket3',
      lat: 24.8607,
      lng: 67.0011,
      continent: 'Azië',
    },
    {
      name: 'Kuala Lumpur',
      country: 'Maleisië',
      coordinates: [3.139, 101.6869],
      package: 'pakket3',
      lat: 3.139,
      lng: 101.6869,
      continent: 'Azië',
    },
    {
      name: 'Hanoi',
      country: 'Vietnam',
      coordinates: [21.0285, 105.8542],
      package: 'pakket3',
      lat: 21.0285,
      lng: 105.8542,
      continent: 'Azië',
    },
    {
      name: 'Adelaide',
      country: 'Australië',
      coordinates: [-34.9285, 138.6007],
      package: 'pakket3',
      lat: -34.9285,
      lng: 138.6007,
      continent: 'Australië',
    },
    {
      name: 'Wellington',
      country: 'Nieuw-Zeeland',
      coordinates: [-41.2866, 174.7756],
      package: 'pakket3',
      lat: -41.2866,
      lng: 174.7756,
      continent: 'Australië',
    },
    {
      name: 'Osaka',
      country: 'Japan',
      coordinates: [34.6937, 135.5023],
      package: 'pakket3',
      lat: 34.6937,
      lng: 135.5023,
      continent: 'Azië',
    },
  ],
  YP = jt.svg`
  display: block;
  margin: 0 auto;
`,
  KP = () =>
    at.jsxs(YP, {
      width: '800',
      height: '500',
      viewBox: '0 0 800 500',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      children: [
        at.jsxs('defs', {
          children: [
            at.jsxs('linearGradient', {
              id: 'woodBody',
              x1: '0',
              y1: '0',
              x2: '0',
              y2: '1',
              children: [
                at.jsx('stop', { offset: '0%', stopColor: '#e2b77a' }),
                at.jsx('stop', { offset: '100%', stopColor: '#a97c50' }),
              ],
            }),
            at.jsxs('linearGradient', {
              id: 'woodDoor',
              x1: '0',
              y1: '0',
              x2: '1',
              y2: '1',
              children: [
                at.jsx('stop', { offset: '0%', stopColor: '#e2b77a' }),
                at.jsx('stop', { offset: '100%', stopColor: '#b88a5a' }),
              ],
            }),
            at.jsxs('radialGradient', {
              id: 'shadow',
              cx: '0.5',
              cy: '0.7',
              r: '0.7',
              children: [
                at.jsx('stop', { offset: '0%', stopColor: '#000', stopOpacity: '0.12' }),
                at.jsx('stop', { offset: '100%', stopColor: '#000', stopOpacity: '0' }),
              ],
            }),
          ],
        }),
        at.jsx('rect', {
          x: '180',
          y: '80',
          width: '440',
          height: '340',
          rx: '36',
          fill: 'url(#woodBody)',
          stroke: '#7c5a2a',
          strokeWidth: '8',
        }),
        at.jsx('ellipse', { cx: '400', cy: '320', rx: '180', ry: '60', fill: 'url(#shadow)' }),
        at.jsx('rect', {
          x: '40',
          y: '80',
          width: '140',
          height: '340',
          rx: '28',
          fill: 'url(#woodDoor)',
          stroke: '#7c5a2a',
          strokeWidth: '8',
        }),
        at.jsx('rect', {
          x: '620',
          y: '80',
          width: '140',
          height: '340',
          rx: '28',
          fill: 'url(#woodDoor)',
          stroke: '#7c5a2a',
          strokeWidth: '8',
        }),
        at.jsx('path', {
          d: 'M180 80 Q400 10 620 80',
          fill: 'url(#woodBody)',
          stroke: '#7c5a2a',
          strokeWidth: '8',
        }),
        at.jsx('path', { d: 'M180 80 L180 90', stroke: '#7c5a2a', strokeWidth: '8' }),
        at.jsx('path', { d: 'M620 80 L620 90', stroke: '#7c5a2a', strokeWidth: '8' }),
        at.jsx('rect', {
          x: '210',
          y: '340',
          width: '380',
          height: '22',
          rx: '7',
          fill: '#f5e1b7',
          stroke: '#a97c50',
          strokeWidth: '4',
        }),
        at.jsx('rect', {
          x: '210',
          y: '260',
          width: '380',
          height: '22',
          rx: '7',
          fill: '#f5e1b7',
          stroke: '#a97c50',
          strokeWidth: '4',
        }),
        at.jsx('rect', {
          x: '210',
          y: '180',
          width: '380',
          height: '22',
          rx: '7',
          fill: '#f5e1b7',
          stroke: '#a97c50',
          strokeWidth: '4',
        }),
        at.jsx('ellipse', { cx: '110', cy: '250', rx: '20', ry: '20', fill: '#c49a6c' }),
        at.jsx('ellipse', { cx: '690', cy: '250', rx: '20', ry: '20', fill: '#c49a6c' }),
        at.jsx('ellipse', { cx: '170', cy: '250', rx: '8', ry: '14', fill: '#a67c52' }),
        at.jsx('ellipse', { cx: '630', cy: '250', rx: '8', ry: '14', fill: '#a67c52' }),
      ],
    }),
  Lr = [
    {
      id: 'ribbon-red',
      name: 'Rood lint',
      description: 'Een simpel rood lint om je kast te versieren.',
      price: 100,
      type: 'ribbon',
      icon: '🎗️',
      spot: 1,
      max: 5,
    },
    {
      id: 'ribbon-blue',
      name: 'Blauw lint',
      description: 'Een simpel blauw lint voor je verzameling.',
      price: 120,
      type: 'ribbon',
      icon: '💙',
      spot: 2,
      max: 5,
    },
    {
      id: 'ribbon-gold',
      name: 'Gouden lint',
      description: 'Een glanzend gouden lint voor speciale prestaties.',
      price: 200,
      type: 'ribbon',
      icon: '🏅',
      spot: 3,
      max: 5,
    },
    {
      id: 'mini-trophy',
      name: 'Mini trofee',
      description: 'Een kleine trofee voor je inzet.',
      price: 400,
      type: 'trophy',
      icon: '🏆',
      spot: 4,
      shelf: 1,
    },
    {
      id: 'silver-trophy',
      name: 'Zilveren trofee',
      description: 'Een glanzende zilveren trofee.',
      price: 800,
      type: 'trophy',
      icon: '🥈',
      spot: 5,
      shelf: 1,
    },
    {
      id: 'gold-trophy',
      name: 'Gouden trofee',
      description: 'Een prestigieuze gouden trofee.',
      price: 1200,
      type: 'trophy',
      icon: '🥇',
      spot: 6,
      shelf: 1,
    },
    {
      id: 'globe',
      name: 'Wereldbol',
      description: 'Een prachtige wereldbol voor topografiemeesters.',
      price: 2500,
      type: 'globe',
      icon: '🌍',
      spot: 7,
      shelf: 2,
    },
    {
      id: 'compass',
      name: 'Ontdekkerskompas',
      description: 'Een kompas voor echte ontdekkingsreizigers.',
      price: 2e3,
      type: 'compass',
      icon: '🧭',
      spot: 8,
      shelf: 2,
    },
    {
      id: 'map',
      name: 'Oude kaart',
      description: 'Een zeldzame kaart voor in je kast.',
      price: 3e3,
      type: 'map',
      icon: '🗺️',
      spot: 9,
      shelf: 2,
    },
    {
      id: 'door-sticker',
      name: 'Deur-sticker',
      description: 'Versier je kastdeuren met een leuke sticker.',
      price: 150,
      type: 'decoration',
      icon: '⭐',
      spot: 10,
    },
    {
      id: 'door-ribbon',
      name: 'Deurlint',
      description: 'Een lint om aan je kastdeur te hangen.',
      price: 180,
      type: 'decoration',
      icon: '🎉',
      spot: 11,
    },
    {
      id: 'book',
      name: 'Boek',
      description: 'Een dik aardrijkskundeboek voor in je kast.',
      price: 700,
      type: 'book',
      icon: '📚',
      spot: 12,
      shelf: 1,
    },
    {
      id: 'binoculars',
      name: 'Verrekijker',
      description: 'Voor de echte ontdekkingsreiziger.',
      price: 900,
      type: 'binoculars',
      icon: '🔭',
      spot: 13,
      shelf: 2,
    },
    {
      id: 'atlas',
      name: 'Atlas',
      description: 'Een wereldatlas vol kaarten.',
      price: 1100,
      type: 'atlas',
      icon: '🗃️',
      spot: 14,
      shelf: 2,
    },
    {
      id: 'cup',
      name: 'Beker',
      description: 'Een grote beker voor de winnaar.',
      price: 1500,
      type: 'cup',
      icon: '🏆',
      spot: 15,
      shelf: 1,
    },
    {
      id: 'medal',
      name: 'Medaillon',
      description: 'Een mooie medaille voor bijzondere prestaties.',
      price: 950,
      type: 'medal',
      icon: '🎖️',
      spot: 16,
      shelf: 3,
    },
    {
      id: 'camera',
      name: 'Camera',
      description: 'Leg je ontdekkingen vast met deze camera.',
      price: 850,
      type: 'camera',
      icon: '📷',
      spot: 17,
      shelf: 3,
    },
    {
      id: 'ship',
      name: 'Schip',
      description: 'Voor de avonturier die de wereldzeeën wil bevaren.',
      price: 1300,
      type: 'ship',
      icon: '⛵',
      spot: 18,
      shelf: 1,
    },
    {
      id: 'mountain',
      name: 'Berg',
      description: 'Voor de topografische bergbeklimmer.',
      price: 1200,
      type: 'mountain',
      icon: '⛰️',
      spot: 19,
      shelf: 2,
    },
  ],
  bM = 'topositev2_ribbons_owned',
  EM = 'topositev2_real_prizes_owned';
function QP(a) {
  localStorage.setItem(bM, JSON.stringify(a));
}
function JP() {
  const a = localStorage.getItem(bM);
  if (!a) return {};
  try {
    const t = JSON.parse(a);
    if (typeof t == 'object' && t !== null) return t;
  } catch (t) {
    console.error('Failed to parse ribbons data:', t);
  }
  return {};
}
function $P(a) {
  localStorage.setItem(EM, JSON.stringify(a));
}
function tD() {
  const a = localStorage.getItem(EM);
  if (!a) return [];
  try {
    const t = JSON.parse(a);
    if (Array.isArray(t)) return t;
  } catch (t) {
    console.error('Failed to parse real prizes data:', t);
  }
  return [];
}
const eD = jt.div`
  width: 100vw;
  height: 100vh;
  overflow-y: auto;
  background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
  color: white;
  display: flex;
  flex-direction: column;
`,
  nD = jt.div`
  max-width: 1200px;
  margin: 0 auto 2rem;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
  padding: 1.5rem 0 0.5rem 0;
  z-index: 10;
`,
  iD = jt.div`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
`,
  aD = jt.h1`
  font-size: 2.5rem;
  color: #f1c40f;
  margin: 0;
`,
  rD = jt.div`
  display: flex;
  align-items: center;
  font-size: 1.3rem;
  color: #f1c40f;
  font-weight: bold;
  background: rgba(255, 255, 255, 0.08);
  border-radius: 8px;
  padding: 0.5rem 1.2rem;
  margin-left: 1.5rem;
`,
  sD = jt.span`
  font-size: 1.5rem;
  margin-right: 0.5rem;
`,
  oD = jt.button`
  background: transparent;
  border: 2px solid #f1c40f;
  color: #f1c40f;
  padding: 0.7rem 1.5rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1.1rem;
  margin-top: 1.5rem;
  margin-bottom: 0.5rem;
  align-self: flex-start;
  transition: all 0.2s;
  font-weight: bold;
  letter-spacing: 0.5px;

  &:hover {
    background: #f1c40f;
    color: #2c3e50;
  }
`,
  lD = jt.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  gap: 2.5rem;
`,
  cD = jt.div`
  position: relative;
  width: 800px;
  height: 500px;
  margin-bottom: 2.5rem;
  display: flex;
  justify-content: center;
  align-items: flex-start;
`,
  Hx = jt.div`
  position: absolute;
  left: ${(a) => a.x}px;
  top: ${(a) => a.y}px;
  font-size: 2.2rem;
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;
`,
  uD = jt.div`
  background: rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 1.5rem 1rem;
  min-width: 320px;
  max-width: 600px;
  width: 100%;
  color: #fff;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  display: flex;
  flex-direction: column;
  gap: 1.2rem;
  align-items: center;
  margin-top: 1.5rem;
`,
  hD = jt.h2`
  color: #f1c40f;
  font-size: 1.3rem;
  margin-bottom: 0.5rem;
`,
  fD = jt.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
  gap: 1rem;
  width: 100%;
  max-width: 520px;
  margin: 0 auto;
`,
  dD = jt.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  background: ${({ selected: a }) => (a ? 'rgba(241,196,15,0.18)' : 'rgba(0,0,0,0.08)')};
  border-radius: 8px;
  padding: 0.7rem 0.2rem 0.5rem 0.2rem;
  cursor: pointer;
  border: ${({ selected: a }) => (a ? '2px solid #f1c40f' : '2px solid transparent')};
  transition:
    border 0.2s,
    background 0.2s;
  min-height: 90px;
`,
  pD = jt.span`
  font-size: 2.1rem;
`,
  mD = jt.div`
  font-weight: bold;
  color: #fff;
  font-size: 0.95rem;
  margin-top: 0.3rem;
  text-align: center;
  word-break: break-word;
  max-width: 80px;
`,
  _D = jt.div`
  margin-top: 0.5rem;
  background: rgba(0, 0, 0, 0.13);
  border-radius: 6px;
  padding: 0.6rem 0.7rem;
  text-align: center;
  font-size: 0.97rem;
  color: #fff;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.07);
  word-break: break-word;
  min-width: 120px;
`,
  gD = jt.div`
  font-size: 0.93rem;
  color: #eee;
  margin-bottom: 0.3rem;
  word-break: break-word;
`,
  vD = jt.div`
  color: #f1c40f;
  font-weight: bold;
  font-size: 1.05rem;
  margin-bottom: 0.5rem;
  margin-top: 0.2rem;
`,
  yD = jt.button`
  background: #f1c40f;
  color: #2c3e50;
  border: none;
  padding: 0.4rem 1.1rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1rem;
  font-weight: bold;
  margin-top: 0.2rem;
  transition: background 0.2s;
  &:hover:enabled {
    background: #ffd700;
  }
  &:disabled {
    background: #ccc;
    color: #888;
    cursor: not-allowed;
  }
`,
  Gx = jt.div`
  margin: 3rem auto 1.5rem auto;
  max-width: 400px;
  background: rgba(255, 255, 255, 0.08);
  border-radius: 10px;
  padding: 1.5rem 2rem;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
`,
  xD = jt.form`
  display: flex;
  align-items: center;
  gap: 1rem;
  width: 100%;
  justify-content: center;
  margin-bottom: 0.5rem;
`,
  SD = jt.input`
  padding: 0.5rem 1rem;
  border-radius: 6px;
  border: 1px solid #f1c40f;
  font-size: 1rem;
  margin-right: 1rem;
  flex: 1;
`,
  iu = jt.button`
  background: #f1c40f;
  color: #2c3e50;
  border: none;
  padding: 0.5rem 1.2rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1rem;
  font-weight: bold;
  margin: 0 0.5rem;
  transition: background 0.2s;
  &:hover {
    background: #ffd700;
  }
`,
  MD = jt.button`
  background: transparent;
  color: #f1c40f;
  border: none;
  font-size: 1.1rem;
  font-weight: bold;
  margin-top: 0.7rem;
  cursor: pointer;
  text-decoration: underline;
  &:hover {
    color: #ffd700;
  }
`,
  bD = jt.div`
  color: #f1c40f;
  font-size: 0.9rem;
  margin-top: 2px;
`,
  ED = jt.div`
  display: flex;
  gap: 1rem;
  align-items: center;
  flex-wrap: wrap;
`,
  Vx = jt.div`
  width: 28px;
  height: 28px;
  position: relative;
  &::before {
    content: '🎗️';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    filter: ${(a) => (a.color === 'red' ? 'hue-rotate(0deg)' : 'hue-rotate(200deg)')};
  }
`,
  Wx = jt.h3`
  font-size: 1.2rem;
  font-weight: bold;
  color: #f1c40f;
  margin: 0 0 1rem 0;
  letter-spacing: 0.5px;
  text-align: center;
`,
  Zx = {
    left: [
      { x: 70, y: 120 },
      { x: 110, y: 120 },
      { x: 70, y: 170 },
      { x: 110, y: 170 },
      { x: 90, y: 145 },
    ],
    right: [
      { x: 650, y: 120 },
      { x: 690, y: 120 },
      { x: 650, y: 170 },
      { x: 690, y: 170 },
      { x: 670, y: 145 },
    ],
  },
  TD = { 1: 340, 2: 260, 3: 180 },
  Xx = [240, 290, 340, 390, 440, 490, 540],
  Dm = (a) =>
    typeof a == 'string'
      ? at.jsx('span', { children: a })
      : a
        ? pa.createElement(a, { width: 36, height: 36 })
        : null,
  wD = () => {
    const a = Ao();
    ot.useEffect(() => {
      window.scrollTo(0, 0);
    }, []);
    const [t, e] = ot.useState(zS()),
      [s, l] = ot.useState(''),
      [h, f] = ot.useState(!1),
      [m, _] = ot.useState(null),
      [g, x] = ot.useState(JP()),
      [S, b] = ot.useState(tD());
    ot.useEffect(() => {
      IS(t);
    }, [t]),
      ot.useEffect(() => {
        QP(g);
      }, [g]),
      ot.useEffect(() => {
        $P(S);
      }, [S]);
    const E = (z) => {
        switch (z.id) {
          case 'ribbon-red':
            return { name: 'Rood lint', desc: 'Een simpel rood lint om je kast te versieren.' };
          case 'ribbon-blue':
            return { name: 'Blauw lint', desc: 'Een simpel blauw lint voor je verzameling.' };
          case 'ribbon-gold':
            return {
              name: 'Gouden lint',
              desc: 'Een glanzend gouden lint voor speciale prestaties.',
            };
          case 'mini-trophy':
            return { name: 'Mini trofee', desc: 'Een kleine trofee voor je inzet.' };
          case 'silver-trophy':
            return { name: 'Zilveren trofee', desc: 'Een glanzende zilveren trofee.' };
          case 'gold-trophy':
            return { name: 'Gouden trofee', desc: 'Een prestigieuze gouden trofee.' };
          case 'globe':
            return { name: 'Wereldbol', desc: 'Een prachtige wereldbol voor topografiemeesters.' };
          case 'compass':
            return {
              name: 'Ontdekkerskompas',
              desc: 'Een kompas voor echte ontdekkingsreizigers.',
            };
          case 'map':
            return { name: 'Oude kaart', desc: 'Een zeldzame kaart voor in je kast.' };
          case 'door-sticker':
            return { name: 'Deur-sticker', desc: 'Versier je kastdeuren met een leuke sticker.' };
          case 'door-ribbon':
            return { name: 'Deurlint', desc: 'Een lint om aan je kastdeur te hangen.' };
          case 'book':
            return { name: 'Boek', desc: 'Een dik aardrijkskundeboek voor in je kast.' };
          case 'binoculars':
            return { name: 'Verrekijker', desc: 'Voor de echte ontdekkingsreiziger.' };
          case 'atlas':
            return { name: 'Atlas', desc: 'Een wereldatlas vol kaarten.' };
          case 'cup':
            return { name: 'Beker', desc: 'Een grote beker voor de winnaar.' };
          case 'medal':
            return { name: 'Medaillon', desc: 'Een mooie medaille voor bijzondere prestaties.' };
          case 'camera':
            return { name: 'Camera', desc: 'Leg je ontdekkingen vast met deze camera.' };
          case 'ship':
            return { name: 'Schip', desc: 'Voor de avonturier die de wereldzeeën wil bevaren.' };
          case 'mountain':
            return { name: 'Berg', desc: 'Voor de topografische bergbeklimmer.' };
          default:
            return { name: z.name, desc: z.description };
        }
      },
      A = (z) => {
        z.preventDefault(), s === 'rrrrr' && f(!0);
      },
      R = () => {
        const z = {};
        Lr.filter((P) => P.type === 'ribbon').forEach((P) => {
          z[P.id] = P.max || 5;
        }),
          x(z),
          b(Lr.filter((P) => P.type !== 'ribbon' && P.shelf).map((P) => P.id));
      },
      T = (z, P) => {
        const D = Lr.find((W) => W.id === z);
        if (D)
          if (D.type === 'ribbon') {
            const W = D.max || 5,
              Z = g[z] || 0;
            t >= P && Z < W && (e(t - P), x((V) => ({ ...V, [z]: Z + 1 })), _(null));
          } else t >= P && !S.includes(z) && (e(t - P), b((W) => [...W, z]), _(null));
      },
      M = (z) =>
        Lr.filter((D) => D.type === 'ribbon').findIndex((D) => D.id === z) % 2 === 0
          ? 'left'
          : 'right';
    return at.jsxs(eD, {
      children: [
        at.jsxs(nD, {
          children: [
            at.jsxs(iD, {
              children: [
                at.jsx(aD, { children: '🏆 Trofeeënkast' }),
                at.jsxs(rD, { children: [at.jsx(sD, { children: '🪙' }), t, ' munten'] }),
              ],
            }),
            at.jsx(oD, { onClick: () => a('/main'), children: 'Terug naar hoofdmenu' }),
          ],
        }),
        at.jsxs(lD, {
          children: [
            at.jsxs(cD, {
              children: [
                at.jsx(KP, {}),
                Lr.filter((z) => z.type === 'ribbon').map((z, P) => {
                  const D = g[z.id] || 0,
                    W = M(z.id);
                  return Array.from({ length: D }).map((Z, V) => {
                    const J = Zx[W][V] || Zx[W][0],
                      F = P * 45;
                    let I = Dm(z.icon);
                    return (
                      (z.id === 'ribbon-blue' || z.id === 'ribbon-red') &&
                        (I = at.jsx(Vx, { color: z.id === 'ribbon-blue' ? 'blue' : 'red' })),
                      at.jsx(Hx, { x: J.x, y: J.y + F, children: I }, z.id + '-' + V)
                    );
                  });
                }),
                [1, 2, 3].map((z) =>
                  Lr.filter((D) => D.shelf === z && S.includes(D.id)).map((D, W) => {
                    const Z = Xx[W % Xx.length],
                      V = TD[z];
                    return at.jsx(Hx, { x: Z, y: V, children: Dm(D.icon) }, D.id);
                  }),
                ),
              ],
            }),
            at.jsxs(uD, {
              children: [
                at.jsx(hD, { children: 'Winkel voor prijzen' }),
                at.jsx(fD, {
                  children: Lr.map((z) => {
                    const P = E(z),
                      D = m === z.id;
                    let W = 0,
                      Z = !1;
                    return (
                      z.type === 'ribbon'
                        ? ((W = g[z.id] || 0), (Z = W >= (z.max || 5)))
                        : ((W = S.includes(z.id) ? 1 : 0), (Z = W > 0)),
                      at.jsxs(
                        dD,
                        {
                          selected: D,
                          onClick: () => _(D ? null : z.id),
                          children: [
                            at.jsx(pD, {
                              children:
                                z.id === 'ribbon-blue' || z.id === 'ribbon-red'
                                  ? at.jsx(Vx, { color: z.id === 'ribbon-blue' ? 'blue' : 'red' })
                                  : Dm(z.icon),
                            }),
                            at.jsx(mD, { children: P.name }),
                            z.type === 'ribbon' && W > 0 && at.jsxs(bD, { children: ['x', W] }),
                            D &&
                              at.jsxs(_D, {
                                children: [
                                  at.jsx(gD, { children: P.desc }),
                                  at.jsxs(vD, { children: ['Kost: ', z.price, ' munten'] }),
                                  at.jsx(yD, {
                                    disabled: Z || t < z.price,
                                    onClick: (V) => {
                                      V.stopPropagation(), T(z.id, z.price);
                                    },
                                    children: Z ? 'Max' : 'Koop',
                                  }),
                                ],
                              }),
                          ],
                        },
                        z.id,
                      )
                    );
                  }),
                }),
              ],
            }),
          ],
        }),
        h
          ? at.jsxs(Gx, {
              children: [
                at.jsx(Wx, { children: 'Ontwikkelaarsopties' }),
                at.jsxs(ED, {
                  children: [
                    at.jsx(iu, { onClick: () => e(t + 500), children: '+500 munten' }),
                    at.jsx(iu, { onClick: () => e(0), children: 'Reset munten naar 0' }),
                    at.jsx(iu, { onClick: R, children: 'Vul kast' }),
                    at.jsx(iu, {
                      onClick: () => {
                        const z = {};
                        Lr.filter((P) => P.type === 'ribbon').forEach((P) => {
                          z[P.id] = P.max || 5;
                        }),
                          x(z),
                          b(Lr.filter((P) => P.type !== 'ribbon' && P.shelf).map((P) => P.id)),
                          e(9999);
                      },
                      children: 'Vul kast (max)',
                    }),
                  ],
                }),
                at.jsx(MD, { onClick: () => f(!1), children: 'Sluit ontwikkelaarsopties' }),
              ],
            })
          : at.jsxs(Gx, {
              children: [
                at.jsx(Wx, { children: 'Ontwikkelaarsopties' }),
                at.jsxs(xD, {
                  onSubmit: A,
                  children: [
                    at.jsx(SD, {
                      id: 'devcode',
                      type: 'text',
                      value: s,
                      onChange: (z) => l(z.target.value),
                      placeholder: 'Voer code in...',
                    }),
                    at.jsx(iu, { type: 'submit', children: 'OK' }),
                  ],
                }),
              ],
            }),
      ],
    });
  },
  AD = jt.div`
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #f5f7fa;
`,
  CD = () => {
    const a = Ao(),
      t = (e) => {
        const s = e.startsWith('interactive');
        a(s ? `/interactive/${e}` : `/game/${e}`);
      };
    return at.jsx(ST, { onSelectPackage: t });
  },
  RD = () => {
    const a = Ao(),
      { package: t } = aS(),
      e = (s) => {
        switch (s) {
          case 'pakket1':
            return vo.filter((l) => l.package === 'pakket1');
          case 'pakket2':
            return vo.filter((l) => l.package === 'pakket2');
          case 'pakket3':
            return vo.filter((l) => l.package === 'pakket3');
          case 'pakket1-2':
            return vo.filter((l) => l.package === 'pakket1' || l.package === 'pakket2');
          case 'pakket2-3':
            return vo.filter((l) => l.package === 'pakket2' || l.package === 'pakket3');
          case 'pakket1-2-3':
            return vo;
          default:
            return [];
        }
      };
    return at.jsx(bw, { cities: e(t || ''), onBack: () => a('/main'), selectedPackage: t || '' });
  },
  LD = () => {
    const a = Ao(),
      { package: t } = aS(),
      e = (s) => {
        const l = s.replace('interactive', 'pakket');
        return vo.filter((h) => h.package === l);
      };
    return at.jsx(Uw, { cities: e(t || ''), onBack: () => a('/main'), selectedPackage: t || '' });
  },
  PD = () =>
    at.jsx(c1, {
      children: at.jsx(AD, {
        children: at.jsxs(kE, {
          children: [
            at.jsx(Cl, { path: '/', element: at.jsx(qP, {}) }),
            at.jsx(Cl, { path: '/main', element: at.jsx(CD, {}) }),
            at.jsx(Cl, { path: '/game/:package', element: at.jsx(RD, {}) }),
            at.jsx(Cl, { path: '/interactive/:package', element: at.jsx(LD, {}) }),
            at.jsx(Cl, { path: '/trophy-cabinet', element: at.jsx(wD, {}) }),
          ],
        }),
      }),
    });
qb.createRoot(document.getElementById('root')).render(
  at.jsx(ot.StrictMode, { children: at.jsx(PD, {}) }),
);
